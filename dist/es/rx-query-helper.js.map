{"version":3,"file":"rx-query-helper.js","names":["LOGICAL_OPERATORS","getPrimaryFieldOfPrimaryKey","clone","firstPropertyNameOfObject","toArray","isMaybeReadonlyArray","parseRegex","flatClone","objectPathMonad","compare","mingoSortComparator","newRxError","getMingoQuery","normalizeMangoQuery","schema","mangoQuery","primaryKey","selector","normalizeQueryRegex","normalizedMangoQuery","skip","Object","entries","forEach","field","matcher","$eq","index","indexAr","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","has","add","currentFieldsAmount","currentBestIndexForSort","useIndex","firstWrongIndex","findIndex","indexField","isPrimaryInSort","p","slice","ret","key","value","RegExp","parsed","$regex","pattern","$options","flags","Array","isArray","item","getSortComparator","query","sortParts","sortBlock","direction","values","getValueFn","fun","a","b","i","length","sortPart","valueA","valueB","getQueryMatcher","_schema","mingoQuery","doc","_deleted","cursor","next"],"sources":["../../src/rx-query-helper.ts"],"sourcesContent":["import { LOGICAL_OPERATORS } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    DeterministicSortComparator,\n    FilledMangoQuery,\n    MangoQuery,\n    MangoQuerySortDirection,\n    QueryMatcher,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    clone,\n    firstPropertyNameOfObject,\n    toArray,\n    isMaybeReadonlyArray,\n    parseRegex,\n    flatClone,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils';\nimport {\n    compare as mingoSortComparator\n} from 'mingo/util';\nimport { newRxError } from './rx-error';\nimport { getMingoQuery } from './rx-query-mingo';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    mangoQuery = flatClone(mangoQuery);\n\n    // regex normalization must run before deep clone because deep clone cannot clone RegExp\n    if (mangoQuery.selector) {\n        mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);\n    }\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = clone(mangoQuery) as any;\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         *\n         *\n         * TODO this must work recursive with nested queries that\n         * contain multiple selectors via $and or $or etc.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    (normalizedMangoQuery as any).selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = toArray(normalizedMangoQuery.index);\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similar to how we add the primary key to indexes that do not have it.\n     *\n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         *\n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => {\n                return { [field as any]: 'asc' } as any;\n            });\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => {\n                        return { [field as any]: 'asc' } as any;\n                    });\n                }\n\n            }\n\n            /**\n             * Fall back to the primary key as sort order\n             * if no better one has been found\n             */\n            if (!normalizedMangoQuery.sort) {\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n\n/**\n * @recursive\n * @mutates the input so that we do not have to deep clone\n */\nexport function normalizeQueryRegex(\n    selector: any\n): any {\n    if (typeof selector !== 'object' || selector === null) {\n        return selector;\n    }\n\n    const keys = Object.keys(selector);\n    const ret: any = {};\n    keys.forEach(key => {\n        const value: any = selector[key];\n        if (\n            key === '$regex' &&\n            value instanceof RegExp\n        ) {\n            const parsed = parseRegex(value);\n            ret.$regex = parsed.pattern;\n            ret.$options = parsed.flags;\n        } else if (Array.isArray(value)) {\n            ret[key] = value.map(item => normalizeQueryRegex(item));\n        } else {\n            ret[key] = normalizeQueryRegex(value);\n        }\n    });\n    return ret;\n}\n\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType> | FilledMangoQuery<RxDocumentData<RxDocType>>\n): DeterministicSortComparator<RxDocType> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n    const sortParts: {\n        key: string;\n        direction: MangoQuerySortDirection;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = [];\n    query.sort.forEach(sortBlock => {\n        const key = Object.keys(sortBlock)[0];\n        const direction = Object.values(sortBlock)[0];\n        sortParts.push({\n            key,\n            direction,\n            getValueFn: objectPathMonad(key)\n        });\n    });\n    const fun: DeterministicSortComparator<RxDocType> = (a: RxDocType, b: RxDocType) => {\n        for (let i = 0; i < sortParts.length; ++i) {\n            const sortPart = sortParts[i];\n            const valueA = sortPart.getValueFn(a);\n            const valueB = sortPart.getValueFn(b);\n            if (valueA !== valueB) {\n                const ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n                return ret as any;\n            }\n        }\n    };\n\n    return fun;\n}\n\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher<RxDocType>(\n    _schema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType> | FilledMangoQuery<RxDocumentData<RxDocType>>\n): QueryMatcher<RxDocumentData<RxDocType>> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n\n    const mingoQuery = getMingoQuery(query.selector as any);\n    const fun: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType>) => {\n        if (doc._deleted) {\n            return false;\n        }\n        const cursor = mingoQuery.find([doc]);\n        const next = cursor.next();\n        if (next) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    return fun;\n}\n"],"mappings":"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"}