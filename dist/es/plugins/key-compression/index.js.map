{"version":3,"file":"index.js","names":["createCompressionTable","compressObject","decompressObject","compressedPath","DEFAULT_COMPRESSION_FLAG","createCompressedJsonSchema","compressQuery","overwritable","wrapRxStorageInstance","getPrimaryFieldOfPrimaryKey","flatCloneDocWithMeta","flatClone","isMaybeReadonlyArray","COMPRESSION_STATE_BY_SCHEMA","WeakMap","getCompressionStateByRxJsonSchema","schema","deepFreezeWhenDevMode","compressionState","get","compressionSchema","primaryKey","table","compressedSchema","composedPrimary","newComposedPrimary","key","fields","map","field","separator","indexes","newIndexes","idx","subIdx","set","wrappedKeyCompressionStorage","args","statics","Object","assign","storage","prepareQuery","mutateableQuery","keyCompression","getSortComparator","preparedQuery","comparator","a","b","compressedDocDataA","compressedDocDataB","res","getQueryMatcher","matcher","docData","compressedDocData","ret","createStorageInstance","params","modifyToStorage","compressDocumentData","modifyFromStorage","decompressDocumentData","childSchema","instance","attachments","_attachments"],"sources":["../../../../src/plugins/key-compression/index.ts"],"sourcesContent":["/**\n * this plugin adds the keycompression-capabilities to rxdb\n * if you dont use this, ensure that you set disableKeyComression to false in your schema\n */\n\nimport type {\n    DeterministicSortComparator,\n    QueryMatcher\n} from 'event-reduce-js';\nimport {\n    createCompressionTable,\n    CompressionTable,\n    JsonSchema as KeyCompressionJsonSchema,\n    compressObject,\n    decompressObject,\n    compressedPath,\n    DEFAULT_COMPRESSION_FLAG,\n    createCompressedJsonSchema,\n    compressQuery\n} from 'jsonschema-key-compression';\nimport {\n    overwritable\n} from '../../overwritable';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { flatCloneDocWithMeta } from '../../rx-storage-helper';\n\nimport type {\n    RxJsonSchema,\n    CompositePrimaryKey,\n    RxStorage,\n    RxStorageInstanceCreationParams,\n    RxDocumentData,\n    RxStorageStatics,\n    FilledMangoQuery,\n    PreparedQuery,\n    RxDocumentWriteData\n} from '../../types';\nimport {\n    flatClone,\n    isMaybeReadonlyArray\n} from '../../plugins/utils';\n\ndeclare type CompressionState = {\n    table: CompressionTable;\n    schema: RxJsonSchema<any>;\n    compressedSchema: RxJsonSchema<any>;\n};\n\n/**\n * Cache the compression table and the compressed schema\n * by the storage instance for better performance.\n */\nconst COMPRESSION_STATE_BY_SCHEMA: WeakMap<\nRxJsonSchema<any>,\nCompressionState\n> = new WeakMap();\n\n\nexport function getCompressionStateByRxJsonSchema(\n    schema: RxJsonSchema<any>\n): CompressionState {\n    /**\n     * Because we cache the state by the JsonSchema,\n     * it must be ausured that the given schema object\n     * is never mutated.\n     */\n    overwritable.deepFreezeWhenDevMode(schema);\n\n    let compressionState = COMPRESSION_STATE_BY_SCHEMA.get(schema);\n    if (!compressionState) {\n        const compressionSchema: KeyCompressionJsonSchema = flatClone(schema) as any;\n        delete (compressionSchema as any).primaryKey;\n\n        const table = createCompressionTable(\n            compressionSchema,\n            DEFAULT_COMPRESSION_FLAG,\n            [\n                /**\n                 * Do not compress the primary field\n                 * for easier debugging.\n                 */\n                getPrimaryFieldOfPrimaryKey(schema.primaryKey),\n                '_rev',\n                '_attachments',\n                '_deleted',\n                '_meta'\n            ]\n        );\n\n        delete (compressionSchema as any).primaryKey;\n        const compressedSchema: RxJsonSchema<any> = createCompressedJsonSchema(\n            table,\n            compressionSchema\n        ) as RxJsonSchema<any>;\n\n        // also compress primary key\n        if (typeof schema.primaryKey !== 'string') {\n            const composedPrimary: CompositePrimaryKey<any> = schema.primaryKey;\n            const newComposedPrimary: CompositePrimaryKey<any> = {\n                key: compressedPath(table, composedPrimary.key as string),\n                fields: composedPrimary.fields.map(field => compressedPath(table, field as string)),\n                separator: composedPrimary.separator\n            };\n            compressedSchema.primaryKey = newComposedPrimary;\n        } else {\n            compressedSchema.primaryKey = compressedPath(table, schema.primaryKey);\n        }\n\n        /**\n         * the key compression module does not know about indexes\n         * in the schema, so we have to also compress them here.\n         */\n        if (schema.indexes) {\n            const newIndexes = schema.indexes.map(idx => {\n                if (isMaybeReadonlyArray(idx)) {\n                    return idx.map(subIdx => compressedPath(table, subIdx));\n                } else {\n                    return compressedPath(table, idx);\n                }\n            });\n            compressedSchema.indexes = newIndexes;\n        }\n\n        compressionState = {\n            table,\n            schema,\n            compressedSchema\n        };\n        COMPRESSION_STATE_BY_SCHEMA.set(schema, compressionState);\n    }\n    return compressionState;\n}\n\nexport function wrappedKeyCompressionStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    const statics: RxStorageStatics = Object.assign(\n        {},\n        args.storage.statics,\n        {\n            prepareQuery<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                mutateableQuery: FilledMangoQuery<RxDocType>\n            ): PreparedQuery<RxDocType> {\n                if (schema.keyCompression) {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    mutateableQuery = compressQuery(\n                        compressionState.table,\n                        mutateableQuery as any\n                    ) as any;\n                    return args.storage.statics.prepareQuery(\n                        compressionState.compressedSchema,\n                        mutateableQuery\n                    );\n                }\n                return args.storage.statics.prepareQuery(\n                    schema,\n                    mutateableQuery\n                );\n            },\n            getSortComparator<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                preparedQuery: PreparedQuery<RxDocType>\n            ): DeterministicSortComparator<RxDocType> {\n                if (!schema.keyCompression) {\n                    return args.storage.statics.getSortComparator(schema, preparedQuery);\n                } else {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    const comparator = args.storage.statics.getSortComparator(compressionState.schema, preparedQuery);\n                    return (a, b) => {\n                        const compressedDocDataA = compressObject(\n                            compressionState.table,\n                            a as any\n                        );\n                        const compressedDocDataB = compressObject(\n                            compressionState.table,\n                            b as any\n                        );\n                        const res = comparator(compressedDocDataA, compressedDocDataB);\n                        return res;\n                    };\n                }\n            },\n            getQueryMatcher<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                preparedQuery: PreparedQuery<RxDocType>\n            ): QueryMatcher<RxDocumentData<RxDocType>> {\n                if (!schema.keyCompression) {\n                    return args.storage.statics.getQueryMatcher(schema, preparedQuery);\n                } else {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    const matcher = args.storage.statics.getQueryMatcher(compressionState.schema, preparedQuery);\n                    return (docData) => {\n                        const compressedDocData = compressObject(\n                            compressionState.table,\n                            docData\n                        );\n                        const ret = matcher(compressedDocData);\n                        return ret;\n                    };\n                }\n            }\n        }\n    );\n\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            statics,\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (!params.schema.keyCompression) {\n                    return args.storage.createStorageInstance(params);\n                }\n\n                const compressionState = getCompressionStateByRxJsonSchema(params.schema);\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    return compressDocumentData(compressionState, docData);\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    return decompressDocumentData(compressionState, docData);\n                }\n\n                /**\n                 * Because this wrapper resolves the key-compression,\n                 * we can set the flag to false\n                 * which allows underlying storages to detect wrong conficturations\n                 * like when keyCompression is set to false but no key-compression module is used.\n                 */\n                const childSchema = flatClone(compressionState.compressedSchema);\n                childSchema.keyCompression = false;\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: childSchema\n                        }\n                    )\n                );\n\n                return wrapRxStorageInstance(\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage\n                );\n            }\n        }\n    );\n}\n\nexport function compressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    /**\n     * Do not send attachments to compressObject()\n     * because it will deep clone which does not work on Blob or Buffer.\n     */\n    docData = flatCloneDocWithMeta(docData);\n    const attachments = docData._attachments;\n    delete docData._attachments;\n\n    docData = compressObject(\n        compressionState.table,\n        docData\n    );\n    docData._attachments = attachments;\n    return docData;\n}\n\nexport function decompressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    return decompressObject(\n        compressionState.table,\n        docData\n    );\n}\n"],"mappings":"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"}