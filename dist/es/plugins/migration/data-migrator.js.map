{"version":3,"sources":["../../../../src/plugins/migration/data-migrator.ts"],"names":["Subject","deepEqual","clone","toPromise","flatClone","getHeightOfRevision","createRevision","PROMISE_RESOLVE_VOID","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_NULL","createRxSchema","newRxError","runAsyncPluginHooks","runPluginHooks","getPreviousVersions","createCrypter","getMigrationStateByDatabase","map","countAllUndeleted","getBatch","getSingleDocument","_handleFromStorageInstance","_handleToStorageInstance","_migrateDocuments","oldCollection","documentsData","Promise","all","docData","migrateDocumentData","migratedDocuments","actions","action","bulkDeleteInputData","writeDeleted","_deleted","previous","document","length","storageInstance","bulkWrite","bulkWriteToStorageInput","forEach","idx","migratedDocData","res","type","migrated","doc","newestCollection","push","isDocumentDataWithoutRevisionEqual","_rev","newHeight","newRevision","attachmentsBefore","_attachments","saveData","bulkAddRevisions","_getOldCollections","dataMigrator","getOldCollectionDocs","oldColDocs","colDoc","createOldCollection","schema","version","filter","currentSchema","jsonSchema","v","database","internalStore","name","fun","then","oldCollectionDocs","d","schemaObj","storageInstanceCreationParams","databaseName","collectionName","options","instanceCreationOptions","multiInstance","storage","createStorageInstance","ret","_crypter","password","DataMigrator","migrationStrategies","_migrated","nonMigratedOldCollections","allOldCollections","migrate","batchSize","state","done","total","handled","success","deleted","percent","stateSubject","allSubject","allList","getValue","slice","asObservable","next","countAll","oldCol","totalCount","reduce","cur","prev","collection","currentCol","shift","currentPromise","migrationState$","migrateOldCollection","sub","subscribe","subState","Math","round","e","unsubscribe","c","close","error","complete","pipe","withCollection","migratePromise","_migratePromise","mustMigrate","must","rej","state$","err","runStrategyIfNotNull","docOrNull","retPromise","getBatchOfOldCollection","docs","mutateableDocData","nextVersion","resolve","validate","asRxError","fromVersion","toVersion","originalDoc","finalDoc","errors","parameters","doc1","doc2","doc1NoRev","Object","assign","undefined","doc2NoRev","deleteOldCollection","remove","removeCollectionDoc","_migrate","observer","allBatchesDone","handleOneBatch","batch"],"mappings":"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","sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n/**\n * TODO this should be completely rewritten because:\n * - The current implemetation does not use bulkDocs which is much faster\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport deepEqual from 'fast-deep-equal';\nimport {\n    clone,\n    toPromise,\n    flatClone,\n    getHeightOfRevision,\n    createRevision,\n    PROMISE_RESOLVE_VOID,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL\n} from '../../util';\nimport {\n    createRxSchema\n} from '../../rx-schema';\nimport {\n    RxError,\n    newRxError\n} from '../../rx-error';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from '../../hooks';\nimport type {\n    RxCollection,\n    RxDatabase,\n    MigrationState,\n    NumberFunctionMap,\n    OldRxCollection,\n    WithAttachmentsData,\n    RxJsonSchema,\n    RxDocumentData,\n    RxStorageInstanceCreationParams\n} from '../../types';\nimport {\n    RxSchema,\n    getPreviousVersions\n} from '../../rx-schema';\nimport {\n    createCrypter\n} from '../../crypter';\nimport {\n    getMigrationStateByDatabase,\n    MigrationStateWithCollection\n} from './migration-state';\nimport { map } from 'rxjs/operators';\nimport {\n    countAllUndeleted,\n    getBatch,\n    getSingleDocument\n} from '../../rx-storage-helper';\nimport { InternalStoreDocumentData } from '../../rx-database';\nimport {\n    _handleFromStorageInstance,\n    _handleToStorageInstance\n} from '../../rx-collection-helper';\n\nexport class DataMigrator {\n\n    constructor(\n        public newestCollection: RxCollection,\n        public migrationStrategies: NumberFunctionMap\n    ) {\n        this.currentSchema = newestCollection.schema;\n        this.database = newestCollection.database;\n        this.name = newestCollection.name;\n    }\n\n    public currentSchema: RxSchema;\n    public database: RxDatabase;\n    public name: string;\n\n\n    private _migrated: boolean = false;\n    private _migratePromise?: Promise<any>;\n    private nonMigratedOldCollections: OldRxCollection[] = [];\n    private allOldCollections: OldRxCollection[] = [];\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        if (this._migrated) {\n            throw newRxError('DM1');\n        }\n        this._migrated = true;\n\n        const state = {\n            done: false, // true if finished\n            total: 0, // will be the doc-count\n            handled: 0, // amount of handled docs\n            success: 0, // handled docs which successed\n            deleted: 0, // handled docs which got deleted\n            percent: 0 // percentage\n        };\n\n        const stateSubject: Subject<MigrationStateWithCollection> = new Subject();\n\n        /**\n         * Add to output of RxDatabase.migrationStates\n         */\n        const allSubject = getMigrationStateByDatabase(this.newestCollection.database);\n        const allList = allSubject.getValue().slice(0);\n        allList.push(stateSubject.asObservable());\n        allSubject.next(allList);\n\n        /**\n         * TODO this is a side-effect which might throw\n         * We did this because it is not possible to create new Observer(async(...))\n         * @link https://github.com/ReactiveX/rxjs/issues/4074\n         * In the future the whole migration plugin should be rewritten without rxjs\n         * so we do not have this problem.\n         */\n        (() => {\n            return _getOldCollections(this)\n                .then(ret => {\n                    this.nonMigratedOldCollections = ret;\n                    this.allOldCollections = this.nonMigratedOldCollections.slice(0);\n                    const countAll: Promise<number[]> = Promise.all(\n                        this.nonMigratedOldCollections.map(oldCol => countAllUndeleted(\n                            this.database.storage,\n                            oldCol.storageInstance\n                            ))\n                    );\n                    return countAll;\n                })\n                .then(countAll => {\n                    const totalCount: number = countAll\n                        .reduce((cur, prev) => prev = cur + prev, 0);\n                    state.total = totalCount;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    let currentCol = this.nonMigratedOldCollections.shift();\n                    let currentPromise = PROMISE_RESOLVE_VOID;\n                    while (currentCol) {\n                        const migrationState$ = migrateOldCollection(\n                            currentCol,\n                            batchSize\n                        );\n                        currentPromise = currentPromise.then(() => {\n                            return new Promise(res => {\n                                const sub = migrationState$.subscribe(\n                                    (subState: any) => {\n                                        state.handled++;\n                                        (state as any)[subState.type] = (state as any)[subState.type] + 1;\n                                        state.percent = Math.round(state.handled / state.total * 100);\n                                        stateSubject.next({\n                                            collection: this.newestCollection,\n                                            state: flatClone(state)\n                                        });\n                                    },\n                                    (e: any) => {\n                                        sub.unsubscribe();\n                                        this.allOldCollections.forEach(c => c.storageInstance.close());\n                                        stateSubject.error(e);\n                                    }, () => {\n                                        if (currentCol) {\n                                            currentCol.storageInstance.close();\n                                        }\n                                        sub.unsubscribe();\n                                        res();\n                                    });\n                            });\n                        });\n                        currentCol = this.nonMigratedOldCollections.shift();\n                    }\n                    return currentPromise;\n                })\n                .then(() => {\n                    state.done = true;\n                    state.percent = 100;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    stateSubject.complete();\n                });\n        })();\n\n\n        return stateSubject.pipe(\n            map(withCollection => withCollection.state)\n        );\n    }\n\n    migratePromise(batchSize: number): Promise<any> {\n        if (!this._migratePromise) {\n            this._migratePromise = mustMigrate(this)\n                .then(must => {\n                    if (!must) {\n                        return PROMISE_RESOLVE_FALSE;\n                    } else {\n                        return new Promise((res, rej) => {\n                            const state$ = this.migrate(batchSize);\n                            (state$ as any).subscribe(null, rej, res);\n                            this.allOldCollections.forEach(c => c.storageInstance.close());\n                        })\n                            .catch(err => {\n                                this.allOldCollections.forEach(c => c.storageInstance.close());\n                                throw err;\n                            });\n                    }\n                });\n        }\n        return this._migratePromise;\n    }\n}\n\nexport async function createOldCollection(\n    version: number,\n    schemaObj: RxJsonSchema<any>,\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection> {\n    const database = dataMigrator.newestCollection.database;\n    const schema = createRxSchema(schemaObj, false);\n\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseName: database.name,\n        collectionName: dataMigrator.newestCollection.name,\n        schema: schemaObj,\n        options: dataMigrator.newestCollection.instanceCreationOptions,\n        multiInstance: database.multiInstance\n    };\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await database.storage.createStorageInstance(\n        storageInstanceCreationParams\n    );\n    const ret: OldRxCollection = {\n        version,\n        dataMigrator,\n        newestCollection: dataMigrator.newestCollection,\n        database,\n        schema: createRxSchema(schemaObj, false),\n        storageInstance,\n        _crypter: createCrypter(\n            database.password,\n            schema\n        )\n    };\n\n    return ret;\n}\n\n\nexport async function getOldCollectionDocs(\n    dataMigrator: DataMigrator\n): Promise<RxDocumentData<InternalStoreDocumentData>[]> {\n    return Promise.all(\n        getPreviousVersions(dataMigrator.currentSchema.jsonSchema)\n            .map(v => getSingleDocument<InternalStoreDocumentData>(dataMigrator.database.internalStore, dataMigrator.name + '-' + v))\n            .map(fun => fun.catch(() => null)) // auto-catch so Promise.all continues\n    )\n        .then(oldCollectionDocs => (oldCollectionDocs as any).filter((d: any) => !!d));\n}\n\n/**\n * get an array with OldCollection-instances from all existing old storage-instances\n */\nexport async function _getOldCollections(\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection[]> {\n    const oldColDocs = await getOldCollectionDocs(dataMigrator);\n\n    return Promise.all(\n        oldColDocs\n            .map(colDoc => {\n                if (!colDoc) {\n                    return null as any;\n                }\n                return createOldCollection(\n                    colDoc.schema.version,\n                    colDoc.schema,\n                    dataMigrator\n                );\n            })\n            .filter(colDoc => colDoc !== null)\n    );\n}\n\n\n/**\n * returns true if a migration is needed\n */\nexport function mustMigrate(dataMigrator: DataMigrator): Promise<boolean> {\n    if (dataMigrator.currentSchema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    return getOldCollectionDocs(dataMigrator)\n        .then(oldColDocs => {\n            if (oldColDocs.length === 0) {\n                return false;\n            } else {\n                return true;\n            }\n        });\n}\n\nexport function runStrategyIfNotNull(\n    oldCollection: OldRxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull, oldCollection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\nexport function getBatchOfOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize: number\n): Promise<any[]> {\n    return getBatch(\n        oldCollection.database.storage,\n        oldCollection.storageInstance,\n        batchSize\n    )\n        .then(docs => docs\n            .map(doc => {\n                doc = flatClone(doc);\n                doc = _handleFromStorageInstance(oldCollection as any, doc);\n                return doc;\n            })\n        );\n}\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    oldCollection: OldRxCollection,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = oldCollection.version + 1;\n\n    // run the document throught migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= oldCollection.newestCollection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            oldCollection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        // check final schema\n        try {\n            oldCollection.newestCollection.schema.validate(doc);\n        } catch (err) {\n            const asRxError: RxError = err as any;\n            throw newRxError('DM2', {\n                fromVersion: oldCollection.version,\n                toVersion: oldCollection.newestCollection.schema.version,\n                originalDoc: docData,\n                finalDoc: doc,\n                /**\n                 * pass down data from parent error,\n                 * to make it better understandable what did not work\n                 */\n                errors: asRxError.parameters.errors,\n                schema: asRxError.parameters.schema\n            });\n        }\n        return doc;\n    });\n}\n\n\nexport function isDocumentDataWithoutRevisionEqual<T>(doc1: T, doc2: T): boolean {\n    const doc1NoRev = Object.assign({}, doc1, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    const doc2NoRev = Object.assign({}, doc2, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    return deepEqual(doc1NoRev, doc2NoRev);\n}\n\n/**\n * transform documents data and save them to the new collection\n * @return status-action with status and migrated document\n */\nexport async function _migrateDocuments(\n    oldCollection: OldRxCollection,\n    documentsData: any[]\n): Promise<{ type: string, doc: any }[]> {\n\n    // run hooks that might mutate documentsData\n    await Promise.all(\n        documentsData.map(docData => runAsyncPluginHooks(\n            'preMigrateDocument',\n            {\n                docData,\n                oldCollection\n            }\n        ))\n    );\n    // run the migration strategies on each document\n    const migratedDocuments: (any | null)[] = await Promise.all(\n        documentsData.map(docData => migrateDocumentData(oldCollection, docData))\n    );\n\n\n    const bulkWriteToStorageInput: any[] = [];\n    const actions: any[] = [];\n\n    documentsData.forEach((docData, idx) => {\n        const migratedDocData: any | null = migratedDocuments[idx];\n        const action = {\n            res: null as any,\n            type: '',\n            migrated: migratedDocData,\n            doc: docData,\n            oldCollection,\n            newestCollection: oldCollection.newestCollection\n        };\n        actions.push(action);\n\n        /**\n         * Determiniticly handle the revision\n         * so migrating the same data on multiple instances\n         * will result in the same output.\n         */\n        if (isDocumentDataWithoutRevisionEqual(docData, migratedDocData)) {\n            /**\n             * Data not changed by migration strategies, keep the same revision.\n             * This ensures that other replicated instances that did not migrate already\n             * will still have the same document.\n             */\n            migratedDocData._rev = docData._rev;\n        } else if (migratedDocData !== null) {\n            /**\n             * data changed, increase revision height\n             * so replicating instances use our new document data\n             */\n            const newHeight = getHeightOfRevision(docData._rev) + 1;\n            const newRevision = newHeight + '-' + createRevision(migratedDocData);\n            migratedDocData._rev = newRevision;\n        }\n\n\n        if (migratedDocData) {\n            /**\n             * save to newest collection\n             * notice that this data also contains the attachments data\n             */\n            const attachmentsBefore = migratedDocData._attachments;\n            const saveData: WithAttachmentsData<any> = _handleToStorageInstance(oldCollection.newestCollection, migratedDocData);\n            saveData._attachments = attachmentsBefore;\n            bulkWriteToStorageInput.push(saveData);\n            action.res = saveData;\n            action.type = 'success';\n        } else {\n            /**\n             * Migration strategy returned null\n             * which means we should not migrate this document,\n             * just drop it.\n             */\n            action.type = 'deleted';\n        }\n    });\n\n\n    /**\n     * Write the documents to the newest collection.\n     * We need to add as revision\n     * because we provide the _rev by our own\n     * to have deterministic revisions in case the migration\n     * runs on multiple nodes which must lead to the equal storage state.\n     */\n    if (bulkWriteToStorageInput.length) {\n        await oldCollection.newestCollection.storageInstance.bulkAddRevisions(bulkWriteToStorageInput);\n    }\n\n    // run hooks\n    await Promise.all(\n        actions.map(action => runAsyncPluginHooks(\n            'postMigrateDocument',\n            action\n        ))\n    );\n\n    // remove the documents from the old collection storage instance\n    const bulkDeleteInputData = documentsData.map(docData => {\n        const writeDeleted = flatClone(docData);\n        writeDeleted._deleted = true;\n        return {\n            previous: _handleToStorageInstance(oldCollection as any, docData),\n            document: _handleToStorageInstance(oldCollection as any, writeDeleted)\n        };\n    });\n\n    if (bulkDeleteInputData.length) {\n        await oldCollection.storageInstance.bulkWrite(bulkDeleteInputData);\n    }\n\n    return actions;\n}\n\n\n/**\n * deletes this.storageInstance and removes it from the database.collectionsCollection\n */\nexport function deleteOldCollection(\n    oldCollection: OldRxCollection\n): Promise<void> {\n    return oldCollection.storageInstance.remove()\n        .then(\n            () => oldCollection.database.removeCollectionDoc(\n                oldCollection.dataMigrator.name,\n                oldCollection.schema\n            )\n        );\n}\n\n/**\n * runs the migration on all documents and deletes the storage instance afterwards\n */\nexport function migrateOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize = 10\n): Observable<any> {\n    if (oldCollection._migrate) {\n        // already running\n        throw newRxError('DM3');\n    }\n    oldCollection._migrate = true;\n\n    const observer = new Subject();\n\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n    (() => {\n        let error: any;\n        const allBatchesDone = () => {\n            // remove this oldCollection\n            return deleteOldCollection(oldCollection)\n                .then(() => observer.complete());\n        };\n        const handleOneBatch = () => {\n            return getBatchOfOldCollection(oldCollection, batchSize)\n                .then(batch => {\n                    if (batch.length === 0) {\n                        allBatchesDone();\n                        return false;\n                    } else {\n                        return _migrateDocuments(oldCollection, batch)\n                            .then((actions: any[]) => actions.forEach(action => observer.next(action)))\n                            .catch(e => error = e)\n                            .then(() => true);\n                    }\n                })\n                .then(next => {\n                    if (!next) {\n                        return;\n                    }\n                    if (error) {\n                        observer.error(error);\n                    } else {\n                        handleOneBatch();\n                    }\n                });\n        };\n        handleOneBatch();\n    })();\n\n    return observer.asObservable();\n}\n\nexport function migratePromise(\n    oldCollection: OldRxCollection,\n    batchSize?: number\n): Promise<any> {\n    if (!oldCollection._migratePromise) {\n        oldCollection._migratePromise = new Promise((res, rej) => {\n            const state$ = migrateOldCollection(oldCollection, batchSize);\n            (state$ as any).subscribe(null, rej, res);\n        });\n    }\n    return oldCollection._migratePromise;\n}\n"],"file":"data-migrator.js"}