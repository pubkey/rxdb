{"version":3,"file":"data-migrator.js","names":["Subject","deepEqual","clone","toPromise","flatClone","getHeightOfRevision","createRevision","PROMISE_RESOLVE_VOID","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_NULL","getDefaultRxDocumentMeta","now","createRxSchema","newRxError","runAsyncPluginHooks","runPluginHooks","getPreviousVersions","getMigrationStateByDatabase","map","getWrappedStorageInstance","getPrimaryKeyOfInternalDocument","INTERNAL_CONTEXT_COLLECTION","normalizeMangoQuery","_migrateDocuments","oldCollection","documentsData","Promise","all","docData","migrateDocumentData","migratedDocuments","actions","action","bulkDeleteInputData","writeDeleted","_deleted","_attachments","previous","document","length","storageInstance","bulkWrite","bulkWriteToStorageInput","forEach","idx","migratedDocData","res","type","migrated","doc","newestCollection","push","isDocumentDataWithoutRevisionEqual","_rev","newHeight","newRevision","database","hashFunction","attachmentsBefore","saveData","_meta","lwt","originalStorageInstance","_getOldCollections","dataMigrator","getOldCollectionDocs","oldColDocs","colDoc","createOldCollection","data","schema","version","filter","schemaObj","storageInstanceCreationParams","databaseInstanceToken","token","databaseName","name","collectionName","options","instanceCreationOptions","multiInstance","storage","createStorageInstance","ret","DataMigrator","migrationStrategies","_migrated","nonMigratedOldCollections","allOldCollections","currentSchema","migrate","batchSize","state","done","total","handled","success","deleted","percent","stateSubject","allSubject","allList","getValue","slice","asObservable","next","then","getAllDocuments","getAllQueryPrepared","statics","prepareQuery","query","queryResult","allDocs","documents","countAll","oldCol","jsonSchema","totalCount","reduce","cur","prev","collection","currentCol","shift","currentPromise","migrationState$","migrateOldCollection","sub","subscribe","subState","Math","round","error","e","unsubscribe","c","close","complete","pipe","withCollection","migratePromise","_migratePromise","mustMigrate","must","rej","state$","err","collectionDocKeys","internalStore","findDocumentsById","key","docsObj","Object","values","runStrategyIfNotNull","docOrNull","retPromise","getBatchOfOldCollection","preparedQuery","selector","sort","primaryPath","limit","skip","result","mutateableDocData","nextVersion","resolve","doc1","doc2","doc1NoRev","assign","undefined","doc2NoRev","deleteOldCollection","remove","removeCollectionDoc","_migrate","observer","allBatchesDone","handleOneBatch","batch"],"sources":["../../../../src/plugins/migration/data-migrator.ts"],"sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n/**\n * TODO this should be completely rewritten because:\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport deepEqual from 'fast-deep-equal';\nimport {\n    clone,\n    toPromise,\n    flatClone,\n    getHeightOfRevision,\n    createRevision,\n    PROMISE_RESOLVE_VOID,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL,\n    getDefaultRxDocumentMeta,\n    now\n} from '../../util';\nimport {\n    createRxSchema\n} from '../../rx-schema';\nimport {\n    newRxError\n} from '../../rx-error';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from '../../hooks';\nimport type {\n    RxCollection,\n    RxDatabase,\n    MigrationState,\n    NumberFunctionMap,\n    OldRxCollection,\n    WithAttachmentsData,\n    RxJsonSchema,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    InternalStoreCollectionDocType,\n    RxStorageInstance\n} from '../../types';\nimport {\n    RxSchema,\n    getPreviousVersions\n} from '../../rx-schema';\nimport {\n    getMigrationStateByDatabase,\n    MigrationStateWithCollection\n} from './migration-state';\nimport { map } from 'rxjs/operators';\nimport {\n    getWrappedStorageInstance\n} from '../../rx-storage-helper';\nimport {\n    getPrimaryKeyOfInternalDocument,\n    INTERNAL_CONTEXT_COLLECTION\n} from '../../rx-database-internal-store';\nimport { normalizeMangoQuery } from '../../rx-query-helper';\n\nexport class DataMigrator {\n\n    constructor(\n        public newestCollection: RxCollection,\n        public migrationStrategies: NumberFunctionMap\n    ) {\n        this.currentSchema = newestCollection.schema;\n        this.database = newestCollection.database;\n        this.name = newestCollection.name;\n    }\n\n    public currentSchema: RxSchema;\n    public database: RxDatabase;\n    public name: string;\n\n\n    private _migrated: boolean = false;\n    private _migratePromise?: Promise<any>;\n    private nonMigratedOldCollections: OldRxCollection[] = [];\n    private allOldCollections: OldRxCollection[] = [];\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        if (this._migrated) {\n            throw newRxError('DM1');\n        }\n        this._migrated = true;\n\n        const state = {\n            done: false, // true if finished\n            total: 0, // will be the doc-count\n            handled: 0, // amount of handled docs\n            success: 0, // handled docs which successed\n            deleted: 0, // handled docs which got deleted\n            percent: 0 // percentage\n        };\n\n        const stateSubject: Subject<MigrationStateWithCollection> = new Subject();\n\n        /**\n         * Add to output of RxDatabase.migrationStates\n         */\n        const allSubject = getMigrationStateByDatabase(this.newestCollection.database);\n        const allList = allSubject.getValue().slice(0);\n        allList.push(stateSubject.asObservable());\n        allSubject.next(allList);\n\n        /**\n         * TODO this is a side-effect which might throw\n         * We did this because it is not possible to create new Observer(async(...))\n         * @link https://github.com/ReactiveX/rxjs/issues/4074\n         * In the future the whole migration plugin should be rewritten without rxjs\n         * so we do not have this problem.\n         */\n        (() => {\n            return _getOldCollections(this)\n                .then(ret => {\n                    this.nonMigratedOldCollections = ret;\n                    this.allOldCollections = this.nonMigratedOldCollections.slice(0);\n\n                    const getAllDocuments = async (\n                        storageInstance: RxStorageInstance<any, any, any>,\n                        schema: RxJsonSchema<any>\n                    ): Promise<RxDocumentData<any>[]> => {\n                        const storage = this.database.storage;\n                        const getAllQueryPrepared = storage.statics.prepareQuery(\n                            storageInstance.schema,\n                            normalizeMangoQuery(\n                                schema,\n                                {}\n                            )\n                        );\n                        const queryResult = await storageInstance.query(getAllQueryPrepared);\n                        const allDocs = queryResult.documents;\n                        return allDocs;\n                    }\n\n                    const countAll: Promise<number[]> = Promise.all(\n                        this.nonMigratedOldCollections\n                            .map(oldCol => getAllDocuments(\n                                oldCol.storageInstance,\n                                oldCol.schema.jsonSchema\n                            ).then(allDocs => allDocs.length))\n                    );\n                    return countAll;\n                })\n                .then(countAll => {\n                    const totalCount: number = countAll\n                        .reduce((cur, prev) => prev = cur + prev, 0);\n                    state.total = totalCount;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    let currentCol = this.nonMigratedOldCollections.shift();\n                    let currentPromise = PROMISE_RESOLVE_VOID;\n                    while (currentCol) {\n                        const migrationState$ = migrateOldCollection(\n                            currentCol,\n                            batchSize\n                        );\n                        currentPromise = currentPromise.then(() => {\n                            return new Promise(res => {\n                                const sub = migrationState$.subscribe({\n                                    next: (subState: any) => {\n                                        state.handled++;\n                                        (state as any)[subState.type] = (state as any)[subState.type] + 1;\n                                        state.percent = Math.round(state.handled / state.total * 100);\n                                        stateSubject.next({\n                                            collection: this.newestCollection,\n                                            state: flatClone(state)\n                                        });\n                                    },\n                                    error: (e: any) => {\n                                        sub.unsubscribe();\n                                        // TODO we should not have to catch here.\n                                        this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                        stateSubject.error(e);\n                                    },\n                                    complete: () => {\n                                        if (currentCol) {\n                                            // TODO we should not have to catch here.\n                                            currentCol.storageInstance.close().catch(() => { });\n                                        }\n                                        sub.unsubscribe();\n                                        res();\n                                    }\n                                });\n                            });\n                        });\n                        currentCol = this.nonMigratedOldCollections.shift();\n                    }\n                    return currentPromise;\n                })\n                .then(() => {\n                    state.done = true;\n                    state.percent = 100;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    stateSubject.complete();\n                });\n        })();\n\n\n        return stateSubject.pipe(\n            map(withCollection => withCollection.state)\n        );\n    }\n\n    migratePromise(batchSize: number): Promise<any> {\n        if (!this._migratePromise) {\n            this._migratePromise = mustMigrate(this)\n                .then(must => {\n                    if (!must) {\n                        return PROMISE_RESOLVE_FALSE;\n                    } else {\n                        return new Promise((res, rej) => {\n                            const state$ = this.migrate(batchSize);\n                            (state$ as any).subscribe(null, rej, res);\n                            this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                        })\n                            .catch(err => {\n                                this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                throw err;\n                            });\n                    }\n                });\n        }\n        return this._migratePromise;\n    }\n}\n\nexport async function createOldCollection(\n    version: number,\n    schemaObj: RxJsonSchema<any>,\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection> {\n    const database = dataMigrator.newestCollection.database;\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: dataMigrator.newestCollection.name,\n        schema: schemaObj,\n        options: dataMigrator.newestCollection.instanceCreationOptions,\n        multiInstance: database.multiInstance\n    };\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await database.storage.createStorageInstance(\n        storageInstanceCreationParams\n    );\n    const ret: OldRxCollection = {\n        version,\n        dataMigrator,\n        newestCollection: dataMigrator.newestCollection,\n        database,\n        schema: createRxSchema(schemaObj, false),\n        storageInstance\n    };\n\n    ret.storageInstance = getWrappedStorageInstance(\n        ret.database,\n        storageInstance,\n        schemaObj\n    );\n\n    return ret;\n}\n\n\nexport function getOldCollectionDocs(\n    dataMigrator: DataMigrator\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n\n    const collectionDocKeys = getPreviousVersions(dataMigrator.currentSchema.jsonSchema)\n        .map(version => dataMigrator.name + '-' + version);\n\n    return dataMigrator.database.internalStore.findDocumentsById(\n        collectionDocKeys.map(key => getPrimaryKeyOfInternalDocument(\n            key,\n            INTERNAL_CONTEXT_COLLECTION\n        )),\n        false\n    ).then(docsObj => Object.values(docsObj));\n}\n\n/**\n * get an array with OldCollection-instances from all existing old storage-instances\n */\nexport async function _getOldCollections(\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection[]> {\n    const oldColDocs = await getOldCollectionDocs(dataMigrator);\n\n    return Promise.all(\n        oldColDocs\n            .map(colDoc => {\n                if (!colDoc) {\n                    return null as any;\n                }\n                return createOldCollection(\n                    colDoc.data.schema.version,\n                    colDoc.data.schema,\n                    dataMigrator\n                );\n            })\n            .filter(colDoc => colDoc !== null)\n    );\n}\n\n\n/**\n * returns true if a migration is needed\n */\nexport function mustMigrate(dataMigrator: DataMigrator): Promise<boolean> {\n    if (dataMigrator.currentSchema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    return getOldCollectionDocs(dataMigrator)\n        .then(oldColDocs => {\n            if (oldColDocs.length === 0) {\n                return false;\n            } else {\n                return true;\n            }\n        });\n}\n\nexport function runStrategyIfNotNull(\n    oldCollection: OldRxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull, oldCollection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\nexport function getBatchOfOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize: number\n): Promise<any[]> {\n    const storage = oldCollection.database.storage;\n    const storageInstance = oldCollection.storageInstance;\n    const preparedQuery = storage.statics.prepareQuery(\n        storageInstance.schema,\n        {\n            selector: {},\n            sort: [{ [oldCollection.schema.primaryPath]: 'asc' } as any],\n            limit: batchSize,\n            skip: 0\n        }\n    );\n\n    return storageInstance\n        .query(preparedQuery)\n        .then(result => result.documents\n            .map(doc => {\n                doc = flatClone(doc);\n                return doc;\n            })\n        );\n}\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    oldCollection: OldRxCollection,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = oldCollection.version + 1;\n\n    // run the document throught migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= oldCollection.newestCollection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            oldCollection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        /**\n         * Add _meta field if missing.\n         * We need this to migration documents from pre-12.0.0 state\n         * to version 12.0.0. Therefore we need to add the _meta field if it is missing.\n         * TODO remove this in the major version 13.0.0 \n         */\n        if (!doc._meta) {\n            doc._meta = getDefaultRxDocumentMeta();\n        }\n        return doc;\n    });\n}\n\n\nexport function isDocumentDataWithoutRevisionEqual<T>(doc1: T, doc2: T): boolean {\n    const doc1NoRev = Object.assign({}, doc1, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    const doc2NoRev = Object.assign({}, doc2, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    return deepEqual(doc1NoRev, doc2NoRev);\n}\n\n/**\n * transform documents data and save them to the new collection\n * @return status-action with status and migrated document\n */\nexport async function _migrateDocuments(\n    oldCollection: OldRxCollection,\n    documentsData: any[]\n): Promise<{ type: string, doc: any }[]> {\n\n    // run hooks that might mutate documentsData\n    await Promise.all(\n        documentsData.map(docData => runAsyncPluginHooks(\n            'preMigrateDocument',\n            {\n                docData,\n                oldCollection\n            }\n        ))\n    );\n    // run the migration strategies on each document\n    const migratedDocuments: (any | null)[] = await Promise.all(\n        documentsData.map(docData => migrateDocumentData(oldCollection, docData))\n    );\n\n\n    const bulkWriteToStorageInput: RxDocumentData<any>[] = [];\n    const actions: any[] = [];\n\n    documentsData.forEach((docData, idx) => {\n        const migratedDocData: any | null = migratedDocuments[idx];\n        const action = {\n            res: null as any,\n            type: '',\n            migrated: migratedDocData,\n            doc: docData,\n            oldCollection,\n            newestCollection: oldCollection.newestCollection\n        };\n        actions.push(action);\n\n        /**\n         * Determiniticly handle the revision\n         * so migrating the same data on multiple instances\n         * will result in the same output.\n         */\n        if (isDocumentDataWithoutRevisionEqual(docData, migratedDocData)) {\n            /**\n             * Data not changed by migration strategies, keep the same revision.\n             * This ensures that other replicated instances that did not migrate already\n             * will still have the same document.\n             */\n            migratedDocData._rev = docData._rev;\n        } else if (migratedDocData !== null) {\n            /**\n             * data changed, increase revision height\n             * so replicating instances use our new document data\n             */\n            const newHeight = getHeightOfRevision(docData._rev) + 1;\n            const newRevision = newHeight + '-' + createRevision(\n                oldCollection.newestCollection.database.hashFunction,\n                migratedDocData\n            );\n            migratedDocData._rev = newRevision;\n        }\n\n\n        if (migratedDocData) {\n            /**\n             * save to newest collection\n             * notice that this data also contains the attachments data\n             */\n            const attachmentsBefore = migratedDocData._attachments;\n            const saveData: WithAttachmentsData<any> = migratedDocData;\n            saveData._attachments = attachmentsBefore;\n            saveData._meta.lwt = now();\n            bulkWriteToStorageInput.push(saveData);\n            action.res = saveData;\n            action.type = 'success';\n        } else {\n            /**\n             * Migration strategy returned null\n             * which means we should not migrate this document,\n             * just drop it.\n             */\n            action.type = 'deleted';\n        }\n    });\n\n    /**\n     * Write the documents to the newest collection.\n     * We need to add as revision\n     * because we provide the _rev by our own\n     * to have deterministic revisions in case the migration\n     * runs on multiple nodes which must lead to the equal storage state.\n     */\n    if (bulkWriteToStorageInput.length) {\n        /**\n         * To ensure that we really keep that revision, we\n         * hackly insert this document via the RxStorageInstance.originalStorageInstance\n         * so that getWrappedStorageInstance() does not overwrite its own revision.\n         */\n        const originalStorageInstance: RxStorageInstance<any, any, any> = (oldCollection.newestCollection.storageInstance as any).originalStorageInstance;\n        await originalStorageInstance.bulkWrite(\n            bulkWriteToStorageInput.map(document => ({ document })),\n            'data-migrator-import'\n        );\n    }\n\n    // run hooks\n    await Promise.all(\n        actions.map(action => runAsyncPluginHooks(\n            'postMigrateDocument',\n            action\n        ))\n    );\n\n    // remove the documents from the old collection storage instance\n    const bulkDeleteInputData = documentsData.map(docData => {\n        const writeDeleted = flatClone(docData);\n        writeDeleted._deleted = true;\n        writeDeleted._attachments = {};\n        return {\n            previous: docData,\n            document: writeDeleted\n        };\n    });\n\n    if (bulkDeleteInputData.length) {\n        await oldCollection.storageInstance.bulkWrite(\n            bulkDeleteInputData,\n            'data-migrator-delete'\n        );\n    }\n\n    return actions;\n}\n\n\n/**\n * deletes this.storageInstance and removes it from the database.collectionsCollection\n */\nexport function deleteOldCollection(\n    oldCollection: OldRxCollection\n): Promise<void> {\n    return oldCollection.storageInstance.remove()\n        .then(\n            () => oldCollection.database.removeCollectionDoc(\n                oldCollection.dataMigrator.name,\n                oldCollection.schema\n            )\n        );\n}\n\n/**\n * runs the migration on all documents and deletes the storage instance afterwards\n */\nexport function migrateOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize = 10\n): Observable<any> {\n    if (oldCollection._migrate) {\n        // already running\n        throw newRxError('DM3');\n    }\n    oldCollection._migrate = true;\n\n    const observer = new Subject();\n\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n    (() => {\n        let error: any;\n        const allBatchesDone = () => {\n            // remove this oldCollection\n            return deleteOldCollection(oldCollection)\n                .then(() => observer.complete());\n        };\n        const handleOneBatch = () => {\n            return getBatchOfOldCollection(oldCollection, batchSize)\n                .then(batch => {\n                    if (batch.length === 0) {\n                        allBatchesDone();\n                        return false;\n                    } else {\n                        return _migrateDocuments(oldCollection, batch)\n                            .then((actions: any[]) => actions.forEach(action => observer.next(action)))\n                            .catch(e => error = e)\n                            .then(() => true);\n                    }\n                })\n                .then(next => {\n                    if (!next) {\n                        return;\n                    }\n                    if (error) {\n                        observer.error(error);\n                    } else {\n                        handleOneBatch();\n                    }\n                });\n        };\n        handleOneBatch();\n    })();\n\n    return observer.asObservable();\n}\n\nexport function migratePromise(\n    oldCollection: OldRxCollection,\n    batchSize?: number\n): Promise<any> {\n    if (!oldCollection._migratePromise) {\n        oldCollection._migratePromise = new Promise((res, rej) => {\n            const state$ = migrateOldCollection(oldCollection, batchSize);\n            (state$ as any).subscribe(null, rej, res);\n        });\n    }\n    return oldCollection._migratePromise;\n}\n"],"mappings":"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"}