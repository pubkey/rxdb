{"version":3,"file":"attachments.js","names":["map","b64DecodeUnicode","blobBufferUtil","flatClone","PROMISE_RESOLVE_VOID","newRxError","flatCloneDocWithMeta","writeSingle","pouchHash","preMigrateDocument","data","attachments","docData","_attachments","newAttachments","Promise","all","Object","keys","attachmentId","attachment","docPrimary","oldCollection","schema","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","digest","length","type","putAttachment","attachmentData","skipIfSame","ensureSchemaSupportsAttachments","dataSize","size","toBase64String","dataString","id","hashAttachmentData","then","hash","newDigest","_atomicQueue","_data","currentMeta","getAttachment","docWriteData","writeRow","previous","document","collection","writeResult","fromStorageInstanceResult","newData","_rev","_dataSync$","next","attachmentBase64String","binary","err","console","log","getAttachmentSize","atob","doc","schemaJson","jsonSchema","link","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainDataBase64","createBlobBufferFromBase64","getStringData","toString","rxDocument","getValue","allAttachments","postMigrateDocument","_action","RxDBAttachmentsPlugin","name","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","after"],"sources":["../../../src/plugins/attachments.ts"],"sourcesContent":["import {\n    map\n} from 'rxjs/operators';\n\nimport {\n    b64DecodeUnicode,\n    blobBufferUtil,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../types';\nimport { flatCloneDocWithMeta, writeSingle } from '../rx-storage-helper';\nimport { pouchHash } from './pouchdb';\n\n\n/**\n * To be able to support PouchDB with attachments,\n * we have to use the md5 hashing here, even if the RxDatabase itself\n * has a different hashing function.\n */\nexport function hashAttachmentData(\n    attachmentBase64String: string\n): Promise<string> {\n    let binary;\n    try {\n        binary = b64DecodeUnicode(attachmentBase64String);\n    } catch (err) {\n        console.log('could not run b64DecodeUnicode() on ' + attachmentBase64String);\n        throw err;\n    }\n    return pouchHash(binary);\n}\n\nexport function getAttachmentSize(\n    attachmentBase64String: string\n): number {\n    return atob(attachmentBase64String).length;\n}\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: flatClone(this.doc._data), // TODO do we need a flatClone here?\n                        document: docWriteData\n                    },\n                    'attachment-remove'\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        const ret = await blobBufferUtil.createBlobBufferFromBase64(\n            plainDataBase64,\n            this.type as any\n        );\n        return ret;\n    }\n\n    async getStringData(): Promise<string> {\n        const data = await this.getData();\n        const asString = await blobBufferUtil.toString(data);\n        return asString;\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    attachmentData: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    const dataSize = blobBufferUtil.size(attachmentData.data);\n    const dataString = await blobBufferUtil.toBase64String(attachmentData.data);\n\n    const id = attachmentData.id;\n    const type = attachmentData.type;\n    const data = dataString;\n\n    const newDigest = await hashAttachmentData(\n        dataString\n    ).then(hash => 'md5-' + hash);\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            docWriteData._attachments[id] = {\n                digest: newDigest,\n                length: dataSize,\n                type,\n                data\n            };\n            const writeRow = {\n                previous: flatClone(this._data),\n                document: flatClone(docWriteData)\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow,\n                'attachment-put'\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n                const rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                newAttachments[attachmentId] = {\n                    digest: attachment.digest,\n                    length: attachment.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return PROMISE_RESOLVE_VOID;\n}\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.putAttachment = putAttachment;\n            proto.getAttachment = getAttachment;\n            proto.allAttachments = allAttachments;\n            Object.defineProperty(proto, 'allAttachments$', {\n                get: function allAttachments$() {\n                    return this._dataSync$\n                        .pipe(\n                            map((data: any) => {\n                                if (!data['_attachments']) {\n                                    return {};\n                                }\n                                return data['_attachments'];\n                            }),\n                            map((attachmentsData: any) => Object.entries(\n                                attachmentsData\n                            )),\n                            map(entries => {\n                                return (entries as any)\n                                    .map(([id, attachmentData]: any) => {\n                                        return fromStorageInstanceResult(\n                                            id,\n                                            attachmentData,\n                                            this\n                                        );\n                                    });\n                            })\n                        );\n                }\n            });\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preMigrateDocument: {\n            after: preMigrateDocument\n        },\n        postMigrateDocument: {\n            after: postMigrateDocument\n        }\n    }\n};\n"],"mappings":"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"}