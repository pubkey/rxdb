{"version":3,"file":"index.js","names":["newRxError","deepEqual","objectPath","clone","ensureNotFalsy","now","objectPathMonad","modifyjs","overwritable","insertCRDT","entry","deepFreezeWhenDevMode","jsonSchema","schema","crdt","queryObj","crdtOptions","database","storageToken","operation","body","Array","isArray","creator","time","insertData","runOperationOnDocument","storage","statics","crdtDocField","operations","hash","set","field","lastAr","push","hashCRDTOperations","hashFunction","insert","err","code","findOne","parameters","id","exec","doc","updateCRDT","collection","atomicUpdate","docData","rxDoc","get","newDocData","toJSON","_deleted","_data","fullDocData","Object","assign","_attachments","_meta","_rev","RX_CRDT_CONTEXT","sortOperationComparator","a","b","storageStatics","entryParts","forEach","entryPart","isMatching","selector","preparedQuery","prepareQuery","sort","skip","matcher","getQueryMatcher","ifMatch","ifNotMatch","crdts","hashObj","map","op","JSON","stringify","getCRDTSchemaPart","operationSchema","type","properties","items","additionalProperties","minItems","minimum","maximum","multipleOf","required","minLength","mergeCRDTFields","crdtsA","crdtsB","length","ret","row","index","mergedOps","ids","Set","add","has","rebuildFromCRDT","base","getCRDTConflictHandler","crdtField","getCRDTValue","conflictHandler","i","_context","newDocCrdt","newDocumentState","masterDocCrdt","realMasterState","Promise","resolve","isEqual","mergedCrdt","mergedDoc","documentData","RxDBcrdtPlugin","name","rxdb","prototypes","RxDocument","proto","oldRemove","remove","bind","$set","oldAtomicPatch","atomicPatch","patch","oldAtomicUpdate","fn","context","primary","args","RxCollection","hooks","preCreateRxCollection","after","data","createRxCollection","getCrdt","isDevMode","bulkWriteBefore","storageInstance","bulkWrite","writes","write","newDocState","document","rebuild","docWithoutMeta","entries","k","v","startsWith","recalculatedHash","bulkInsertBefore","bulkInsert","docsData","useDocsData","setMe","key","value","crdtOperations"],"sources":["../../../../src/plugins/crdt/index.ts"],"sourcesContent":["import { newRxError } from '../../rx-error';\nimport deepEqual from 'fast-deep-equal';\nimport objectPath from 'object-path';\nimport type {\n    CRDTDocumentField,\n    CRDTEntry,\n    CRDTOperation,\n    HashFunction,\n    JsonSchema,\n    RxConflictHandler,\n    RxConflictHandlerInput,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    RxPlugin,\n    RxStorageStatics,\n    WithDeleted\n} from '../../types';\nimport {\n    clone,\n    ensureNotFalsy,\n    now,\n    objectPathMonad\n} from '../../util';\nimport modifyjs from 'modifyjs';\nimport {\n    overwritable,\n    RxCollection,\n    RxDocumentWriteData,\n    RxError\n} from '../..';\n\n\n\nexport async function updateCRDT<RxDocType>(\n    this: RxDocument<RxDocType>,\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\n) {\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\n\n    const jsonSchema = this.collection.schema.jsonSchema;\n    if (!jsonSchema.crdt) {\n        throw newRxError('CRDT1', {\n            schema: jsonSchema,\n            queryObj: entry\n        });\n    }\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\n    const storageToken = await this.collection.database.storageToken;\n\n    return this.atomicUpdate((docData, rxDoc) => {\n        const crdtDocField: CRDTDocumentField<RxDocType> = clone(objectPath.get(docData as any, crdtOptions.field));\n        const operation: CRDTOperation<RxDocType> = {\n            body: Array.isArray(entry) ? entry : [entry],\n            creator: storageToken,\n            time: now()\n        };\n\n        /**\n         * A new write will ALWAYS be an operation in the last\n         * array which was non existing before.\n         */\n        const lastAr: CRDTOperation<RxDocType>[] = [operation];\n        crdtDocField.operations.push(lastAr);\n        crdtDocField.hash = hashCRDTOperations(this.collection.database.hashFunction, crdtDocField);\n\n        let newDocData: WithDeleted<RxDocType> = clone(rxDoc.toJSON()) as any;\n        newDocData._deleted = rxDoc._data._deleted;\n        newDocData = runOperationOnDocument(\n            this.collection.database.storage.statics,\n            this.collection.schema.jsonSchema,\n            newDocData,\n            operation\n        );\n        objectPath.set(newDocData, crdtOptions.field, crdtDocField);\n\n        // add other internal fields\n        const fullDocData: RxDocumentData<RxDocType> = Object.assign({\n            _attachments: rxDoc._data._attachments,\n            _meta: rxDoc._data._meta,\n            _rev: rxDoc._data._rev\n        }, newDocData);\n\n        return fullDocData;\n    }, RX_CRDT_CONTEXT);\n}\n\n\nexport async function insertCRDT<RxDocType>(\n    this: RxCollection<RxDocType>,\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\n) {\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\n\n    const jsonSchema = this.schema.jsonSchema;\n    if (!jsonSchema.crdt) {\n        throw newRxError('CRDT1', {\n            schema: jsonSchema,\n            queryObj: entry\n        });\n    }\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\n    const storageToken = await this.database.storageToken;\n    const operation: CRDTOperation<RxDocType> = {\n        body: Array.isArray(entry) ? entry : [entry],\n        creator: storageToken,\n        time: now()\n    };\n\n    let insertData: RxDocumentWriteData<RxDocType> = {} as any;\n    insertData = runOperationOnDocument(\n        this.database.storage.statics,\n        this.schema.jsonSchema,\n        insertData as any,\n        operation\n    ) as any;\n    const crdtDocField: CRDTDocumentField<RxDocType> = {\n        operations: [],\n        hash: ''\n    };\n    objectPath.set(insertData as any, crdtOptions.field, crdtDocField);\n\n    const lastAr: CRDTOperation<RxDocType>[] = [operation];\n    crdtDocField.operations.push(lastAr);\n    crdtDocField.hash = hashCRDTOperations(this.database.hashFunction, crdtDocField);\n\n    const result = await this.insert(insertData).catch(async (err: RxError) => {\n        if (err.code === 'COL19') {\n            // was a conflict, update document instead of inserting\n            const doc = await this.findOne(err.parameters.id).exec(true);\n            return doc.updateCRDT(entry);\n        } else {\n            throw err;\n        }\n    });\n    return result;\n}\n\n\nexport function sortOperationComparator<RxDocType>(a: CRDTOperation<RxDocType>, b: CRDTOperation<RxDocType>) {\n    return a.creator > b.creator ? 1 : -1;\n}\n\n\nfunction runOperationOnDocument<RxDocType>(\n    storageStatics: RxStorageStatics,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    docData: WithDeleted<RxDocType>,\n    operation: CRDTOperation<RxDocType>\n): WithDeleted<RxDocType> {\n    const entryParts = operation.body;\n    entryParts.forEach(entryPart => {\n        let isMatching: boolean;\n        if (entryPart.selector) {\n            const preparedQuery = storageStatics.prepareQuery(schema, {\n                selector: ensureNotFalsy(entryPart.selector),\n                sort: [],\n                skip: 0\n            });\n            const matcher = storageStatics.getQueryMatcher(schema, preparedQuery);\n            isMatching = matcher(docData as any);\n        } else {\n            isMatching = true;\n        }\n        if (isMatching) {\n            if (entryPart.ifMatch) {\n                docData = modifyjs(docData, entryPart.ifMatch);\n            }\n        } else {\n            if (entryPart.ifNotMatch) {\n                docData = modifyjs(docData, entryPart.ifNotMatch);\n            }\n        }\n    });\n    return docData;\n}\n\nexport function hashCRDTOperations(\n    hashFunction: HashFunction,\n    crdts: CRDTDocumentField<any>\n): string {\n    const hashObj = crdts.operations.map((operations) => {\n        return operations.map(op => op.creator);\n    });\n    const hash = hashFunction(JSON.stringify(hashObj));\n    return hash;\n}\n\nexport function getCRDTSchemaPart<RxDocType>(): JsonSchema<CRDTDocumentField<RxDocType>> {\n    const operationSchema: JsonSchema<CRDTOperation<RxDocType>> = {\n        type: 'object',\n        properties: {\n            body: {\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        selector: {\n                            type: 'object'\n                        },\n                        ifMatch: {\n                            type: 'object'\n                        },\n                        ifNotMatch: {\n                            type: 'object'\n                        }\n                    },\n                    additionalProperties: false\n                },\n                minItems: 1\n            },\n            creator: {\n                type: 'string'\n            },\n            time: {\n                type: 'number',\n                minimum: 1,\n                maximum: 1000000000000000,\n                multipleOf: 0.01\n            }\n        },\n        additionalProperties: false,\n        required: [\n            'body',\n            'creator',\n            'time'\n        ]\n    };\n    return {\n        type: 'object',\n        properties: {\n            operations: {\n                type: 'array',\n                items: {\n                    type: 'array',\n                    items: operationSchema\n                }\n            },\n            hash: {\n                type: 'string',\n                // set a minLength to not accidentally store an empty string\n                minLength: 2\n            }\n        },\n        additionalProperties: false,\n        required: ['operations', 'hash']\n    };\n}\n\n\nexport function mergeCRDTFields<RxDocType>(\n    hashFunction: HashFunction,\n    crdtsA: CRDTDocumentField<RxDocType>,\n    crdtsB: CRDTDocumentField<RxDocType>\n): CRDTDocumentField<RxDocType> {\n\n    // the value with most operations must be A to\n    // ensure we not miss out rows when iterating over both fields.\n    if (crdtsA.operations.length < crdtsB.operations.length) {\n        [crdtsA, crdtsB] = [crdtsB, crdtsA];\n    }\n\n    const ret: CRDTDocumentField<RxDocType> = {\n        operations: [],\n        hash: ''\n    };\n    crdtsA.operations.forEach((row, index) => {\n        let mergedOps: CRDTOperation<RxDocType>[] = [];\n        const ids = new Set<string>(); // used to deduplicate\n\n        row.forEach(op => {\n            ids.add(op.creator);\n            mergedOps.push(op);\n        });\n        if (crdtsB.operations[index]) {\n            crdtsB.operations[index].forEach(op => {\n                if (!ids.has(op.creator)) {\n                    mergedOps.push(op);\n                }\n            });\n        }\n        mergedOps = mergedOps.sort(sortOperationComparator);\n        ret.operations[index] = mergedOps;\n    });\n\n\n    ret.hash = hashCRDTOperations(hashFunction, ret);\n    return ret;\n}\n\nexport function rebuildFromCRDT<RxDocType>(\n    storageStatics: RxStorageStatics,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    docData: WithDeleted<RxDocType>,\n    crdts: CRDTDocumentField<RxDocType>\n): WithDeleted<RxDocType> {\n    let base: WithDeleted<RxDocType> = {\n        _deleted: false\n    } as any;\n    objectPath.set(base, ensureNotFalsy(schema.crdt).field, crdts);\n    crdts.operations.forEach(operations => {\n        operations.forEach(op => {\n            base = runOperationOnDocument(\n                storageStatics,\n                schema,\n                base,\n                op\n            );\n        });\n    });\n    return base;\n}\n\n\nexport function getCRDTConflictHandler<RxDocType>(\n    hashFunction: HashFunction,\n    storageStatics: RxStorageStatics,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\n): RxConflictHandler<RxDocType> {\n    const crdtOptions = ensureNotFalsy(schema.crdt);\n    const crdtField = crdtOptions.field;\n    const getCRDTValue = objectPathMonad<WithDeleted<RxDocType>, CRDTDocumentField<RxDocType>>(crdtField);\n\n    const conflictHandler: RxConflictHandler<RxDocType> = (\n        i: RxConflictHandlerInput<RxDocType>,\n        _context: string\n    ) => {\n        const newDocCrdt = getCRDTValue(i.newDocumentState);\n        const masterDocCrdt = getCRDTValue(i.realMasterState);\n\n        if (newDocCrdt.hash === masterDocCrdt.hash) {\n            return Promise.resolve({\n                isEqual: true\n            });\n        }\n\n        const mergedCrdt = mergeCRDTFields(hashFunction, newDocCrdt, masterDocCrdt);\n        const mergedDoc = rebuildFromCRDT(\n            storageStatics,\n            schema,\n            i.newDocumentState,\n            mergedCrdt\n        );\n        return Promise.resolve({\n            isEqual: false,\n            documentData: mergedDoc\n        });\n    };\n\n    return conflictHandler;\n}\n\n\nexport const RX_CRDT_CONTEXT = 'rx-crdt';\n\nexport const RxDBcrdtPlugin: RxPlugin = {\n    name: 'crdt',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.updateCRDT = updateCRDT;\n\n            const oldRemove = proto.remove;\n            proto.remove = function (this: RxDocument) {\n                if (!this.collection.schema.jsonSchema.crdt) {\n                    return oldRemove.bind(this)();\n                }\n                return this.updateCRDT({\n                    ifMatch: {\n                        $set: {\n                            _deleted: true\n                        }\n                    }\n                });\n            };\n\n            const oldAtomicPatch = proto.atomicPatch;\n            proto.atomicPatch = function (this: RxDocument, patch: any) {\n                if (!this.collection.schema.jsonSchema.crdt) {\n                    return oldAtomicPatch.bind(this)(patch);\n                }\n                return this.updateCRDT({\n                    ifMatch: {\n                        $set: patch\n                    }\n                });\n            };\n            const oldAtomicUpdate = proto.atomicUpdate;\n            proto.atomicUpdate = function (fn: any, context: string) {\n                if (!this.collection.schema.jsonSchema.crdt) {\n                    return oldAtomicUpdate.bind(this)(fn);\n                }\n                if (context === RX_CRDT_CONTEXT) {\n                    return oldAtomicUpdate.bind(this)(fn);\n                } else {\n                    throw newRxError('CRDT2', {\n                        id: this.primary,\n                        args: { context }\n                    });\n                }\n            };\n        },\n        RxCollection: (proto: any) => {\n            proto.insertCRDT = insertCRDT;\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preCreateRxCollection: {\n            after: (data) => {\n                if (!data.schema.crdt) {\n                    return;\n                }\n                if (data.conflictHandler) {\n                    throw newRxError('CRDT3', {\n                        collection: data.name,\n                        schema: data.schema\n                    });\n                }\n                data.conflictHandler = getCRDTConflictHandler(\n                    data.database.hashFunction,\n                    data.database.storage.statics,\n                    data.schema\n                );\n            }\n        },\n        createRxCollection: {\n            after: ({ collection }) => {\n                if (!collection.schema.jsonSchema.crdt) {\n                    return;\n                }\n\n                const crdtOptions = ensureNotFalsy(collection.schema.jsonSchema.crdt);\n                const crdtField = crdtOptions.field;\n                const getCrdt = objectPathMonad<any, CRDTDocumentField<any>>(crdtOptions.field);\n\n                /**\n                 * In dev-mode we have to ensure that all document writes\n                 * have the correct crdt state so that nothing is missed out\n                 * or could accidentally do non-crdt writes to the document.\n                 */\n                if (overwritable.isDevMode()) {\n                    const bulkWriteBefore = collection.storageInstance.bulkWrite.bind(collection.storageInstance);\n                    collection.storageInstance.bulkWrite = function (writes, context) {\n\n                        writes.forEach(write => {\n                            const newDocState: typeof write.document = clone(write.document);\n                            const crdts = getCrdt(newDocState);\n\n                            const rebuild = rebuildFromCRDT(\n                                collection.database.storage.statics,\n                                collection.schema.jsonSchema,\n                                newDocState,\n                                crdts\n                            );\n\n                            function docWithoutMeta(doc: any) {\n                                const ret: any = {};\n                                Object.entries(doc).forEach(([k, v]) => {\n                                    if (!k.startsWith('_')) {\n                                        ret[k] = v;\n                                    }\n                                });\n                                return ret;\n                            }\n                            if (!deepEqual(docWithoutMeta(newDocState), docWithoutMeta(rebuild))) {\n                                throw newRxError('SNH', {\n                                    document: newDocState\n                                });\n                            }\n                            const recalculatedHash = hashCRDTOperations(collection.database.hashFunction, crdts);\n                            if (crdts.hash !== recalculatedHash) {\n                                throw newRxError('SNH', {\n                                    document: newDocState,\n                                    args: { hash: crdts.hash, recalculatedHash }\n                                });\n                            }\n                        });\n\n                        return bulkWriteBefore(writes, context);\n                    };\n                }\n\n\n                const bulkInsertBefore = collection.bulkInsert.bind(collection);\n                collection.bulkInsert = async function (docsData: any[]) {\n                    const storageToken = await collection.database.storageToken;\n                    const useDocsData = docsData.map(docData => {\n                        const setMe: Partial<RxDocumentData<any>> = {};\n                        Object.entries(docData).forEach(([key, value]) => {\n                            if (\n                                !key.startsWith('_') &&\n                                key !== crdtField\n                            ) {\n                                setMe[key] = value;\n                            }\n                        });\n\n                        const crdtOperations: CRDTDocumentField<any> = {\n                            operations: [\n                                [{\n                                    creator: storageToken,\n                                    body: [{\n                                        ifMatch: {\n                                            $set: setMe\n                                        }\n                                    }],\n                                    time: now()\n                                }]\n                            ],\n                            hash: ''\n                        };\n                        crdtOperations.hash = hashCRDTOperations(collection.database.hashFunction, crdtOperations);\n                        objectPath.set(docData, crdtOptions.field, crdtOperations);\n                        return docData;\n                    });\n                    return bulkInsertBefore(useDocsData);\n                };\n            }\n        }\n    }\n};\n"],"mappings":"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"}