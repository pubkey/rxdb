{"version":3,"file":"rx-storage-instance-memory.js","names":["Subject","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","newRxError","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","getNewestOfDocumentStates","getFromMapOrThrow","lastOfArray","now","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","RX_META_LWT_MINIMUM","RxStorageDexieStatics","boundGE","boundGT","boundLE","attachmentMapKey","compareDocsWithIndex","ensureNotRemoved","getMemoryCollectionKey","putWriteRowToState","removeDocFromState","addIndexesToInternalsState","getMemoryIndexName","RxStorageInstanceMemory","storage","databaseName","collectionName","schema","internals","options","settings","closed","changes$","primaryPath","primaryKey","bulkWrite","documentWrites","context","ret","success","error","categorized","documents","errors","stateByIndex","Object","values","byIndex","bulkInsertDocs","forEach","writeRow","docId","document","undefined","bulkUpdateDocs","get","attachmentsMap","attachments","attachmentsAdd","attachment","set","documentId","attachmentId","attachmentData","attachmentsUpdate","attachmentsRemove","eventBulk","events","length","lastState","checkpoint","id","lwt","_meta","next","Promise","resolve","findDocumentsById","docIds","withDeleted","docInDb","_deleted","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","getQueryMatcher","queryPlanFields","index","mustManuallyResort","sortFieldsSameAsIndexFields","concat","lowerBound","startKeys","lowerBoundString","inclusiveStart","upperBound","endKeys","upperBoundString","inclusiveEnd","indexName","docsWithIndex","indexOfLower","indexString","indexOfUpper","rows","done","currentDoc","doc","push","sortComparator","getSortComparator","sort","slice","count","result","mode","getChangedDocumentsSince","sinceLwt","sinceId","lastDoc","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","data","changeStream","asObservable","remove","removed","collectionStates","close","reject","database","collection","complete","refCount","conflictResultionTasks","conflictResultionTasks$","resolveConflictResultionTask","_taskSolution","createMemoryStorageInstance","params","collectionKey","Map","instance"],"sources":["../../../../src/plugins/memory/rx-storage-instance-memory.ts"],"sourcesContent":["import { QueryMatcher } from 'event-reduce-js';\nimport {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport {\n    categorizeBulkWriteRows,\n    getNewestOfDocumentStates\n} from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport {\n    getFromMapOrThrow,\n    lastOfArray,\n    now,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM\n} from '../../util';\nimport { RxStorageDexieStatics } from '../dexie/dexie-statics';\nimport {\n    boundGE,\n    boundGT,\n    boundLE\n} from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes';\nimport type {\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public closed = false;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath as any,\n            this.internals.documents,\n            documentWrites,\n            context\n        );\n        ret.error = categorized.errors;\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                this.internals.documents.get(docId as any)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        /**\n         * Handle attachments\n         */\n        const attachmentsMap = this.internals.attachments;\n        categorized.attachmentsAdd.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsUpdate.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsRemove.forEach(attachment => {\n            attachmentsMap.delete(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId)\n            );\n        });\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.changes$.next(categorized.eventBulk);\n        }\n        return Promise.resolve(ret);\n    }\n\n    findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        const ret: RxDocumentDataById<RxDocType> = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n        if (!queryPlan.selectorSatisfiedByIndex) {\n            queryMatcher = RxStorageDexieStatics.getQueryMatcher(\n                this.schema,\n                preparedQuery\n            );\n        }\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortFieldsSameAsIndexFields;\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound: any[] = queryPlan.startKeys;\n        lowerBound = [false].concat(lowerBound);\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound,\n            queryPlan.inclusiveStart\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound,\n            queryPlan.inclusiveEnd\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n        const indexOfUpper = boundLE(\n            docsWithIndex,\n            {\n                indexString: upperBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n\n            if (\n                !currentDoc ||\n                indexOfLower > indexOfUpper\n            ) {\n                break;\n            }\n\n            if (!queryMatcher || queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            const sortComparator = RxStorageDexieStatics.getSortComparator(this.schema, preparedQuery);\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n        return Promise.resolve({\n            documents: rows\n        });\n    }\n\n    async count(\n        preparedQuery: MemoryPreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const result = await this.query(preparedQuery);\n        return {\n            count: result.documents.length,\n            mode: 'fast'\n        };\n    }\n\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ],\n            false\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        const lastDoc = lastOfArray(rows);\n        return Promise.resolve({\n            documents: rows,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        });\n    }\n\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ],\n            false\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        return Promise.resolve(data.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    close(): Promise<void> {\n        if (this.closed) {\n            return Promise.reject(newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            }));\n        }\n        this.closed = true;\n        this.changes$.complete();\n\n        this.internals.refCount = this.internals.refCount - 1;\n        if (this.internals.refCount === 0) {\n            this.storage.collectionStates.delete(\n                getMemoryCollectionKey(this.databaseName, this.collectionName)\n            );\n        }\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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"}