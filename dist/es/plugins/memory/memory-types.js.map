{"version":3,"file":"memory-types.js","names":[],"sources":["../../../../src/plugins/memory/memory-types.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport type {\n    DexiePreparedQuery,\n    RxAttachmentWriteData,\n    RxConflictResultionTask,\n    RxDocumentData,\n    RxStorage\n} from '../../types';\n\nexport type RxStorageMemorySettings = {};\nexport type RxStorageMemoryInstanceCreationOptions = {};\nexport type RxStorageMemory = RxStorage<MemoryStorageInternals<any>, RxStorageMemoryInstanceCreationOptions> & {\n    /**\n     * State by collectionKey\n     */\n    collectionStates: Map<string, MemoryStorageInternals<any>>;\n};\n\nexport type MemoryStorageInternalsByIndex<RxDocType> = {\n    index: string[];\n    docsWithIndex: DocWithIndexString<RxDocType>[];\n    getIndexableString: (docData: RxDocumentData<RxDocType>) => string;\n};\n\n/**\n * The internals are shared between multiple storage instances\n * that have been created with the same [databaseName+collectionName] combination.\n */\nexport type MemoryStorageInternals<RxDocType> = {\n    /**\n     * We re-use the memory state when multiple instances\n     * are created with the same params.\n     * If refCount beomces 0, we can delete the state.\n     */\n    refCount: number;\n    /**\n     * If this becomes true,\n     * it means that an instance has called remove()\n     * so all other instances should also not work anymore.\n     */\n    removed: boolean;\n    documents: Map<string, RxDocumentData<RxDocType>>;\n    /**\n     * Attachments data, indexed by a combined string\n     * consisting of [documentId + '||' + attachmentId]\n     */\n    attachments: Map<string, RxAttachmentWriteData>;\n    byIndex: {\n        /**\n         * Because RxDB requires a deterministic sorting\n         * on all indexes, we can be sure that the composed index key\n         * of each document is unique, because it contains the primaryKey\n         * as last index part.\n         * So we do not have to store the index-position when we want to do fast\n         * writes. Instead we can do a binary search over the existing array\n         * because RxDB also knows the previous state of the document when we do a bulkWrite().\n         */\n        [indexName: string]: MemoryStorageInternalsByIndex<RxDocType>;\n    };\n\n    /**\n     * To easier test the conflict resolution,\n     * the memory storage exposes the conflict resolution task subject\n     * so that we can inject own tasks during tests.\n     */\n    conflictResultionTasks$: Subject<RxConflictResultionTask<RxDocType>>;\n};\n\nexport type DocWithIndexString<RxDocType> = {\n    id: string;\n    doc: RxDocumentData<RxDocType>;\n    indexString: string;\n};\n\nexport type MemoryPreparedQuery<DocType> = DexiePreparedQuery<DocType>;\n"],"mappings":""}