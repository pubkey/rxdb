{"version":3,"file":"custom-events-plugin.js","names":["PouchDBCore","Subject","ensureNotFalsy","flatClone","getFromMapOrThrow","now","parseRevision","PROMISE_RESOLVE_VOID","randomCouchString","newRxError","getEventKey","pouchChangeRowToChangeEvent","POUCHDB_DESIGN_PREFIX","POUCHDB_LOCAL_PREFIX","pouchDocumentDataToRxDocumentData","writeAttachmentsToAttachments","eventEmitDataToStorageEvents","pouchDBInstance","primaryPath","emitData","ret","writeOptions","custom","hasOwnProperty","new_edits","Promise","all","writeDocs","map","writeDoc","id","_id","_attachments","previousDoc","previousDocs","get","parsedRevPrevious","_rev","parsedRevNew","height","hash","_deleted","event","operation","doc","previous","args","changeEvent","changeEventToNormal","startTime","endTime","push","writeRowById","writeDocsById","Map","forEach","set","writeResult","resultRow","startsWith","rev","writeMap","error","writeRow","document","attachments","newDoc","Object","assign","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","getCustomEventEmitterByPouch","pouch","key","__opts","name","adapter","join","emitter","subject","i","BULK_DOC_RUN_QUEUE","WeakMap","addCustomEventsPluginToPouch","oldBulkDocs","prototype","bulkDocs","newBulkDocs","body","options","callback","internalPouches","includes","call","err","result","queue","then","newBulkDocsInner","bind","usePouchResult","hasNonErrorWrite","docs","insertDocsById","Array","from","entries","previousRev","newRev","docInDb","previousDocsInDb","docInDbRev","status","useRevisions","start","ids","_revisions","slice","unshift","useNewRev","writeToPouchDocData","ok","deeperOptions","isDeeper","callReturn","callPromise","res","rej","docIds","Set","d","heighestSequence","changesSub","heighestSequencePromise","changes","since","live","include_docs","on","change","docId","has","seq","size","cancel","useOptsForOldBulkDocs","row","eventsPromise","emitId","runId","events","eventBulk","checkpoint","sequence","context","next","hasError","find","isArray","undefined","length","bulkGet","revs","latest","viaBulkGet","mustRefetchBecauseDeleted","results","firstDoc","reason","allDocs","keys","conflicts","deletedDocsViaAllDocs","idsWithRevs","rows","value","deletedDocsViaBulkGetWithRev","plugin","primary","storageChangeEvent","eventId","documentId","documentData","previousDocumentData"],"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n * @link https://hasura.io/blog/couchdb-style-conflict-resolution-rxdb-hasura/\n */\n\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchChangesOnChangeEvent,\n    PouchCheckpoint,\n    PouchDBInstance,\n    PouchWriteError,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    ensureNotFalsy,\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    parseRevision,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport {\n    getEventKey,\n    pouchChangeRowToChangeEvent,\n    POUCHDB_DESIGN_PREFIX,\n    POUCHDB_LOCAL_PREFIX,\n    pouchDocumentDataToRxDocumentData,\n    writeAttachmentsToAttachments\n} from './pouchdb-helper';\nimport type { ChangeEvent } from 'event-reduce-js';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter<RxDocType> = {\n    subject: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, PouchCheckpoint>>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter<any>> = new Map();\n\nexport function getCustomEventEmitterByPouch<RxDocType>(\n    pouch: PouchDBInstance\n): Emitter<RxDocType> {\n    const key = [\n        pouch.__opts.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject()\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\n/**\n * Counter, used to debug stuff.\n */\nlet i = 0;\n\n\n/**\n * Because we cannot force pouchdb to await bulkDocs runs\n * inside of a transaction, like done with the other RxStorage implementations,\n * we have to ensure the calls to bulkDocs() do not run in parallel. \n * \n * TODO this is somehow a hack. Instead of doing that, inspect how\n * PouchDB runs bulkDocs internally and adapt that transaction handling.\n */\nconst BULK_DOC_RUN_QUEUE: WeakMap<PouchDBInstance, Promise<any>> = new WeakMap();\n\n/**\n * PouchDB is like a minefield,\n * where stuff randomly does not work dependent on some conditions.\n * So instead of doing plain writes,\n * we hack into the bulkDocs() function\n * and adjust the behavior accordingly.\n */\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n\n    /**\n     * Ensure we do not run bulkDocs() in parallel on the same PouchDB instance.\n     */\n    const newBulkDocs = function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n\n        /**\n         * Normalize inputs\n         * because there are many ways to call pouchdb.bulkDocs()\n         */\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n\n        /**\n         * PouchDB internal requests\n         * must still be handled normally\n         * to decrease the likelyness of bugs.\n         */\n        const internalPouches = [\n            '_replicator',\n            '_users',\n            'pouch__all_dbs__'\n        ];\n        if (\n            (\n                internalPouches.includes(this.name) ||\n                this.name.includes('-mrview-')\n            )\n        ) {\n            return oldBulkDocs.call(\n                this,\n                body,\n                options,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err, null) : 0;\n                    } else {\n                        if (callback) {\n                            callback(null, result);\n                        }\n                    }\n                });\n        }\n\n\n        let queue = BULK_DOC_RUN_QUEUE.get(this);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue.then(async () => {\n            const ret = await newBulkDocsInner.bind(this)(\n                body,\n                options,\n                callback\n            );\n            return ret;\n        });\n        BULK_DOC_RUN_QUEUE.set(this, queue);\n        return queue;\n    };\n\n\n    const newBulkDocsInner = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        const startTime = now();\n        const runId = i++;\n\n        /**\n         * Normalize inputs\n         * because there are many ways to call pouchdb.bulkDocs()\n         */\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        // throw if no docs given, because RxDB should never make such a call.\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocsInDb: Map<string, RxDocumentData<any>> = options.custom ? options.custom.previousDocsInDb : new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const viaBulkGet = await this.bulkGet({\n                docs: docs.map(doc => ({ id: doc._id })),\n                revs: true,\n                latest: true\n            });\n\n            /**\n             * bulkGet() does not return deleted documents,\n             * so we must refetch them via allDocs() afterwards.\n             */\n            const mustRefetchBecauseDeleted: string[] = [];\n\n            viaBulkGet.results.forEach(resultRow => {\n                const firstDoc = resultRow.docs[0];\n                if (firstDoc.ok) {\n                    previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                } else {\n                    if (firstDoc.error && firstDoc.error.reason === 'deleted') {\n                        mustRefetchBecauseDeleted.push(resultRow.id);\n                    }\n                }\n            });\n\n            if (mustRefetchBecauseDeleted.length > 0) {\n                const deletedDocsViaAllDocs = await this.allDocs({\n                    keys: mustRefetchBecauseDeleted,\n                    include_docs: true,\n                    conflicts: true,\n                });\n\n                const idsWithRevs: { id: string; rev: string; }[] = [];\n                deletedDocsViaAllDocs.rows.forEach(row => {\n                    idsWithRevs.push({\n                        id: row.id,\n                        rev: row.value.rev\n                    });\n                });\n\n                const deletedDocsViaBulkGetWithRev = await this.bulkGet({\n                    docs: idsWithRevs,\n                    revs: true,\n                    latest: true\n                });\n\n                deletedDocsViaBulkGetWithRev.results.forEach(resultRow => {\n                    const firstDoc = resultRow.docs[0];\n                    if (firstDoc.ok) {\n                        previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                deletedDocsViaBulkGetWithRev,\n                                resultRow\n                            }\n                        });\n                    }\n                });\n\n            }\n        }\n\n        /**\n         * Custom handling if the call came from RxDB (options.custom is set).\n         */\n        const usePouchResult: (PouchBulkDocResultRow | PouchWriteError)[] = [];\n        let hasNonErrorWrite = false;\n        if (\n            options.custom &&\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            /**\n             * Reset the write docs array,\n             * because we only write non-conflicting documents.\n             */\n            docs = [];\n            const writeRowById: Map<string, BulkWriteRow<any>> = options.custom.writeRowById;\n            const insertDocsById: Map<string, any> = options.custom.insertDocsById;\n\n            Array.from(writeRowById.entries()).forEach(([id, writeRow]) => {\n                const previousRev = writeRow.previous ? writeRow.previous._rev : null;\n                const newRev = parseRevision(writeRow.document._rev);\n                const docInDb = previousDocsInDb.get(id);\n                const docInDbRev: string | null = docInDb ? docInDb._rev : null;\n\n                if (\n                    docInDbRev !== previousRev\n                ) {\n                    // we have a conflict\n                    usePouchResult.push({\n                        error: true,\n                        id,\n                        status: 409\n                    });\n                } else {\n                    const useRevisions = {\n                        start: newRev.height,\n                        ids: docInDb ? docInDb._revisions.ids.slice(0) : []\n                    };\n                    useRevisions.ids.unshift(newRev.hash);\n                    const useNewRev = useRevisions.start + '-' + newRev.hash;\n\n                    hasNonErrorWrite = true;\n                    const writeToPouchDocData = Object.assign(\n                        {},\n                        insertDocsById.get(id),\n                        {\n                            _revisions: useRevisions,\n                            _rev: useNewRev\n                        }\n                    );\n                    docs.push(writeToPouchDocData);\n                    usePouchResult.push({\n                        ok: true,\n                        id,\n                        rev: writeRow.document._rev\n                    });\n                }\n            });\n\n            /**\n             * Optimization shortcut,\n             * if all document writes were conflict errors,\n             * we can skip directly.\n             */\n            if (!hasNonErrorWrite) {\n                return usePouchResult;\n            }\n        }\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n        let callReturn: any;\n        const callPromise = new Promise((res, rej) => {\n\n            /**\n             * The emitted EventBulk from the write to the pouchdb, needs to contain a checkpoint field.\n             * Because PouchDB works on sequence number to sort changes,\n             * we have to fetch the latest sequence number out of the events because it\n             * is not possible to that that from pouch.bulkDocs().\n             */\n            const docIds: Set<string> = new Set(docs.map(d => d._id));\n            let heighestSequence = 0;\n            let changesSub: PouchChangesOnChangeEvent;\n            const heighestSequencePromise = new Promise<number>(res => {\n                changesSub = this.changes({\n                    since: 'now',\n                    live: true,\n                    include_docs: true\n                }).on('change', (change: any) => {\n                    const docId: string = change.id;\n                    if (docIds.has(docId)) {\n                        docIds.delete(docId);\n                        if (heighestSequence < change.seq) {\n                            heighestSequence = change.seq;\n                        }\n\n                        if (docIds.size === 0) {\n                            (changesSub as any).cancel();\n                            res(heighestSequence);\n                        }\n                    }\n                }) as any;\n            });\n\n\n            /**\n             * We cannot send the custom here,\n             * because when a migration between different major RxDB versions is done,\n             * multiple versions of the RxDB PouchDB RxStorage might have added their\n             * custom method via PouchDBCore.plugin()\n             */\n            const useOptsForOldBulkDocs = flatClone(deeperOptions);\n            delete useOptsForOldBulkDocs.custom;\n\n            callReturn = oldBulkDocs.call(\n                this,\n                docs,\n                useOptsForOldBulkDocs,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err) : rej(err);\n                    } else {\n                        return (async () => {\n                            const hasError = result.find(row => (row as PouchWriteError).error);\n                            let heighestSequence = -1;\n                            if (!hasError) {\n                                heighestSequence = await heighestSequencePromise;\n                            } else {\n                                changesSub.cancel();\n                            }\n\n                            result.forEach(row => {\n                                usePouchResult.push(row);\n                            });\n\n                            /**\n                             * For calls that came from RxDB,\n                             * we have to ensure that the events are emitted\n                             * before the actual call resolves.\n                             */\n                            let eventsPromise = PROMISE_RESOLVE_VOID;\n                            if (!options.isDeeper) {\n                                const endTime = now();\n                                const emitData = {\n                                    emitId: runId,\n                                    writeDocs: docs,\n                                    writeOptions: options,\n                                    writeResult: usePouchResult,\n                                    previousDocs: previousDocsInDb,\n                                    startTime,\n                                    endTime\n                                };\n                                eventsPromise = eventEmitDataToStorageEvents(\n                                    this,\n                                    '_id',\n                                    emitData\n                                ).then(events => {\n                                    const eventBulk: EventBulk<any, PouchCheckpoint> = {\n                                        id: randomCouchString(10),\n                                        events,\n                                        checkpoint: {\n                                            sequence: heighestSequence\n                                        },\n                                        context: options.custom ? options.custom.context : 'pouchdb-internal'\n                                    };\n\n                                    const emitter = getCustomEventEmitterByPouch(this);\n                                    emitter.subject.next(eventBulk);\n                                });\n                            }\n\n                            if (callback) {\n                                callback(null, usePouchResult);\n                            } else {\n                                return eventsPromise.then(() => {\n                                    res(usePouchResult);\n                                    return usePouchResult;\n                                });\n                            }\n                        })();\n                    }\n                });\n        });\n\n        if (options.custom) {\n            return callPromise;\n        }\n\n\n\n        return callReturn;\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\nexport async function eventEmitDataToStorageEvents<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    emitData: EmitData\n): Promise<RxStorageChangeEvent<RxDocumentData<RxDocType>>[]> {\n    const ret: RxStorageChangeEvent<RxDocumentData<RxDocType>>[] = [];\n    if (\n        !emitData.writeOptions.custom &&\n        emitData.writeOptions.hasOwnProperty('new_edits') &&\n        emitData.writeOptions.new_edits === false\n    ) {\n        await Promise.all(\n            emitData.writeDocs.map(async (writeDoc) => {\n                const id = writeDoc._id;\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                let previousDoc = emitData.previousDocs.get(id);\n                if (previousDoc) {\n                    previousDoc = pouchDocumentDataToRxDocumentData(\n                        primaryPath,\n                        previousDoc\n                    );\n                }\n                if (previousDoc) {\n                    const parsedRevPrevious = parseRevision(previousDoc._rev);\n                    const parsedRevNew = parseRevision(writeDoc._rev);\n                    if (\n                        (\n                            parsedRevPrevious.height > parsedRevNew.height ||\n                            /**\n                             * If the revision height is equal,\n                             * we determine the higher hash as winner.\n                             */\n                            (\n                                parsedRevPrevious.height === parsedRevNew.height &&\n                                parsedRevPrevious.hash > parsedRevNew.hash\n                            )\n                        )\n                    ) {\n                        /**\n                         * The newly added document was not the latest revision\n                         * so we drop the write.\n                         * With plain PouchDB it makes sense to store conflicting branches of the document\n                         * but RxDB assumes that the conflict is resolved directly.\n                         */\n                        return;\n                    }\n                }\n\n                if (!previousDoc && writeDoc._deleted) {\n                    // deleted document was added as revision\n                    return;\n                }\n\n                if (previousDoc && previousDoc._deleted && writeDoc._deleted) {\n                    // delete document was deleted again\n                    return;\n                }\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if ((!previousDoc || previousDoc._deleted) && !writeDoc._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: writeDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeDoc._deleted && previousDoc && !previousDoc._deleted) {\n                    // was delete\n                    previousDoc._rev = writeDoc._rev;\n                    event = {\n                        operation: 'DELETE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else if (\n                    previousDoc\n                ) {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else {\n                    throw newRxError('SNH', { args: { writeDoc } });\n                }\n\n                const changeEvent = changeEventToNormal(\n                    pouchDBInstance,\n                    primaryPath,\n                    event,\n                    emitData.startTime,\n                    emitData.endTime\n                );\n\n                ret.push(changeEvent);\n            })\n        );\n    }\n    /**\n     * There is no write map given for internal pouchdb document writes\n     * like it is done with replication.\n     */\n    else if (\n        !emitData.writeOptions.custom ||\n        (emitData.writeOptions.custom && !emitData.writeOptions.custom.writeRowById)\n    ) {\n        const writeDocsById: Map<string, any> = new Map();\n        emitData.writeDocs.forEach(writeDoc => writeDocsById.set(writeDoc._id, writeDoc));\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                const id = resultRow.id;\n                if (\n                    id.startsWith(POUCHDB_DESIGN_PREFIX) ||\n                    id.startsWith(POUCHDB_LOCAL_PREFIX)\n                ) {\n                    return;\n                }\n                let writeDoc = getFromMapOrThrow(writeDocsById, resultRow.id);\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                writeDoc = flatClone(writeDoc);\n                writeDoc._rev = (resultRow as any).rev;\n                const event = pouchChangeRowToChangeEvent<RxDocType>(\n                    primaryPath as any,\n                    writeDoc\n                );\n                const changeEvent = changeEventToNormal(pouchDBInstance, primaryPath, event);\n                ret.push(changeEvent);\n            })\n        );\n    } else {\n        const writeMap: Map<string, BulkWriteRow<RxDocType>> = emitData.writeOptions.custom.writeRowById;\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                if ((resultRow as PouchWriteError).error) {\n                    return;\n                }\n                const id = resultRow.id;\n                const writeRow = getFromMapOrThrow(writeMap, id);\n                const attachments = await writeAttachmentsToAttachments(writeRow.document._attachments);\n                const newDoc: RxDocumentData<RxDocType> = Object.assign(\n                    {},\n                    writeRow.document,\n                    {\n                        _attachments: attachments,\n                        _rev: (resultRow as PouchBulkDocResultRow).rev\n                    }\n                );\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if (!writeRow.previous || writeRow.previous._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: newDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const attachments = await writeAttachmentsToAttachments(writeRow.previous._attachments);\n                    const previousDoc = Object.assign(\n                        {},\n                        writeRow.previous,\n                        {\n                            _attachments: attachments\n                        }\n                    );\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: writeRow.document,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    } as any;\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: newDoc,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n                    const changeEvent = changeEventToNormal(\n                        pouchDBInstance,\n                        ensureNotFalsy(emitData.writeOptions.custom).primaryPath,\n                        event,\n                        emitData.startTime,\n                        emitData.endTime\n                    );\n                    ret.push(changeEvent);\n                }\n            })\n        );\n    }\n\n    return ret;\n}\n\nexport function changeEventToNormal<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    change: ChangeEvent<RxDocumentData<RxDocType>>,\n    startTime?: number,\n    endTime?: number\n): RxStorageChangeEvent<RxDocumentData<RxDocType>> {\n    const doc: RxDocumentData<RxDocType> = change.operation === 'DELETE' ? change.previous as any : change.doc as any;\n    const primary: string = (doc as any)[primaryPath];\n    const storageChangeEvent: RxStorageChangeEvent<RxDocumentData<RxDocType>> = {\n        eventId: getEventKey(pouchDBInstance, primary, change),\n        documentId: primary,\n        documentData: change.doc as any,\n        previousDocumentData: change.previous as any,\n        operation: change.operation,\n        startTime,\n        endTime\n    };\n    return storageChangeEvent;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAcA,OAAOA,WAAW,MAAM,cAAc;AACtC,SAASC,OAAO,QAAQ,MAAM;AAC9B,SACIC,cAAc,EACdC,SAAS,EACTC,iBAAiB,EACjBC,GAAG,EACHC,aAAa,EACbC,oBAAoB,EACpBC,iBAAiB,QACd,YAAY;AACnB,SAASC,UAAU,QAAQ,gBAAgB;AAC3C,SACIC,WAAW,EACXC,2BAA2B,EAC3BC,qBAAqB,EACrBC,oBAAoB,EACpBC,iCAAiC,EACjCC,6BAA6B,QAC1B,kBAAkB;AA+czB,WAAsBC,4BAA4B,YAA5BA,4BAA4B,CAC9CC,eAAgC,EAChCC,WAAmB,EACnBC,QAAkB;EAAA,IACwC;IAC1D,IAAMC,GAAsD,GAAG,EAAE;IAAC;MAAA,IAE9D,CAACD,QAAQ,CAACE,YAAY,CAACC,MAAM,IAC7BH,QAAQ,CAACE,YAAY,CAACE,cAAc,CAAC,WAAW,CAAC,IACjDJ,QAAQ,CAACE,YAAY,CAACG,SAAS,KAAK,KAAK;QAAA,uBAEnCC,OAAO,CAACC,GAAG,CACbP,QAAQ,CAACQ,SAAS,CAACC,GAAG,WAAQC,QAAQ;UAAA,IAAK;YACvC,IAAMC,EAAE,GAAGD,QAAQ,CAACE,GAAG;YACvBF,QAAQ,GAAGf,iCAAiC,CACxCI,WAAW,EACXW,QAAQ,CACX;YAAC,uBAC4Bd,6BAA6B,CAACc,QAAQ,CAACG,YAAY,CAAC;cAAlFH,QAAQ,CAACG,YAAY,wBAA6D;cAClF,IAAIC,WAAW,GAAGd,QAAQ,CAACe,YAAY,CAACC,GAAG,CAACL,EAAE,CAAC;cAC/C,IAAIG,WAAW,EAAE;gBACbA,WAAW,GAAGnB,iCAAiC,CAC3CI,WAAW,EACXe,WAAW,CACd;cACL;cACA,IAAIA,WAAW,EAAE;gBACb,IAAMG,iBAAiB,GAAG9B,aAAa,CAAC2B,WAAW,CAACI,IAAI,CAAC;gBACzD,IAAMC,YAAY,GAAGhC,aAAa,CAACuB,QAAQ,CAACQ,IAAI,CAAC;gBACjD,IAEQD,iBAAiB,CAACG,MAAM,GAAGD,YAAY,CAACC,MAAM;gBAC9C;AAC5B;AACA;AACA;;gBAEgCH,iBAAiB,CAACG,MAAM,KAAKD,YAAY,CAACC,MAAM,IAChDH,iBAAiB,CAACI,IAAI,GAAGF,YAAY,CAACE,IACzC,EAEP;kBACE;AACxB;AACA;AACA;AACA;AACA;kBACwB;gBACJ;cACJ;cAEA,IAAI,CAACP,WAAW,IAAIJ,QAAQ,CAACY,QAAQ,EAAE;gBACnC;gBACA;cACJ;cAEA,IAAIR,WAAW,IAAIA,WAAW,CAACQ,QAAQ,IAAIZ,QAAQ,CAACY,QAAQ,EAAE;gBAC1D;gBACA;cACJ;cAEA,IAAIC,KAA6C;cACjD,IAAI,CAAC,CAACT,WAAW,IAAIA,WAAW,CAACQ,QAAQ,KAAK,CAACZ,QAAQ,CAACY,QAAQ,EAAE;gBAC9D;gBACAC,KAAK,GAAG;kBACJC,SAAS,EAAE,QAAQ;kBACnBC,GAAG,EAAEf,QAAQ;kBACbC,EAAE,EAAEA,EAAE;kBACNe,QAAQ,EAAE;gBACd,CAAC;cACL,CAAC,MAAM,IAAIhB,QAAQ,CAACY,QAAQ,IAAIR,WAAW,IAAI,CAACA,WAAW,CAACQ,QAAQ,EAAE;gBAClE;gBACAR,WAAW,CAACI,IAAI,GAAGR,QAAQ,CAACQ,IAAI;gBAChCK,KAAK,GAAG;kBACJC,SAAS,EAAE,QAAQ;kBACnBC,GAAG,EAAEf,QAAQ;kBACbC,EAAE,EAAEA,EAAE;kBACNe,QAAQ,EAAEZ;gBACd,CAAC;cACL,CAAC,MAAM,IACHA,WAAW,EACb;gBACE;gBACAS,KAAK,GAAG;kBACJC,SAAS,EAAE,QAAQ;kBACnBC,GAAG,EAAEf,QAAQ;kBACbC,EAAE,EAAEA,EAAE;kBACNe,QAAQ,EAAEZ;gBACd,CAAC;cACL,CAAC,MAAM;gBACH,MAAMxB,UAAU,CAAC,KAAK,EAAE;kBAAEqC,IAAI,EAAE;oBAAEjB,QAAQ,EAARA;kBAAS;gBAAE,CAAC,CAAC;cACnD;cAEA,IAAMkB,WAAW,GAAGC,mBAAmB,CACnC/B,eAAe,EACfC,WAAW,EACXwB,KAAK,EACLvB,QAAQ,CAAC8B,SAAS,EAClB9B,QAAQ,CAAC+B,OAAO,CACnB;cAED9B,GAAG,CAAC+B,IAAI,CAACJ,WAAW,CAAC;YAAC;UAC1B,CAAC;YAAA;UAAA;QAAA,EAAC,CACL;MAAA;QAAA;UAAA,IAOD,CAAC5B,QAAQ,CAACE,YAAY,CAACC,MAAM,IAC5BH,QAAQ,CAACE,YAAY,CAACC,MAAM,IAAI,CAACH,QAAQ,CAACE,YAAY,CAACC,MAAM,CAAC8B,YAAa;YAE5E,IAAMC,aAA+B,GAAG,IAAIC,GAAG,EAAE;YACjDnC,QAAQ,CAACQ,SAAS,CAAC4B,OAAO,CAAC,UAAA1B,QAAQ;cAAA,OAAIwB,aAAa,CAACG,GAAG,CAAC3B,QAAQ,CAACE,GAAG,EAAEF,QAAQ,CAAC;YAAA,EAAC;YAAC,uBAC5EJ,OAAO,CAACC,GAAG,CACbP,QAAQ,CAACsC,WAAW,CAAC7B,GAAG,WAAQ8B,SAAS;cAAA,IAAK;gBAC1C,IAAM5B,EAAE,GAAG4B,SAAS,CAAC5B,EAAE;gBACvB,IACIA,EAAE,CAAC6B,UAAU,CAAC/C,qBAAqB,CAAC,IACpCkB,EAAE,CAAC6B,UAAU,CAAC9C,oBAAoB,CAAC,EACrC;kBACE;gBACJ;gBACA,IAAIgB,QAAQ,GAAGzB,iBAAiB,CAACiD,aAAa,EAAEK,SAAS,CAAC5B,EAAE,CAAC;gBAC7DD,QAAQ,GAAGf,iCAAiC,CACxCI,WAAW,EACXW,QAAQ,CACX;gBAAC,uBAE4Bd,6BAA6B,CAACc,QAAQ,CAACG,YAAY,CAAC;kBAAlFH,QAAQ,CAACG,YAAY,yBAA6D;kBAClFH,QAAQ,GAAG1B,SAAS,CAAC0B,QAAQ,CAAC;kBAC9BA,QAAQ,CAACQ,IAAI,GAAIqB,SAAS,CAASE,GAAG;kBACtC,IAAMlB,KAAK,GAAG/B,2BAA2B,CACrCO,WAAW,EACXW,QAAQ,CACX;kBACD,IAAMkB,WAAW,GAAGC,mBAAmB,CAAC/B,eAAe,EAAEC,WAAW,EAAEwB,KAAK,CAAC;kBAC5EtB,GAAG,CAAC+B,IAAI,CAACJ,WAAW,CAAC;gBAAC;cAC1B,CAAC;gBAAA;cAAA;YAAA,EAAC,CACL;UAAA;YAED,IAAMc,QAA8C,GAAG1C,QAAQ,CAACE,YAAY,CAACC,MAAM,CAAC8B,YAAY;YAAC,uBAC3F3B,OAAO,CAACC,GAAG,CACbP,QAAQ,CAACsC,WAAW,CAAC7B,GAAG,WAAQ8B,SAAS;cAAA,IAAK;gBAC1C,IAAKA,SAAS,CAAqBI,KAAK,EAAE;kBACtC;gBACJ;gBACA,IAAMhC,EAAE,GAAG4B,SAAS,CAAC5B,EAAE;gBACvB,IAAMiC,QAAQ,GAAG3D,iBAAiB,CAACyD,QAAQ,EAAE/B,EAAE,CAAC;gBAAC,uBACvBf,6BAA6B,CAACgD,QAAQ,CAACC,QAAQ,CAAChC,YAAY,CAAC,iBAAjFiC,WAAW;kBAAA;oBAAA,IAmDbF,QAAQ,CAACC,QAAQ,CAACvB,QAAQ,KAEtB,CAACsB,QAAQ,CAAClB,QAAQ,IAClBkB,QAAQ,CAAClB,QAAQ,CAACJ,QAAQ,CAC7B;sBAOD,IAAMM,WAAW,GAAGC,mBAAmB,CACnC/B,eAAe,EACff,cAAc,CAACiB,QAAQ,CAACE,YAAY,CAACC,MAAM,CAAC,CAACJ,WAAW,EACxDwB,KAAK,EACLvB,QAAQ,CAAC8B,SAAS,EAClB9B,QAAQ,CAAC+B,OAAO,CACnB;sBACD9B,GAAG,CAAC+B,IAAI,CAACJ,WAAW,CAAC;oBAAC;kBAAA;kBApE1B,IAAMmB,MAAiC,GAAGC,MAAM,CAACC,MAAM,CACnD,CAAC,CAAC,EACFL,QAAQ,CAACC,QAAQ,EACjB;oBACIhC,YAAY,EAAEiC,WAAW;oBACzB5B,IAAI,EAAGqB,SAAS,CAA2BE;kBAC/C,CAAC,CACJ;kBAED,IAAIlB,KAA6C;kBAAC;oBAAA,IAC9C,CAACqB,QAAQ,CAAClB,QAAQ,IAAIkB,QAAQ,CAAClB,QAAQ,CAACJ,QAAQ;sBAChD;sBACAC,KAAK,GAAG;wBACJC,SAAS,EAAE,QAAQ;wBACnBC,GAAG,EAAEsB,MAAM;wBACXpC,EAAE,EAAEA,EAAE;wBACNe,QAAQ,EAAE;sBACd,CAAC;oBAAC;sBAAA;wBAAA,IACKkB,QAAQ,CAACC,QAAQ,CAACvB,QAAQ;0BACjC;0BAEA;0BACA;0BACA;0BAAA,uBAC0B1B,6BAA6B,CAACgD,QAAQ,CAAClB,QAAQ,CAACb,YAAY,CAAC,iBAAjFiC,WAAW;4BACjB,IAAMhC,WAAW,GAAGkC,MAAM,CAACC,MAAM,CAC7B,CAAC,CAAC,EACFL,QAAQ,CAAClB,QAAQ,EACjB;8BACIb,YAAY,EAAEiC;4BAClB,CAAC,CACJ;4BAEDvB,KAAK,GAAG;8BACJC,SAAS,EAAE,QAAQ;8BACnBC,GAAG,EAAEmB,QAAQ,CAACC,QAAQ;8BACtBlC,EAAE,EAAE4B,SAAS,CAAC5B,EAAE;8BAChBe,QAAQ,EAAEZ;4BACd,CAAQ;0BAAC;wBAAA;0BAET;0BACAS,KAAK,GAAG;4BACJC,SAAS,EAAE,QAAQ;4BACnBC,GAAG,EAAEsB,MAAM;4BACXpC,EAAE,EAAE4B,SAAS,CAAC5B,EAAE;4BAChBe,QAAQ,EAAEkB,QAAQ,CAAClB;0BACvB,CAAC;wBAAC;sBAAA;sBAAA;oBAAA;kBAAA;kBAAA;gBAAA;cAwBV,CAAC;gBAAA;cAAA;YAAA,EAAC,CACL;UAAA;QAAA;QAAA;MAAA;IAAA;IAAA;MAGL,OAAOzB,GAAG;IAAC,KAAJA,GAAG;EACd,CAAC;IAAA;EAAA;AAAA;AA/qBD;AACA,IAAIiD,YAAY,GAAG,KAAK;AAiBxB,OAAO,IAAMC,+BAA0D,GAAG,IAAIhB,GAAG,EAAE;AAEnF,OAAO,SAASiB,4BAA4B,CACxCC,KAAsB,EACJ;EAClB,IAAMC,GAAG,GAAG,CACRD,KAAK,CAACE,MAAM,CAACC,IAAI,EACjBH,KAAK,CAACI,OAAO,CAChB,CAACC,IAAI,CAAC,GAAG,CAAC;EACX,IAAIC,OAAO,GAAGR,+BAA+B,CAACnC,GAAG,CAACsC,GAAG,CAAC;EACtD,IAAI,CAACK,OAAO,EAAE;IACVA,OAAO,GAAG;MACNC,OAAO,EAAE,IAAI9E,OAAO;IACxB,CAAC;IACDqE,+BAA+B,CAACd,GAAG,CAACiB,GAAG,EAAEK,OAAO,CAAC;EACrD;EACA,OAAOA,OAAO;AAClB;;AAGA;AACA;AACA;AACA,IAAIE,CAAC,GAAG,CAAC;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,kBAA0D,GAAG,IAAIC,OAAO,EAAE;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,4BAA4B,GAAG;EAC3C,IAAId,YAAY,EAAE;IACd;EACJ;EACAA,YAAY,GAAG,IAAI;EAEnB,IAAMe,WAAgB,GAAGpF,WAAW,CAACqF,SAAS,CAACC,QAAQ;;EAEvD;AACJ;AACA;EACI,IAAMC,WAAW,GAAG,SAAdA,WAAW,CAEbC,IAAkD,EAClDC,OAA4B,EAC5BC,QAAkB,EACpB;IAAA;IAEE;AACR;AACA;AACA;IACQ,IAAI,OAAOD,OAAO,KAAK,UAAU,EAAE;MAC/BC,QAAQ,GAAGD,OAAO;MAClBA,OAAO,GAAG,CAAC,CAAC;IAChB;IACA,IAAI,CAACA,OAAO,EAAE;MACVA,OAAO,GAAG,CAAC,CAAC;IAChB;;IAGA;AACR;AACA;AACA;AACA;IACQ,IAAME,eAAe,GAAG,CACpB,aAAa,EACb,QAAQ,EACR,kBAAkB,CACrB;IACD,IAEQA,eAAe,CAACC,QAAQ,CAAC,IAAI,CAACjB,IAAI,CAAC,IACnC,IAAI,CAACA,IAAI,CAACiB,QAAQ,CAAC,UAAU,CAAC,EAEpC;MACE,OAAOR,WAAW,CAACS,IAAI,CACnB,IAAI,EACJL,IAAI,EACJC,OAAO,EACP,UAACK,GAAQ,EAAEC,MAAmD,EAAK;QAC/D,IAAID,GAAG,EAAE;UACLJ,QAAQ,GAAGA,QAAQ,CAACI,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC;QACtC,CAAC,MAAM;UACH,IAAIJ,QAAQ,EAAE;YACVA,QAAQ,CAAC,IAAI,EAAEK,MAAM,CAAC;UAC1B;QACJ;MACJ,CAAC,CAAC;IACV;IAGA,IAAIC,KAAK,GAAGf,kBAAkB,CAAC9C,GAAG,CAAC,IAAI,CAAC;IACxC,IAAI,CAAC6D,KAAK,EAAE;MACRA,KAAK,GAAGzF,oBAAoB;IAChC;IACAyF,KAAK,GAAGA,KAAK,CAACC,IAAI;MAAA,IAAa;QAAA,uBACTC,gBAAgB,CAACC,IAAI,CAAC,KAAI,CAAC,CACzCX,IAAI,EACJC,OAAO,EACPC,QAAQ,CACX;MAEL,CAAC;QAAA;MAAA;IAAA,EAAC;IACFT,kBAAkB,CAACzB,GAAG,CAAC,IAAI,EAAEwC,KAAK,CAAC;IACnC,OAAOA,KAAK;EAChB,CAAC;EAGD,IAAME,gBAAgB,YAAhBA,gBAAgB,CAElBV,IAAkD,EAClDC,OAA4B,EAC5BC,QAAkB;IAAA,IACpB;MAAA;QA8GE;AACR;AACA;QACQ,IAAMU,cAA2D,GAAG,EAAE;QACtE,IAAIC,gBAAgB,GAAG,KAAK;QAC5B,IACIZ,OAAO,CAACnE,MAAM,IACdmE,OAAO,CAAClE,cAAc,CAAC,WAAW,CAAC,IACnCkE,OAAO,CAACjE,SAAS,KAAK,KAAK,EAC7B;UACE;AACZ;AACA;AACA;UACY8E,IAAI,GAAG,EAAE;UACT,IAAMlD,YAA4C,GAAGqC,OAAO,CAACnE,MAAM,CAAC8B,YAAY;UAChF,IAAMmD,cAAgC,GAAGd,OAAO,CAACnE,MAAM,CAACiF,cAAc;UAEtEC,KAAK,CAACC,IAAI,CAACrD,YAAY,CAACsD,OAAO,EAAE,CAAC,CAACnD,OAAO,CAAC,gBAAoB;YAAA,IAAlBzB,EAAE;cAAEiC,QAAQ;YACrD,IAAM4C,WAAW,GAAG5C,QAAQ,CAAClB,QAAQ,GAAGkB,QAAQ,CAAClB,QAAQ,CAACR,IAAI,GAAG,IAAI;YACrE,IAAMuE,MAAM,GAAGtG,aAAa,CAACyD,QAAQ,CAACC,QAAQ,CAAC3B,IAAI,CAAC;YACpD,IAAMwE,OAAO,GAAGC,gBAAgB,CAAC3E,GAAG,CAACL,EAAE,CAAC;YACxC,IAAMiF,UAAyB,GAAGF,OAAO,GAAGA,OAAO,CAACxE,IAAI,GAAG,IAAI;YAE/D,IACI0E,UAAU,KAAKJ,WAAW,EAC5B;cACE;cACAP,cAAc,CAACjD,IAAI,CAAC;gBAChBW,KAAK,EAAE,IAAI;gBACXhC,EAAE,EAAFA,EAAE;gBACFkF,MAAM,EAAE;cACZ,CAAC,CAAC;YACN,CAAC,MAAM;cACH,IAAMC,YAAY,GAAG;gBACjBC,KAAK,EAAEN,MAAM,CAACrE,MAAM;gBACpB4E,GAAG,EAAEN,OAAO,GAAGA,OAAO,CAACO,UAAU,CAACD,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC,GAAG;cACrD,CAAC;cACDJ,YAAY,CAACE,GAAG,CAACG,OAAO,CAACV,MAAM,CAACpE,IAAI,CAAC;cACrC,IAAM+E,SAAS,GAAGN,YAAY,CAACC,KAAK,GAAG,GAAG,GAAGN,MAAM,CAACpE,IAAI;cAExD6D,gBAAgB,GAAG,IAAI;cACvB,IAAMmB,mBAAmB,GAAGrD,MAAM,CAACC,MAAM,CACrC,CAAC,CAAC,EACFmC,cAAc,CAACpE,GAAG,CAACL,EAAE,CAAC,EACtB;gBACIsF,UAAU,EAAEH,YAAY;gBACxB5E,IAAI,EAAEkF;cACV,CAAC,CACJ;cACDjB,IAAI,CAACnD,IAAI,CAACqE,mBAAmB,CAAC;cAC9BpB,cAAc,CAACjD,IAAI,CAAC;gBAChBsE,EAAE,EAAE,IAAI;gBACR3F,EAAE,EAAFA,EAAE;gBACF8B,GAAG,EAAEG,QAAQ,CAACC,QAAQ,CAAC3B;cAC3B,CAAC,CAAC;YACN;UACJ,CAAC,CAAC;;UAEF;AACZ;AACA;AACA;AACA;UACY,IAAI,CAACgE,gBAAgB,EAAE;YACnB,OAAOD,cAAc;UACzB;QACJ;;QAEA;AACR;AACA;AACA;AACA;QACQ,IAAMsB,aAAa,GAAGvH,SAAS,CAACsF,OAAO,CAAC;QACxCiC,aAAa,CAACC,QAAQ,GAAG,IAAI;QAC7B,IAAIC,UAAe;QACnB,IAAMC,WAAW,GAAG,IAAIpG,OAAO,CAAC,UAACqG,GAAG,EAAEC,GAAG,EAAK;UAE1C;AACZ;AACA;AACA;AACA;AACA;UACY,IAAMC,MAAmB,GAAG,IAAIC,GAAG,CAAC3B,IAAI,CAAC1E,GAAG,CAAC,UAAAsG,CAAC;YAAA,OAAIA,CAAC,CAACnG,GAAG;UAAA,EAAC,CAAC;UACzD,IAAIoG,gBAAgB,GAAG,CAAC;UACxB,IAAIC,UAAqC;UACzC,IAAMC,uBAAuB,GAAG,IAAI5G,OAAO,CAAS,UAAAqG,GAAG,EAAI;YACvDM,UAAU,GAAG,OAAKE,OAAO,CAAC;cACtBC,KAAK,EAAE,KAAK;cACZC,IAAI,EAAE,IAAI;cACVC,YAAY,EAAE;YAClB,CAAC,CAAC,CAACC,EAAE,CAAC,QAAQ,EAAE,UAACC,MAAW,EAAK;cAC7B,IAAMC,KAAa,GAAGD,MAAM,CAAC7G,EAAE;cAC/B,IAAIkG,MAAM,CAACa,GAAG,CAACD,KAAK,CAAC,EAAE;gBACnBZ,MAAM,UAAO,CAACY,KAAK,CAAC;gBACpB,IAAIT,gBAAgB,GAAGQ,MAAM,CAACG,GAAG,EAAE;kBAC/BX,gBAAgB,GAAGQ,MAAM,CAACG,GAAG;gBACjC;gBAEA,IAAId,MAAM,CAACe,IAAI,KAAK,CAAC,EAAE;kBAClBX,UAAU,CAASY,MAAM,EAAE;kBAC5BlB,GAAG,CAACK,gBAAgB,CAAC;gBACzB;cACJ;YACJ,CAAC,CAAQ;UACb,CAAC,CAAC;;UAGF;AACZ;AACA;AACA;AACA;AACA;UACY,IAAMc,qBAAqB,GAAG9I,SAAS,CAACuH,aAAa,CAAC;UACtD,OAAOuB,qBAAqB,CAAC3H,MAAM;UAEnCsG,UAAU,GAAGxC,WAAW,CAACS,IAAI,SAEzBS,IAAI,EACJ2C,qBAAqB,EACrB,UAACnD,GAAQ,EAAEC,MAAmD,EAAK;YAC/D,IAAID,GAAG,EAAE;cACLJ,QAAQ,GAAGA,QAAQ,CAACI,GAAG,CAAC,GAAGiC,GAAG,CAACjC,GAAG,CAAC;YACvC,CAAC,MAAM;cACH,OAAO;gBAAA,IAAa;kBAAA;oBAShBC,MAAM,CAACxC,OAAO,CAAC,UAAA2F,GAAG,EAAI;sBAClB9C,cAAc,CAACjD,IAAI,CAAC+F,GAAG,CAAC;oBAC5B,CAAC,CAAC;;oBAEF;AAC5B;AACA;AACA;AACA;oBAC4B,IAAIC,aAAa,GAAG5I,oBAAoB;oBACxC,IAAI,CAACkF,OAAO,CAACkC,QAAQ,EAAE;sBACnB,IAAMzE,OAAO,GAAG7C,GAAG,EAAE;sBACrB,IAAMc,QAAQ,GAAG;wBACbiI,MAAM,EAAEC,KAAK;wBACb1H,SAAS,EAAE2E,IAAI;wBACfjF,YAAY,EAAEoE,OAAO;wBACrBhC,WAAW,EAAE2C,cAAc;wBAC3BlE,YAAY,EAAE4E,gBAAgB;wBAC9B7D,SAAS,EAATA,SAAS;wBACTC,OAAO,EAAPA;sBACJ,CAAC;sBACDiG,aAAa,GAAGnI,4BAA4B,SAExC,KAAK,EACLG,QAAQ,CACX,CAAC8E,IAAI,CAAC,UAAAqD,MAAM,EAAI;wBACb,IAAMC,SAA0C,GAAG;0BAC/CzH,EAAE,EAAEtB,iBAAiB,CAAC,EAAE,CAAC;0BACzB8I,MAAM,EAANA,MAAM;0BACNE,UAAU,EAAE;4BACRC,QAAQ,EAAEtB;0BACd,CAAC;0BACDuB,OAAO,EAAEjE,OAAO,CAACnE,MAAM,GAAGmE,OAAO,CAACnE,MAAM,CAACoI,OAAO,GAAG;wBACvD,CAAC;wBAED,IAAM5E,OAAO,GAAGP,4BAA4B,QAAM;wBAClDO,OAAO,CAACC,OAAO,CAAC4E,IAAI,CAACJ,SAAS,CAAC;sBACnC,CAAC,CAAC;oBACN;oBAAC,IAEG7D,QAAQ;sBACRA,QAAQ,CAAC,IAAI,EAAEU,cAAc,CAAC;oBAAC;sBAE/B,OAAO+C,aAAa,CAAClD,IAAI,CAAC,YAAM;wBAC5B6B,GAAG,CAAC1B,cAAc,CAAC;wBACnB,OAAOA,cAAc;sBACzB,CAAC,CAAC;oBAAC;kBAAA;kBAtDP,IAAMwD,QAAQ,GAAG7D,MAAM,CAAC8D,IAAI,CAAC,UAAAX,GAAG;oBAAA,OAAKA,GAAG,CAAqBpF,KAAK;kBAAA,EAAC;kBACnE,IAAIqE,iBAAgB,GAAG,CAAC,CAAC;kBAAC;oBAAA,IACtB,CAACyB,QAAQ;sBAAA,uBACgBvB,uBAAuB;wBAAhDF,iBAAgB,wBAAgC;sBAAC;oBAAA;sBAEjDC,UAAU,CAACY,MAAM,EAAE;oBAAC;kBAAA;kBAAA;gBAmD5B,CAAC;kBAAA;gBAAA;cAAA,GAAG;YACR;UACJ,CAAC,CAAC;QACV,CAAC,CAAC;QAAC,OAECvD,OAAO,CAACnE,MAAM,GACPuG,WAAW,GAKfD,UAAU;MAAA;MAAA,aAhQY,IAAI;MAhDjC,IAAM3E,SAAS,GAAG5C,GAAG,EAAE;MACvB,IAAMgJ,KAAK,GAAGrE,CAAC,EAAE;;MAEjB;AACR;AACA;AACA;MACQ,IAAI,OAAOS,OAAO,KAAK,UAAU,EAAE;QAC/BC,QAAQ,GAAGD,OAAO;QAClBA,OAAO,GAAG,CAAC,CAAC;MAChB;MACA,IAAI,CAACA,OAAO,EAAE;QACVA,OAAO,GAAG,CAAC,CAAC;MAChB;MAEA,IAAIa,IAAW;MACf,IAAIE,KAAK,CAACsD,OAAO,CAACtE,IAAI,CAAC,EAAE;QACrBc,IAAI,GAAGd,IAAI;MACf,CAAC,MAAM,IAAIA,IAAI,KAAKuE,SAAS,EAAE;QAC3BzD,IAAI,GAAG,EAAE;MACb,CAAC,MAAM;QACHA,IAAI,GAAGd,IAAI,CAACc,IAAI;QAChB,IAAId,IAAI,CAACjE,cAAc,CAAC,WAAW,CAAC,EAAE;UAClCkE,OAAO,CAACjE,SAAS,GAAGgE,IAAI,CAAChE,SAAS;QACtC;MACJ;;MAEA;MACA,IAAI8E,IAAI,CAAC0D,MAAM,KAAK,CAAC,EAAE;QACnB,MAAMvJ,UAAU,CAAC,KAAK,EAAE;UACpBqC,IAAI,EAAE;YACF0C,IAAI,EAAJA,IAAI;YACJC,OAAO,EAAPA;UACJ;QACJ,CAAC,CAAC;MACN;;MAGA;AACR;AACA;AACA;AACA;MACQ,IAAMqB,gBAAkD,GAAGrB,OAAO,CAACnE,MAAM,GAAGmE,OAAO,CAACnE,MAAM,CAACwF,gBAAgB,GAAG,IAAIxD,GAAG,EAAE;MAAC;QAAA,IAEpHmC,OAAO,CAAClE,cAAc,CAAC,WAAW,CAAC,IACnCkE,OAAO,CAACjE,SAAS,KAAK,KAAK;UAAA,uBAEF,OAAKyI,OAAO,CAAC;YAClC3D,IAAI,EAAEA,IAAI,CAAC1E,GAAG,CAAC,UAAAgB,GAAG;cAAA,OAAK;gBAAEd,EAAE,EAAEc,GAAG,CAACb;cAAI,CAAC;YAAA,CAAC,CAAC;YACxCmI,IAAI,EAAE,IAAI;YACVC,MAAM,EAAE;UACZ,CAAC,CAAC,iBAJIC,UAAU;YAMhB;AACZ;AACA;AACA;YACY,IAAMC,yBAAmC,GAAG,EAAE;YAE9CD,UAAU,CAACE,OAAO,CAAC/G,OAAO,CAAC,UAAAG,SAAS,EAAI;cACpC,IAAM6G,QAAQ,GAAG7G,SAAS,CAAC4C,IAAI,CAAC,CAAC,CAAC;cAClC,IAAIiE,QAAQ,CAAC9C,EAAE,EAAE;gBACbX,gBAAgB,CAACtD,GAAG,CAAC+G,QAAQ,CAAC9C,EAAE,CAAC1F,GAAG,EAAEwI,QAAQ,CAAC9C,EAAE,CAAC;cACtD,CAAC,MAAM;gBACH,IAAI8C,QAAQ,CAACzG,KAAK,IAAIyG,QAAQ,CAACzG,KAAK,CAAC0G,MAAM,KAAK,SAAS,EAAE;kBACvDH,yBAAyB,CAAClH,IAAI,CAACO,SAAS,CAAC5B,EAAE,CAAC;gBAChD;cACJ;YACJ,CAAC,CAAC;YAAC;cAAA,IAECuI,yBAAyB,CAACL,MAAM,GAAG,CAAC;gBAAA,uBACA,OAAKS,OAAO,CAAC;kBAC7CC,IAAI,EAAEL,yBAAyB;kBAC/B5B,YAAY,EAAE,IAAI;kBAClBkC,SAAS,EAAE;gBACf,CAAC,CAAC,iBAJIC,qBAAqB;kBAM3B,IAAMC,WAA2C,GAAG,EAAE;kBACtDD,qBAAqB,CAACE,IAAI,CAACvH,OAAO,CAAC,UAAA2F,GAAG,EAAI;oBACtC2B,WAAW,CAAC1H,IAAI,CAAC;sBACbrB,EAAE,EAAEoH,GAAG,CAACpH,EAAE;sBACV8B,GAAG,EAAEsF,GAAG,CAAC6B,KAAK,CAACnH;oBACnB,CAAC,CAAC;kBACN,CAAC,CAAC;kBAAC,uBAEwC,OAAKqG,OAAO,CAAC;oBACpD3D,IAAI,EAAEuE,WAAW;oBACjBX,IAAI,EAAE,IAAI;oBACVC,MAAM,EAAE;kBACZ,CAAC,CAAC,iBAJIa,4BAA4B;oBAMlCA,4BAA4B,CAACV,OAAO,CAAC/G,OAAO,CAAC,UAAAG,SAAS,EAAI;sBACtD,IAAM6G,QAAQ,GAAG7G,SAAS,CAAC4C,IAAI,CAAC,CAAC,CAAC;sBAClC,IAAIiE,QAAQ,CAAC9C,EAAE,EAAE;wBACbX,gBAAgB,CAACtD,GAAG,CAAC+G,QAAQ,CAAC9C,EAAE,CAAC1F,GAAG,EAAEwI,QAAQ,CAAC9C,EAAE,CAAC;sBACtD,CAAC,MAAM;wBACH,MAAMhH,UAAU,CAAC,KAAK,EAAE;0BACpBqC,IAAI,EAAE;4BACFkI,4BAA4B,EAA5BA,4BAA4B;4BAC5BtH,SAAS,EAATA;0BACJ;wBACJ,CAAC,CAAC;sBACN;oBACJ,CAAC,CAAC;kBAAC;gBAAA;cAAA;YAAA;YAAA;UAAA;QAAA;MAAA;MAAA;IAyMf,CAAC;MAAA;IAAA;EAAA;EAED1D,WAAW,CAACiL,MAAM,CAAC;IACf3F,QAAQ,EAAEC;EACd,CAAC,CAAQ;AAEb;AAuOA,OAAO,SAASvC,mBAAmB,CAC/B/B,eAAgC,EAChCC,WAAmB,EACnByH,MAA8C,EAC9C1F,SAAkB,EAClBC,OAAgB,EAC+B;EAC/C,IAAMN,GAA8B,GAAG+F,MAAM,CAAChG,SAAS,KAAK,QAAQ,GAAGgG,MAAM,CAAC9F,QAAQ,GAAU8F,MAAM,CAAC/F,GAAU;EACjH,IAAMsI,OAAe,GAAItI,GAAG,CAAS1B,WAAW,CAAC;EACjD,IAAMiK,kBAAmE,GAAG;IACxEC,OAAO,EAAE1K,WAAW,CAACO,eAAe,EAAEiK,OAAO,EAAEvC,MAAM,CAAC;IACtD0C,UAAU,EAAEH,OAAO;IACnBI,YAAY,EAAE3C,MAAM,CAAC/F,GAAU;IAC/B2I,oBAAoB,EAAE5C,MAAM,CAAC9F,QAAe;IAC5CF,SAAS,EAAEgG,MAAM,CAAChG,SAAS;IAC3BM,SAAS,EAATA,SAAS;IACTC,OAAO,EAAPA;EACJ,CAAC;EACD,OAAOiI,kBAAkB;AAC7B"}