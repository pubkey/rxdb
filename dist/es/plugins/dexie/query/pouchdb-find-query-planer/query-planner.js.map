{"version":3,"file":"query-planner.js","names":["getUserFields","getKey","compare","arrayEquals","arrayToObject","flatten","max","mergeObjects","oneArrayIsStrictSubArrayOfOther","oneArrayIsSubArrayOfOther","oneSetIsSubArrayOfOther","uniq","COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","limit","startkey","endkey","inMemoryFields","checkFieldInIndex","index","field","indexFields","def","fields","map","i","len","length","indexField","userOperatorLosesPrecision","selector","matcher","userOperator","sortFieldsByIndex","userFields","slice","sort","a","b","aIdx","indexOf","bIdx","Number","MAX_VALUE","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","Object","keys","forEach","operator","push","getInMemoryFields","coreInMemoryFields","result","checkIndexFieldsMatch","sortOrder","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexes","filter","findBestMatchingIndex","useIndex","matchingIndexes","Error","JSON","stringify","error","message","defaultIndex","defaultUsed","userFieldsMap","scoreIndex","score","useIndexDdoc","useIndexName","find","ddoc","name","getSingleFieldQueryOptsFor","userValue","key","inclusive_end","inclusive_start","getSingleFieldCoreQueryPlan","userOperators","combinedOpts","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","some","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","j","newOpts","res","shouldShortCircuit","values","val","getDefaultQueryPlan","_idx","getCoreQueryPlan","planQuery","request","assign","userFieldsRes","use_index","coreQueryPlan"],"sources":["../../../../../../src/plugins/dexie/query/pouchdb-find-query-planer/query-planner.ts"],"sourcesContent":["import {\n    getUserFields\n} from './utils';\nimport {\n    getKey,\n    compare\n} from 'pouchdb-selector-core';\nimport {\n    arrayEquals,\n    arrayToObject,\n    flatten,\n    max,\n    mergeObjects,\n    oneArrayIsStrictSubArrayOfOther,\n    oneArrayIsSubArrayOfOther,\n    oneSetIsSubArrayOfOther,\n    uniq\n} from './main-utils';\n\n// couchdb lowest collation value\nconst COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\n// const COLLATE_HI = { '\\uffff': {} };\n// overwritten COLLATE_HI for dexie.js RxStorage.\nconst COLLATE_HI = '\\uffff';\n\n\nconst SHORT_CIRCUIT_QUERY = {\n    queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n    inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index: any, field: string) {\n    const indexFields = index.def.fields.map(getKey);\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n        if (field === indexField) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector: any, field: string) {\n    const matcher = selector[field];\n    const userOperator = getKey(matcher);\n\n    return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields: any[], index: any) {\n    const indexFields = index.def.fields.map(getKey);\n\n    return userFields.slice().sort(function (a, b) {\n        let aIdx = indexFields.indexOf(a);\n        let bIdx = indexFields.indexOf(b);\n        if (aIdx === -1) {\n            aIdx = Number.MAX_VALUE;\n        }\n        if (bIdx === -1) {\n            bIdx = Number.MAX_VALUE;\n        }\n        return compare(aIdx, bIdx);\n    });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index: any, selector: any, userFields: any) {\n\n    userFields = sortFieldsByIndex(userFields, index);\n\n    // check if any of the user selectors lose precision\n    let needToFilterInMemory = false;\n    for (let i = 0, len = userFields.length; i < len; i++) {\n        const field = userFields[i];\n        if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n            return userFields.slice(i);\n        }\n        if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n            needToFilterInMemory = true;\n        }\n    }\n    return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector: any) {\n    const fields: any[] = [];\n    Object.keys(selector).forEach(function (field) {\n        const matcher = selector[field];\n        Object.keys(matcher).forEach(function (operator) {\n            if (operator === '$ne') {\n                fields.push(field);\n            }\n        });\n    });\n    return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields: any, index: any, selector: any, userFields: any) {\n    const result = (flatten as any)(\n        // in-memory fields reported as necessary by the query planner\n        coreInMemoryFields,\n        // combine with another pass that checks for any we may have missed\n        getBasicInMemoryFields(index, selector, userFields),\n        // combine with another pass that checks for $ne's\n        getInMemoryFieldsFromNe(selector)\n    );\n\n    return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields: any, sortOrder: any, fields: any) {\n    if (sortOrder) {\n        // array has to be a strict subarray of index array. furthermore,\n        // the sortOrder fields need to all be represented in the index\n        const sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n        const selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n        return sortMatches && selectorMatches;\n    }\n\n    // all of the user's specified fields still need to be\n    // on the left side of the index array, although the order\n    // doesn't matter\n    return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nconst logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher: any) {\n    return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields: any, selector: any) {\n    const firstField = indexFields[0];\n    const matcher = selector[firstField];\n\n    if (typeof matcher === 'undefined') {\n        /* istanbul ignore next */\n        return true;\n    }\n\n    const isInvalidNe = Object.keys(matcher).length === 1 &&\n        getKey(matcher) === '$ne';\n\n    return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index: any, sortOrder: any, fields: any, selector: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    const fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n    if (!fieldsMatch) {\n        return false;\n    }\n\n    return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector: any, userFields: any, sortOrder: any, indexes: any) {\n    return indexes.filter(function (index: any) {\n        return checkIndexMatches(index, sortOrder, userFields, selector);\n    });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector: any, userFields: any, sortOrder: any, indexes: any, useIndex: string) {\n\n    const matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n    if (matchingIndexes.length === 0) {\n        if (useIndex) {\n            throw new Error(JSON.stringify({\n                error: 'no_usable_index',\n                message: 'There is no index available for this selector.',\n                selector,\n                indexes,\n                sortOrder,\n                userFields,\n                useIndex\n            }, null, 4));\n        }\n        //return `all_docs` as a default index;\n        //I'm assuming that _all_docs is always first\n        const defaultIndex = indexes[0];\n        defaultIndex.defaultUsed = true;\n        return defaultIndex;\n    }\n    if (matchingIndexes.length === 1 && !useIndex) {\n        return matchingIndexes[0];\n    }\n\n    const userFieldsMap = arrayToObject(userFields);\n\n    function scoreIndex(index: any) {\n        const indexFields = index.def.fields.map(getKey);\n        let score = 0;\n        for (let i = 0, len = indexFields.length; i < len; i++) {\n            const indexField = indexFields[i];\n            if (userFieldsMap[indexField]) {\n                score++;\n            }\n        }\n        return score;\n    }\n\n    if (useIndex) {\n        const useIndexDdoc = '_design/' + useIndex;\n        const useIndexName = useIndex;\n        const index = matchingIndexes.find(function (index: any) {\n            if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n                return true;\n            }\n\n            if (index.ddoc === useIndexDdoc) {\n                /* istanbul ignore next */\n                return true;\n            }\n\n            return false;\n        });\n\n        if (!index) {\n            throw new Error(JSON.stringify({\n                error: 'unknown_error',\n                message: 'Could not find that index or could not use that index for the query',\n                useIndex,\n                indexes,\n                selector\n            }, null, 4));\n        }\n        return index;\n    }\n\n    return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return { key: userValue };\n        case '$lte':\n            return { endkey: userValue };\n        case '$gte':\n            return { startkey: userValue };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n\n    return {\n        startkey: COLLATE_LO\n    };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector: any, index: any) {\n    const field = getKey(index.def.fields[0]);\n    //ignoring this because the test to exercise the branch is skipped at the moment\n    /* istanbul ignore next */\n    const matcher = selector[field] || {};\n    const inMemoryFields: any[] = [];\n\n    const userOperators = Object.keys(matcher);\n\n    let combinedOpts: any;\n\n    userOperators.forEach(function (userOperator) {\n\n        if (isNonLogicalMatcher(userOperator)) {\n            inMemoryFields.push(field);\n        }\n\n        const userValue = matcher[userOperator];\n\n        const newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n        if (combinedOpts) {\n            combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n        } else {\n            combinedOpts = newQueryOpts;\n        }\n    });\n\n    return {\n        queryOpts: combinedOpts,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator: any, userValue: any) {\n    switch (userOperator) {\n        case '$eq':\n            return {\n                startkey: userValue,\n                endkey: userValue\n            };\n        case '$lte':\n            return {\n                endkey: userValue\n            };\n        case '$gte':\n            return {\n                startkey: userValue\n            };\n        case '$lt':\n            return {\n                endkey: userValue,\n                inclusive_end: false\n            };\n        case '$gt':\n            return {\n                startkey: userValue,\n                inclusive_start: false\n            };\n    }\n}\n\nfunction getMultiFieldQueryOpts(selector: any, index: any) {\n\n    const indexFields = index.def.fields.map(getKey);\n\n    let inMemoryFields: any[] = [];\n    const startkey = [];\n    const endkey = [];\n    let inclusiveStart: any;\n    let inclusiveEnd: any;\n\n\n    function finish(i: any) {\n\n        if (inclusiveStart !== false) {\n            startkey.push(COLLATE_LO);\n        }\n        if (inclusiveEnd !== false) {\n            endkey.push(COLLATE_HI);\n        }\n        // keep track of the fields where we lost specificity,\n        // and therefore need to filter in-memory\n        inMemoryFields = indexFields.slice(i);\n    }\n\n    for (let i = 0, len = indexFields.length; i < len; i++) {\n        const indexField = indexFields[i];\n\n        const matcher = selector[indexField];\n\n        if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n            finish(i);\n            break;\n        } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n            finish(i);\n            break;\n        } else if (i > 0) {\n            const usingGtlt = (\n                '$gt' in matcher || '$gte' in matcher ||\n                '$lt' in matcher || '$lte' in matcher);\n            const previousKeys = Object.keys(selector[indexFields[i - 1]]);\n            const previousWasEq = arrayEquals(previousKeys, ['$eq']);\n            const previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n            const gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n            if (gtltLostSpecificity) {\n                finish(i);\n                break;\n            }\n        }\n\n        const userOperators = Object.keys(matcher);\n\n        let combinedOpts: any = null;\n\n        for (let j = 0; j < userOperators.length; j++) {\n            const userOperator = userOperators[j];\n            const userValue = matcher[userOperator];\n\n            const newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n            if (combinedOpts) {\n                combinedOpts = mergeObjects([combinedOpts, newOpts]);\n            } else {\n                combinedOpts = newOpts;\n            }\n        }\n\n        startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n        endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n        if ('inclusive_start' in combinedOpts) {\n            inclusiveStart = combinedOpts.inclusive_start;\n        }\n        if ('inclusive_end' in combinedOpts) {\n            inclusiveEnd = combinedOpts.inclusive_end;\n        }\n    }\n\n    const res: any = {\n        startkey: startkey,\n        endkey: endkey\n    };\n\n    if (typeof inclusiveStart !== 'undefined') {\n        res.inclusive_start = inclusiveStart;\n    }\n    if (typeof inclusiveEnd !== 'undefined') {\n        res.inclusive_end = inclusiveEnd;\n    }\n\n    return {\n        queryOpts: res,\n        inMemoryFields: inMemoryFields\n    };\n}\n\nfunction shouldShortCircuit(selector: any) {\n    // We have a field to select from, but not a valid value\n    // this should result in a short circuited query \n    // just like the http adapter (couchdb) and mongodb\n    // see tests for issue #7810\n\n    const values = Object.values(selector);\n    return values.some(function (val: any) {\n        return typeof val === 'object' && Object.keys(val).length === 0;\n    });\n}\n\nfunction getDefaultQueryPlan(selector: any, _idx?: any) {\n    //using default index, so all fields need to be done in memory\n    return {\n        queryOpts: { startkey: null },\n        inMemoryFields: [Object.keys(selector)]\n    };\n}\n\nfunction getCoreQueryPlan(selector: any, index: any) {\n    if (index.defaultUsed) {\n        return getDefaultQueryPlan(selector, index);\n    }\n\n    if (index.def.fields.length === 1) {\n        // one field in index, so the value was indexed as a singleton\n        return getSingleFieldCoreQueryPlan(selector, index);\n    }\n    // else index has multiple fields, so the value was indexed as an array\n    return getMultiFieldQueryOpts(selector, index);\n}\n\nexport function planQuery(request: any, indexes: any) {\n\n    const selector = request.selector;\n    const sort = request.sort;\n\n    if (shouldShortCircuit(selector)) {\n        return Object.assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n    }\n\n    const userFieldsRes = getUserFields(selector, sort);\n\n    const userFields = userFieldsRes.fields;\n    const sortOrder = userFieldsRes.sortOrder;\n    const index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n    const coreQueryPlan = getCoreQueryPlan(selector, index);\n    const queryOpts = coreQueryPlan.queryOpts;\n    const coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n    const inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n    const res = {\n        queryOpts: queryOpts,\n        index: index,\n        inMemoryFields: inMemoryFields\n    };\n    return res;\n}\n"],"mappings":"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"}