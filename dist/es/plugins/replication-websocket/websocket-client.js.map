{"version":3,"file":"websocket-client.js","names":["replicateRxCollection","ReconnectingWebSocket","IsomorphicWebSocket","getFromMapOrThrow","randomCouchString","filter","map","Subject","firstValueFrom","BehaviorSubject","newRxError","ensureIsWebsocket","w","is","CLOSING","console","dir","Error","replicateWithWebsocketServer","options","getWebSocket","url","collection","database","socketState","wsClient","socket","messages$","message$","requestCounter","getRequestId","count","token","requestFlag","replicationState","replicationIdentifier","pull","batchSize","stream$","pipe","msg","id","name","result","handler","lastPulledCheckpoint","requestId","request","method","params","send","JSON","stringify","push","docs","error$","subscribe","err","subjects","error","next","connected$","isConnected","reSync","streamRequest","onDestroy","removeWebSocketRef","cacheKey","has","WEBSOCKET_BY_CACHE_KEY","get","WebSocket","openPromise","Promise","res","onopen","onclose","onmessage","messageObj","message","parse","data","onerror","emitError","errors","Array","isArray","direction","refCount","set","Map","obj","complete","close"],"sources":["../../../../src/plugins/replication-websocket/websocket-client.ts"],"sourcesContent":["import { replicateRxCollection, RxReplicationState } from '../replication';\nimport {\n    WebsocketClientOptions,\n    WebsocketMessageResponseType,\n    WebsocketMessageType\n} from './websocket-types';\n\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport IsomorphicWebSocket from 'isomorphic-ws';\nimport {\n    getFromMapOrThrow,\n    randomCouchString\n} from '../../util';\nimport {\n    filter,\n    map,\n    Subject,\n    firstValueFrom,\n    BehaviorSubject\n} from 'rxjs';\nimport {\n    RxDatabase,\n    RxError,\n    RxReplicationWriteToMasterRow\n} from '../../types';\nimport { newRxError } from '../../rx-error';\n\nexport type WebsocketWithRefCount = {\n    url: string;\n    socket: ReconnectingWebSocket;\n    refCount: number;\n    openPromise: Promise<void>;\n    connected$: BehaviorSubject<boolean>;\n    message$: Subject<WebsocketMessageResponseType>;\n    error$: Subject<RxError>\n};\n\n\n/**\n * Copied and adapter from the 'reconnecting-websocket' npm module.\n * Some bundlers have problems with bundling the isomorphic-ws plugin\n * so we directly check the correctness in RxDB to ensure that we can\n * throw a helpful error.\n */\nfunction ensureIsWebsocket(w: typeof IsomorphicWebSocket) {\n    const is = typeof w !== 'undefined' && !!w && w.CLOSING === 2;\n    if (!is) {\n        console.dir(w);\n        throw new Error('websocket not valid');\n    }\n}\n\n/**\n * Reuse the same socket even when multiple\n * collection replicate with the same server at once.\n */\nexport const WEBSOCKET_BY_CACHE_KEY: Map<string, WebsocketWithRefCount> = new Map();\nexport async function getWebSocket(\n    url: string,\n    database: RxDatabase<any, any, any>\n): Promise<WebsocketWithRefCount> {\n    /**\n     * Also use the database token as cache-key\n     * to make it easier to test and debug\n     * multi-instance setups.\n     */\n    const cacheKey = url + '|||' + database.token;\n\n    let has = WEBSOCKET_BY_CACHE_KEY.get(cacheKey);\n    if (!has) {\n        ensureIsWebsocket(IsomorphicWebSocket);\n        const wsClient = new ReconnectingWebSocket(\n            url,\n            [],\n            {\n                WebSocket: IsomorphicWebSocket\n            }\n        );\n\n        const connected$ = new BehaviorSubject<boolean>(false);\n        const openPromise = new Promise<void>(res => {\n            wsClient.onopen = () => {\n                connected$.next(true);\n                res();\n            };\n        });\n        wsClient.onclose = () => {\n            connected$.next(false);\n        };\n\n        const message$ = new Subject<WebsocketMessageResponseType>();\n        wsClient.onmessage = (messageObj) => {\n            const message: WebsocketMessageResponseType = JSON.parse(messageObj.data);\n            message$.next(message);\n        };\n\n        const error$ = new Subject<any>();\n        wsClient.onerror = (err) => {\n            const emitError = newRxError('RC_STREAM', {\n                errors: Array.isArray(err) ? err as any : [err],\n                direction: 'pull'\n            });\n            error$.next(emitError);\n        }\n\n\n        has = {\n            url,\n            socket: wsClient,\n            openPromise,\n            refCount: 1,\n            connected$,\n            message$,\n            error$\n        };\n        WEBSOCKET_BY_CACHE_KEY.set(cacheKey, has);\n    } else {\n        has.refCount = has.refCount + 1;\n    }\n\n\n    await has.openPromise;\n    return has;\n}\n\nexport function removeWebSocketRef(\n    url: string,\n    database: RxDatabase\n) {\n    const cacheKey = url + '|||' + database.token;\n    const obj = getFromMapOrThrow(WEBSOCKET_BY_CACHE_KEY, cacheKey);\n    obj.refCount = obj.refCount - 1;\n    if (obj.refCount === 0) {\n        WEBSOCKET_BY_CACHE_KEY.delete(cacheKey);\n        obj.connected$.complete();\n        obj.socket.close();\n    }\n}\n\n\n\nexport async function replicateWithWebsocketServer<RxDocType, CheckpointType>(\n    options: WebsocketClientOptions<RxDocType>\n): Promise<RxReplicationState<RxDocType, CheckpointType>> {\n    const socketState = await getWebSocket(options.url, options.collection.database);\n    const wsClient = socketState.socket;\n\n    const messages$ = socketState.message$;\n\n    let requestCounter = 0;\n    const requestFlag = randomCouchString(10);\n    function getRequestId() {\n        const count = requestCounter++;\n        return options.collection.database.token + '|' + requestFlag + '|' + count;\n    }\n    const replicationState = replicateRxCollection<RxDocType, CheckpointType>({\n        collection: options.collection,\n        replicationIdentifier: 'websocket-' + options.url,\n        pull: {\n            batchSize: options.batchSize,\n            stream$: messages$.pipe(\n                filter(msg => msg.id === 'stream' && msg.collection === options.collection.name),\n                map(msg => msg.result)\n            ),\n            async handler(lastPulledCheckpoint: CheckpointType, batchSize: number) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterChangesSince',\n                    params: [lastPulledCheckpoint, batchSize]\n                }\n                wsClient.send(JSON.stringify(request));\n                const result = await firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n                return result;\n            }\n        },\n        push: {\n            batchSize: options.batchSize,\n            handler(docs: RxReplicationWriteToMasterRow<RxDocType>[]) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterWrite',\n                    params: [docs]\n                }\n                wsClient.send(JSON.stringify(request));\n                return firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n            }\n        }\n    });\n\n    socketState.error$.subscribe(err => replicationState.subjects.error.next(err));\n\n    socketState.connected$.subscribe(isConnected => {\n        if (isConnected) {\n            /**\n             * When the client goes offline and online again,\n             * we have to send a 'RESYNC' signal because the client\n             * might have missed out events while being offline.\n             */\n            replicationState.reSync();\n\n            /**\n             * Because reconnecting creates a new websocket-instance,\n             * we have to start the changestream from the remote again\n             * each time.\n             */\n            const streamRequest: WebsocketMessageType = {\n                id: 'stream',\n                collection: options.collection.name,\n                method: 'masterChangeStream$',\n                params: []\n            }\n            wsClient.send(JSON.stringify(streamRequest));\n        }\n    });\n\n    options.collection.onDestroy.push(() => removeWebSocketRef(options.url, options.collection.database));\n    return replicationState;\n}\n"],"mappings":"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"}