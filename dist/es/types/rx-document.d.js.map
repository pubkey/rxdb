{"version":3,"file":"rx-document.d.js","names":[],"sources":["../../../src/types/rx-document.d.ts"],"sourcesContent":["import {\n    Observable,\n    BehaviorSubject\n} from 'rxjs';\n\nimport {\n    RxCollection,\n} from './rx-collection';\nimport {\n    RxAttachment,\n    RxAttachmentCreator\n} from './rx-attachment';\nimport { RxDocumentData } from './rx-storage';\nimport { RxChangeEvent } from './rx-change-event';\nimport { DeepReadonly, PlainJsonValue } from './util';\n\nexport type RxDocument<RxDocumentType = {}, OrmMethods = {}> = RxDocumentBase<RxDocumentType, OrmMethods> & RxDocumentType & OrmMethods;\n\ndeclare type AtomicUpdateFunction<RxDocumentType> = (\n    doc: RxDocumentData<RxDocumentType>,\n    rxDocument: RxDocument<RxDocumentType>\n) => RxDocumentType | Promise<RxDocumentType>;\n\n/**\n * Meta data that is attached to each document by RxDB.\n * TODO in the next major release,\n * we should move the other meta fields\n * _rev, _deleted, _attachments into this property.\n */\nexport type RxDocumentMeta = {\n    /**\n     * Last write time.\n     * Unix epoch in milliseconds.\n     */\n    lwt: number;\n\n    /**\n     * Any other value can be attached to the _meta data.\n     * Mostly done by plugins to mark documents.\n     */\n    [k: string]: PlainJsonValue;\n};\n\nexport declare interface RxDocumentBase<RxDocumentType, OrmMethods = {}> {\n    isInstanceOfRxDocument: true;\n    collection: RxCollection<RxDocumentType, OrmMethods>;\n    readonly deleted: boolean;\n\n    readonly $: Observable<DeepReadonly<any>>;\n    readonly deleted$: Observable<boolean>;\n\n    readonly primary: string;\n    readonly allAttachments$: Observable<RxAttachment<RxDocumentType, OrmMethods>[]>;\n\n    // internal things\n    _isTemporary: boolean;\n    _dataSync$: BehaviorSubject<DeepReadonly<RxDocumentType>>;\n    _data: RxDocumentData<RxDocumentType>;\n    _isDeleted$: BehaviorSubject<boolean>;\n    primaryPath: string;\n    revision: string;\n    _atomicQueue: Promise<any>;\n    $emit(cE: RxChangeEvent<RxDocumentType>): void;\n    _saveData(newData: any, oldData: any): Promise<void>;\n    // /internal things\n\n    get$(path: string): Observable<any>;\n    get(objPath: string): DeepReadonly<any>;\n    populate(objPath: string): Promise<RxDocument<RxDocumentType, OrmMethods> | any | null>;\n\n    /**\n     * mutate the document with a function\n     */\n    atomicUpdate(mutationFunction: AtomicUpdateFunction<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>>;\n    /**\n     * patches the given properties\n     */\n    atomicPatch(patch: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>>;\n\n    update(updateObj: any): Promise<any>;\n    remove(): Promise<boolean>;\n    _handleChangeEvent(cE: any): void;\n\n    // only for temporary documents\n    set(objPath: string, value: any): RxDocument<RxDocumentType, OrmMethods>;\n    save(): Promise<boolean>;\n\n    // attachments\n    putAttachment(\n        creator: RxAttachmentCreator,\n        /**\n         * If set to true and data is equal,\n         * operation will be skipped.\n         * This prevents us from upgrading the revision\n         * and causing events in the change stream.\n         * (default = true)\n         */\n        skipIfSame?: boolean\n    ): Promise<RxAttachment<RxDocumentType, OrmMethods>>;\n    getAttachment(id: string): RxAttachment<RxDocumentType, OrmMethods> | null;\n    allAttachments(): RxAttachment<RxDocumentType, OrmMethods>[];\n\n    toJSON(): DeepReadonly<RxDocumentType>;\n    toJSON(withRevAndAttachments: true): DeepReadonly<RxDocumentData<RxDocumentType>>;\n    toJSON(withRevAndAttachments: false): DeepReadonly<RxDocumentType>;\n\n    toMutableJSON(): RxDocumentType;\n    toMutableJSON(withRevAndAttachments: true): RxDocumentData<RxDocumentType>;\n    toMutableJSON(withRevAndAttachments: false): RxDocumentType;\n\n    destroy(): void;\n}\n"],"mappings":""}