{"version":3,"file":"rx-schema.d.js","names":[],"sources":["../../../src/types/rx-schema.d.ts"],"sourcesContent":["import { AsTyped } from 'as-typed';\nimport { CRDTSchemaOptions } from './plugins/crdt';\nimport { StringKeys } from './util';\n\n/**\n * @link https://github.com/types/lib-json-schema/blob/master/v4/index.d.ts\n */\nexport type JsonSchemaTypes = 'array' | 'boolean' | 'integer' | 'number' | 'null' | 'object' | 'string' | (string & {});\n\nexport type CompositePrimaryKey<RxDocType> = {\n    /**\n     * The top level field of the document that will be used\n     * to store the composite key as string.\n     */\n    key: StringKeys<RxDocType>;\n\n    /**\n     * The fields of the composite key,\n     * the fields must be required and final\n     * and have the type number, int, or string.\n     */\n    fields: (StringKeys<RxDocType> | string)[];\n    /**\n     * The separator which is used to concat the\n     * primary fields values.\n     * Choose a character as separator that is known\n     * to never appear inside of the primary fields values.\n     * I recommend to use the pipe char '|'.\n     */\n    separator: string;\n};\n\nexport type PrimaryKey<RxDocType> = StringKeys<RxDocType> | CompositePrimaryKey<RxDocType>;\n\nexport type JsonSchema<RxDocType = any> = {\n    allOf?: JsonSchema[];\n    anyOf?: JsonSchema[];\n    oneOf?: JsonSchema[];\n    additionalItems?: boolean | JsonSchema;\n    additionalProperties?: boolean | JsonSchema;\n    type?: JsonSchemaTypes | JsonSchemaTypes[];\n    description?: string;\n    dependencies?: {\n        [key: string]: JsonSchema | string[];\n    };\n    exclusiveMinimum?: boolean;\n    exclusiveMaximum?: boolean;\n    items?: JsonSchema | JsonSchema[];\n    multipleOf?: number;\n    maxProperties?: number;\n    maximum?: number;\n    minimum?: number;\n    maxLength?: number;\n    minLength?: number;\n    maxItems?: number;\n    minItems?: number;\n    minProperties?: number;\n    pattern?: string;\n    patternProperties?: {\n        [key: string]: JsonSchema;\n    };\n    properties?: {\n        [key in StringKeys<RxDocType>]: JsonSchema;\n    };\n    required?: string[];\n    uniqueItems?: boolean;\n    enum?: any[];\n    not?: JsonSchema;\n    definitions?: {\n        [key: string]: JsonSchema;\n    };\n    format?: 'date-time' | 'email' | 'hostname' | 'ipv4' | 'ipv6' | 'uri' | string;\n\n    // RxDB-specific\n    ref?: string;\n    final?: boolean;\n}\n\nexport interface TopLevelProperty extends JsonSchema {\n    default?: any;\n}\n\nexport type RxJsonSchema<\n    /**\n     * The doctype must be given, and '=any' cannot be used,\n     * otherwise the keyof of primaryKey\n     * would be optional when the type of the document is not known.\n     */\n    RxDocType\n> = {\n    title?: string;\n    description?: string;\n    version: number;\n\n    /**\n     * The primary key of the documents.\n     * Must be in the top level of the properties of the schema\n     * and that property must have the type 'string'\n     */\n    primaryKey: PrimaryKey<RxDocType>;\n\n    /**\n     * TODO this looks like a typescript-bug\n     * we have to allows all string because the 'object'-literal is not recognized\n     * retry this in later typescript-versions\n     */\n    type: 'object' | string;\n    properties: { [key in StringKeys<RxDocType>]: TopLevelProperty };\n\n    /**\n     * On the top level the required-array must be set\n     * because we always have to set the primary key to required.\n     * \n     * TODO required should be made non-optional on the top level\n     */\n    required?: StringKeys<RxDocType>[] | readonly StringKeys<RxDocType>[];\n\n\n    indexes?: (string | string[])[] | (string | readonly string[])[] | readonly (string | string[])[] | readonly (string | readonly string[])[];\n    encrypted?: string[];\n    keyCompression?: boolean;\n    /**\n     * if not set, rxdb will set 'false' as default\n     * Having additionalProperties: true is not allwed on the root level to ensure\n     * that property names do not clash with properties of the RxDocument class\n     * or ORM methods.\n     */\n    additionalProperties?: false;\n    attachments?: {\n        encrypted?: boolean;\n    };\n    /**\n     * Options for the sharding plugin of rxdb-premium.\n     * We set these on the schema because changing the shard amount or mode\n     * will require a migration.\n     * @link https://rxdb.info/rx-storage-sharding.html\n     */\n    sharding?: {\n        /**\n         * Amount of shards. \n         * This value cannot be changed after you have stored data,\n         * if you change it anyway, you will loose the existing data.\n         */\n        shards: number;\n        /**\n         * Either shard by collection or by database.\n         * For most use cases (IndexedDB based storages), sharding by collection is the way to go\n         * because it has a faster initial load time.\n         */\n        mode: 'database' | 'collection';\n    }\n    crdt?: CRDTSchemaOptions<RxDocType>;\n}\n\n/**\n * Used to aggregate the document type from the schema.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport type ExtractDocumentTypeFromTypedRxJsonSchema<TypedRxJsonSchema> = AsTyped<TypedRxJsonSchema>;\n"],"mappings":""}