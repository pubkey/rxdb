{"version":3,"file":"replication-protocol.d.js","names":[],"sources":["../../../src/types/replication-protocol.d.ts"],"sourcesContent":["import { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { RxConflictHandler, RxConflictHandlerInput, RxConflictHandlerOutput } from './conflict-handling';\nimport { RxError, RxTypeError } from './rx-error';\nimport { BulkWriteRow, RxDocumentData, WithDeleted } from './rx-storage';\nimport type {\n    RxStorageInstance\n} from './rx-storage.interface';\nimport { HashFunction } from './util';\n\nexport type RxStorageReplicationMeta = {\n\n    /**\n     * Combined primary key consisting\n     * of: [replicationId, itemId, isCheckpoint]\n     * so that the same RxStorageInstance\n     * can be used for multiple replication states.\n     */\n    id: string;\n\n    /**\n     * Either the document primaryKey\n     * or the id of the replication checkpoint.\n     */\n    itemId: string;\n\n    /**\n     * input.identifier of the replication state,\n     * used to not mix up different data\n     * when the instance is used in more then one replication.\n     */\n    replicationIdentifier: string;\n\n    /**\n     * True if the doc data is about a checkpoint,\n     * False if it is about a document state from the master.\n     * Stored as a string so it can be used\n     * in the combined primary key 'id'\n     */\n    isCheckpoint: '0' | '1';\n\n    /**\n     * Either the document state of the master\n     * or the checkpoint data.\n     */\n    data: any;\n    /**\n     * If the current assumed master was written while\n     * resolving a conflict, this field contains\n     * the revision of the conflict-solution that\n     * is stored in the forkInstance.\n     */\n    isResolvedConflict?: string;\n};\n\nexport type RxReplicationWriteToMasterRow<RxDocType> = {\n    assumedMasterState?: WithDeleted<RxDocType>;\n    newDocumentState: WithDeleted<RxDocType>;\n};\n\n\nexport type DocumentsWithCheckpoint<RxDocType, CheckpointType> = {\n    documents: WithDeleted<RxDocType>[];\n    checkpoint: CheckpointType;\n}\n\n\nexport type RxReplicationPullStreamItem<RxDocType, MasterCheckpointType> = DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> |\n    /**\n     * Emit this when the masterChangeStream$ might have missed out\n     * some events because the fork lost the connection to the master.\n     * Like when the user went offline and reconnects.\n     */\n    'RESYNC';\n\n/**\n * The replication handler contains all logic\n * that is required by the replication protocol\n * to interact with the master instance.\n * This is an abstraction so that we can use different\n * handlers for GraphQL, REST or any other transportation layer.\n * Even a RxStorageInstance can be wrapped in a way to represend a replication handler.\n * \n * The RxStorage instance of the master branch that is\n * replicated with the fork branch.\n * The replication algorithm is made to make\n * as less writes on the master as possible.\n * The master instance is always 'the truth' which\n * does never contain conflicting document states.\n * All conflicts are handled on the fork branch\n * before being replicated to the master.\n */\nexport type RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n    masterChangeStream$: Observable<RxReplicationPullStreamItem<RxDocType, MasterCheckpointType>>;\n    masterChangesSince(\n        checkpoint: MasterCheckpointType,\n        batchSize: number\n    ): Promise<DocumentsWithCheckpoint<RxDocType, MasterCheckpointType>>;\n    /**\n     * Writes the fork changes to the master.\n     * Only returns the conflicts if there are any.\n     * (otherwise returns an empty array.)\n     */\n    masterWrite(\n        rows: RxReplicationWriteToMasterRow<RxDocType>[]\n    ): Promise<WithDeleted<RxDocType>[]>;\n};\n\nexport type RxStorageInstanceReplicationInput<RxDocType> = {\n    /**\n     * A string that uniquely identifies\n     * the replication.\n     * Ensures that checkpoint are not\n     * mixed with other replications.\n     */\n    identifier: string;\n    pullBatchSize: number;\n    pushBatchSize: number;\n    replicationHandler: RxReplicationHandler<RxDocType, any>;\n    conflictHandler: RxConflictHandler<RxDocType>;\n\n    /**\n     * The fork is the one that contains the forked chain of document writes.\n     * All conflicts are solved on the fork and only resolved correct document data\n     * is written back to the parent.\n     */\n    forkInstance: RxStorageInstance<RxDocType, any, any>;\n\n    /**\n     * The replication needs to store some meta data\n     * for documents to know which state is at the master\n     * and how/if it diverges from the fork.\n     * In the past this was stored in the _meta field of\n     * the forkInstance documents but that was not a good design decision\n     * because it required additional writes on the forkInstance\n     * to know which documents have been upstream replicated\n     * to not cause conflicts.\n     * Using the metaInstance instead leads to better overall performance\n     * because RxDB will not re-emit query results or document state\n     * when replication meta data is written.\n     * \n     * In addition to per-document meta data,\n     * the replication checkpoints are also stored in this instance.\n     * \n     */\n    metaInstance: RxStorageInstance<RxStorageReplicationMeta, any, any>;\n\n    /**\n     * When a write happens to the fork,\n     * normally the replication will directly try to persist.\n     * \n     * For many use cases, it is better to await the next event loop tick\n     * or to wait until the RxDatabase is idle or requestIdleCallback() calls\n     * to ensure the CPU is idle.\n     * This can improve performance because the persistence will not affect UI\n     * renders.\n     * \n     * But: The longer you wait here, the higher is the risk of loosing fork\n     * writes when the replicatoin is destroyed unexpected.\n     */\n    waitBeforePersist?: () => Promise<any>;\n\n    hashFunction: HashFunction;\n};\n\nexport type RxStorageInstanceReplicationState<RxDocType> = {\n    // store the primaryPath here for better reuse and performance.\n    primaryPath: string;\n    input: RxStorageInstanceReplicationInput<RxDocType>;\n\n    events: {\n        /**\n         * Streams all document writes that have SUCCESSFULLY\n         * been written in one direction.\n         */\n        processed: {\n            up: Subject<RxReplicationWriteToMasterRow<RxDocType>>;\n            down: Subject<BulkWriteRow<RxDocType>>;\n        }\n        resolvedConflicts: Subject<{\n            input: RxConflictHandlerInput<RxDocType>;\n            output: RxConflictHandlerOutput<RxDocType>;\n        }>;\n        /**\n         * Contains the cancel state.\n         * Emit true here to cancel the replication.\n         */\n        canceled: BehaviorSubject<boolean>;\n        /**\n         * Contains true if the replication is duing something\n         * at this point in time.\n         * If this is false, it means that the replication\n         * is idle AND in sync.\n         */\n        active: {\n            [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\n        },\n        /**\n         * All errors that would otherwhise be unhandled,\n         * get emitted here.\n         */\n        error: Subject<RxError | RxTypeError>\n    };\n\n\n    /**\n     * Contains counters that can be used in tests\n     * or to debug problems.\n     */\n    stats: {\n        down: {\n            addNewTask: number;\n            downstreamResyncOnce: number;\n            downstreamProcessChanges: number;\n            masterChangeStreamEmit: number;\n            persistFromMaster: number;\n        };\n        up: {\n            upstreamInitialSync: number;\n            forkChangeStreamEmit: number;\n            processTasks: number;\n            persistToMaster: number;\n            persistToMasterHadConflicts: number;\n            persistToMasterConflictWrites: number;\n        };\n    };\n\n    /**\n     * Used in checkpoints and ._meta fields\n     * to ensure we do not mix up meta data of\n     * different replications.\n     */\n    checkpointKey: string;\n\n    downstreamBulkWriteFlag: string;\n\n    /**\n     * Tracks if the streams have been in sync\n     * for at least one time.\n     */\n    firstSyncDone: {\n        [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\n    };\n\n    /**\n     * Can be used to detect if the replication is doing something\n     * or if it is in an idle state.\n     */\n    streamQueue: {\n        [direction in RxStorageReplicationDirection]: Promise<any>;\n    }\n    \n    checkpointQueue: Promise<any>;\n\n    /**\n     * For better performance we store the last known checkpoint\n     * document so that we can likely do checkpoint storing without\n     * conflicts.\n     */\n    lastCheckpointDoc: {\n        [direction in RxStorageReplicationDirection]?: RxDocumentData<RxStorageReplicationMeta>;\n    }\n}\n\nexport type RxStorageReplicationDirection = 'up' | 'down';\n"],"mappings":""}