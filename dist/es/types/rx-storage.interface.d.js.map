{"version":3,"file":"rx-storage.interface.d.js","names":[],"sources":["../../../src/types/rx-storage.interface.d.ts"],"sourcesContent":["import type {\n    DeterministicSortComparator,\n    QueryMatcher\n} from 'event-reduce-js';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PreparedQuery,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult\n} from './rx-storage';\nimport type {\n    DeepReadonly,\n    JsonSchema,\n    MangoQuery,\n    MangoQuerySelector,\n    MangoQuerySortPart,\n    Override,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxJsonSchema\n} from './';\nimport type {\n    Observable\n} from 'rxjs';\n\n/**\n * RxStorage\n * This is an interface that abstracts the storage engine.\n * This allows us to use RxDB with different engines like PouchDB or LokiJS.\n *\n * Also see\n * @link https://github.com/pubkey/rxdb/issues/1636\n *\n */\n\n\n/**\n * A RxStorage is a module that acts\n * as a factory that can create multiple RxStorageInstance\n * objects.\n * \n * All data inputs and outputs of a StorageInstance must be plain json objects.\n * Do not use Map, Set or anything else that cannot be JSON.stringify-ed.\n * This will ensure that the storage can exchange data\n * when it is a WebWorker or a WASM process or data is send via BroadcastChannel.\n */\nexport interface RxStorage<Internals, InstanceCreationOptions> {\n    /**\n     * name of the storage engine\n     * used to detect if plugins do not work so we can throw proper errors.\n     */\n    readonly name: string;\n\n    /**\n     * Static functions\n     */\n    readonly statics: RxStorageStatics;\n\n    /**\n     * creates a storage instance\n     * that can contain the internal database\n     * For example the PouchDB instance\n     */\n    createStorageInstance<RxDocType>(\n        params: RxStorageInstanceCreationParams<RxDocType, InstanceCreationOptions>\n    ): Promise<RxStorageInstance<RxDocType, Internals, InstanceCreationOptions>>;\n}\n\n\n/**\n * User provided mango queries will be filled up by RxDB via normalizeMangoQuery()\n * so we do not have to do many if-field-exist tests in the internals.\n */\nexport type FilledMangoQuery<RxDocType> = Override<\n    MangoQuery<RxDocType>,\n    {\n        /**\n         * The selector is required here.\n         */\n        selector: MangoQuerySelector<RxDocType>;\n\n        /**\n         * In contrast to the user-provided MangoQuery,\n         * the sorting is required here because\n         * RxDB has to ensure that the primary key is always\n         * part of the sort params.\n         */\n        sort: MangoQuerySortPart<RxDocType>[];\n\n        /**\n         * In the normalized mango query,\n         * the index must always be a string[],\n         * never just a string.\n         * This makes it easier to use the query because\n         * we do not have to do an array check.\n         */\n        index?: string[];\n\n        /**\n         * Skip must be set which defaults to 0\n         */\n        skip: number;\n    }\n>;\n\n/**\n * Static functions of the RxStorage.\n * Can be used without creating an instance of any kind.\n * These functions are not directly children of RxStorage because\n * we might need them without having to import the whole storage engine.\n * For example when the Worker plugin is used, the main process only needs the\n * static functions, while the worker process needs the whole storage engine.\n */\nexport type RxStorageStatics = Readonly<{\n    /**\n     * PouchDB and others have some bugs\n     * and behaviors that must be worked around\n     * before querying the db.\n     * \n     * Also some storages do optimizations\n     * and other things related to query planning.\n     * \n     * For performance reason this preparation\n     * runs in a single step so it can be cached\n     * when the query is used multiple times.\n     *\n     * @returns a format of the query that can be used with the storage\n     * when calling RxStorageInstance().query()\n     */\n    prepareQuery<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        /**\n         * a query that can be mutated by the function without side effects.\n         */\n        mutateableQuery: FilledMangoQuery<RxDocType>\n    ): PreparedQuery<RxDocType>;\n\n    /**\n     * Returns the sort-comparator,\n     * which is able to sort documents in the same way\n     * a query over the db would do.\n     */\n    getSortComparator<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        preparedQuery: PreparedQuery<RxDocType>\n    ): DeterministicSortComparator<RxDocType>;\n\n    /**\n     * Returns a function\n     * that can be used to check if a document\n     * matches the query.\n     */\n    getQueryMatcher<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        preparedQuery: PreparedQuery<RxDocType>\n    ): QueryMatcher<RxDocumentData<RxDocType>>;\n\n    /**\n     * Contains the JsonSchema that matches the checkpoint\n     * of this RxStorage.\n     * Used in some plugins like the graphql plugin\n     * where it is used to create a GraphQL Schema from the checkpoint.\n     */\n    checkpointSchema: DeepReadonly<JsonSchema>;\n}>;\n\n\nexport interface RxStorageInstance<\n    /**\n     * The type of the documents that can be stored in this instance.\n     * All documents in an instance must comply to the same schema.\n     * Also all documents are RxDocumentData with the meta properties like\n     * _deleted or _rev etc.\n     */\n    RxDocType,\n    Internals,\n    InstanceCreationOptions,\n    CheckpointType = any\n> {\n    readonly databaseName: string;\n    /**\n     * Returns the internal data that is used by the storage engine.\n     * For example the pouchdb instance.\n     */\n    readonly internals: Readonly<Internals>;\n    readonly options: Readonly<InstanceCreationOptions>;\n    /**\n     * The schema that defines the documents that are stored in this instance.\n     * Notice that the schema must be enhanced with the meta properties like\n     * _meta, _rev and _deleted etc. which are added by fillWithDefaultSettings()\n     */\n    readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>;\n    readonly collectionName: string;\n\n    /**\n     * Writes multiple documents to the storage instance.\n     * The write for each single document is atomic, there\n     * is no transaction around all documents.\n     * The written documents must be the newest revision of that documents data.\n     * If the previous document is not the current newest revision, a conflict error\n     * must be returned.\n     * It must be possible that some document writes succeed\n     * and others error. We need this to have a similar behavior as most NoSQL databases.\n     */\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        /**\n         * Context will be used in all\n         * changeStream()-events that are emitted as a result\n         * of that bulkWrite() operation.\n         * Used in plugins so that we can detect that event X\n         * comes from operation Y.\n         */\n        context: string\n    ): Promise<\n        /**\n         * returns the response, split into success and error lists.\n         */\n        RxStorageBulkWriteResponse<RxDocType>\n    >;\n\n    /**\n     * Get Multiple documents by their primary value.\n     * This must also return deleted documents.\n     */\n    findDocumentsById(\n        /**\n         * List of primary values\n         * of the documents to find.\n         */\n        ids: string[],\n        /**\n         * If set to true, deleted documents will also be returned.\n         */\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>>;\n\n    /**\n     * Runs a NoSQL 'mango' query over the storage\n     * and returns the found documents data.\n     * Having all storage instances behave similar\n     * is likely the most difficult thing when creating a new\n     * rx-storage implementation. Atm we use the pouchdb-find plugin\n     * as reference to how NoSQL-queries must work.\n     * But the past has shown that pouchdb find can behave wrong,\n     * which must be fixed or at least documented.\n     */\n    query(\n        /**\n         * Here we get the result of this.prepareQuery()\n         * instead of the plain mango query.\n         * This makes it easier to have good performance\n         * when transformations of the query must be done.\n         */\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>>;\n\n    /**\n     * Returns the amount of non-deleted documents\n     * that match the given query.\n     * Sort, skip and limit of the query must be ignored!\n     */\n    count(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult>;\n\n    /**\n     * Returns the plain data of a single attachment.\n     */\n    getAttachmentData(\n        documentId: string,\n        attachmentId: string\n    ): Promise<string>;\n\n    /**\n     * Returns the current (not the old!) data of all documents that have been changed AFTER the given checkpoint.\n     * If the returned array does not reach the limit, it can be assumed that the \"end\" is reached, when paginating over the changes.\n     * Also returns a new checkpoint for each document which can be used to continue with the pagination from that change on.\n     * Must never return the same document multiple times in the same call operation.\n     * This is used by RxDB to known what has changed since X so these docs can be handled by the backup or the replication\n     * plugin.\n     */\n    getChangedDocumentsSince(\n        limit: number,\n        /**\n         * The checkpoint from with to start\n         * when the events are sorted in time.\n         * If we want to start from the beginning,\n         * undefined is used as a checkpoint.\n         */\n        checkpoint?: CheckpointType\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        /**\n         * The checkpoint contains data so that another\n         * call to getChangedDocumentsSince() will continue\n         * from exactly the last document that was returned before.\n         */\n        checkpoint: CheckpointType;\n    }>;\n\n    /**\n     * Returns an ongoing stream\n     * of all changes that happen to the\n     * storage instance.\n     * Do not forget to unsubscribe.\n     * \n     * If the RxStorage support multi-instance,\n     * and the storage is persistend,\n     * then the emitted changes of one RxStorageInstance\n     * must be also emitted to other instances with the same databaseName+collectionName.\n     * See ./rx-storage-multiinstance.ts\n     */\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocType>, CheckpointType>>;\n\n    /**\n     * Runs a cleanup that removes all tompstones\n     * of documents that have _deleted set to true\n     * to free up disc space.\n     * \n     * Returns true if all cleanable documents have been removed.\n     * Returns false if there are more documents to be cleaned up,\n     * but not all have been purged because that would block the storage for too long.\n     */\n    cleanup(\n        /**\n         * The minimum time in milliseconds\n         * of how long a document must have been deleted\n         * until it is purged by the cleanup.\n         */\n        minimumDeletedTime: number\n    ): Promise<\n        /**\n         * True if all docs cleaned up,\n         * false if there are more docs to clean up\n         */\n        boolean\n    >;\n\n    /**\n     * Closes the storage instance so it cannot be used\n     * anymore and should clear all memory.\n     * The returned promise must resolve when everything is cleaned up.\n     */\n    close(): Promise<void>;\n\n    /**\n     * Remove the database and\n     * deletes all of its data.\n     */\n    remove(): Promise<void>;\n\n    /**\n     * Instead of passing the conflict-resolver function\n     * into the storage, we have to work with an observable that emits tasks\n     * and a resolver that takes resolved tasks.\n     * This is needed because the RxStorageInstance might run inside of a Worker\n     * other JavaScript process, so we cannot pass plain code.\n     */\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>>;\n    resolveConflictResultionTask(taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void>;\n}\n"],"mappings":""}