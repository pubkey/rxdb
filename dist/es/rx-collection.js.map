{"version":3,"file":"rx-collection.js","names":["filter","startWith","mergeMap","shareReplay","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","clone","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","RXJS_SHARE_REPLAY_DEFAULTS","getDefaultRxDocumentMeta","getDefaultRevision","nextTick","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","removeCollectionStorages","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocCache","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createRxDocument","getWrappedStorageInstance","storageChangeEventToRxChangeEvent","throwIfIsStorageWriteError","defaultConflictHandler","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","conflictHandler","storageInstance","timeouts","Set","_atomicUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","_changeEventBuffer","onDestroy","destroyed","_applyHookFunctions","asRxCollection","prepare","jsonSchema","eventBulks$","pipe","changeEventBulk","collectionName","events","storageToken","databaseStorageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","map","ev","databaseToken","token","checkpoint","context","$emit","push","cE","isLocal","doc","get","documentId","_handleChangeEvent","conflictResultionTasks","task","input","then","output","resolveConflictResultionTask","migrationNeeded","getDataMigrator","migrate","batchSize","migratePromise","insert","json","useJson","bulkInsert","writeResult","isError","error","primaryPath","insertResult","success","docsData","docs","docsMap","insertRows","set","docData","Object","assign","_attachments","_meta","_rev","_deleted","row","document","bulkWrite","results","rxDocuments","values","successDocData","writtenDocData","hasHooks","Promise","all","_runHooks","primary","length","useDocs","useDocData","bulkRemove","ids","findByIds","rxDocumentMap","Array","from","forEach","rxDocument","data","toJSON","removeDocs","writeDoc","previous","successIds","keys","bulkUpsert","insertData","useJsonByDocId","ret","slice","writeData","docDataInDb","documentInDb","atomicUpdate","updatedDocs","concat","upsert","result","atomicUpsert","queue","_atomicUpsertEnsureRxDocumentExists","wasInserted","inserted","_atomicUpsertUpdate","find","queryObj","query","findOne","selector","limit","isArray","count","mustBeQueried","findDocumentsById","findByIds$","currentValue","lastChangeEvent","initialPromise","counter","firstEmitDone","changeEvent","includes","missedChangeEvents","getFrom","newResult","resultHasChanged","rxChangeEvent","docId","op","operation","documentData","has","x","exportJSON","importJSON","_exportedJSON","insertCRDT","_updateObj","syncCouchDB","_syncOptions","syncGraphQL","_options","addHook","when","key","fun","parallel","boundFun","bind","runName","series","getHooks","instance","tasks","hook","_runHooksSync","promiseWait","time","res","timeout","setTimeout","add","destroy","clearTimeout","requestIdlePromise","fn","close","sub","unsubscribe","collections","remove","storage","internalStore","hashFunction","collection","colProto","getPrototypeOf","fnName","_innerDoc","rxCollection","docFromCache","resolve","exec","newDoc","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","multiInstance","password","entries","funName","defineProperty","version","creator","err","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\n    filter,\n    startWith,\n    mergeMap,\n    shareReplay\n} from 'rxjs/operators';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    clone,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getDefaultRxDocumentMeta,\n    getDefaultRevision,\n    nextTick\n} from './util';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages\n} from './rx-collection-helper';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error';\nimport type {\n    DataMigrator\n} from './plugins/migration';\nimport {\n    DocCache\n} from './doc-cache';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCouchDBReplicationState,\n    MigrationState,\n    SyncOptions,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    SyncOptionsGraphQL,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageBulkWriteError,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise,\n    CRDTEntry,\n    MangoQuerySelectorAndIndex\n} from './types';\nimport type {\n    RxGraphQLReplicationState\n} from './plugins/replication-graphql';\n\nimport {\n    RxSchema\n} from './rx-schema';\n\nimport {\n    createRxDocument\n} from './rx-document-prototype-merge';\nimport {\n    getWrappedStorageInstance,\n    storageChangeEventToRxChangeEvent,\n    throwIfIsStorageWriteError\n} from './rx-storage-helper';\nimport { defaultConflictHandler } from './replication-protocol';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any }\n> {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: KeyFunctionMap = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _atomicUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocCache<\n        RxDocument<RxDocumentType, OrmMethods>\n    > = new DocCache();\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer = {} as ChangeEventBuffer;\n\n\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n    public onDestroy: (() => MaybePromise<any>)[] = [];\n    public destroyed = false;\n\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n\n        this.$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n\n        /**\n         * Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(\n                    false,\n                    ev,\n                    this as any\n                )),\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * When a write happens to the collection\n         * we find the changed document in the docCache\n         * and tell it that it has to change its data.\n         */\n        this._subs.push(\n            this.$\n                .pipe(\n                    filter((cE: RxChangeEvent<RxDocumentType>) => !cE.isLocal)\n                )\n                .subscribe(cE => {\n                    // when data changes, send it to RxDocument in docCache\n                    const doc = this._docCache.get(cE.documentId);\n                    if (doc) {\n                        doc._handleChangeEvent(cE);\n                    }\n                })\n        );\n\n        /**\n         * Resolve the conflict tasks\n         * of the RxStorageInstance\n         */\n        this._subs.push(\n            this.storageInstance\n                .conflictResultionTasks()\n                .subscribe(task => {\n                    this\n                        .conflictHandler(task.input, task.context)\n                        .then(output => {\n                            this.storageInstance.resolveConflictResultionTask({\n                                id: task.id,\n                                output\n                            });\n                        });\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    // overwritte by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration');\n    }\n    getDataMigrator(): DataMigrator {\n        throw pluginMissing('migration');\n    }\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        return this.getDataMigrator().migrate(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getDataMigrator().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n\n        // TODO do we need fillObjectDataBeforeInsert() here because it is also run at bulkInsert() later\n        const useJson: RxDocumentWriteData<RxDocumentType> = fillObjectDataBeforeInsert(this.schema, json);\n\n        const writeResult = await this.bulkInsert([useJson]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, useJson[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const useDocs = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n            return useDocData;\n        });\n        const docs = this.hasHooks('pre', 'insert') ?\n            await Promise.all(\n                useDocs.map(doc => {\n                    return this._runHooks('pre', 'insert', doc)\n                        .then(() => {\n                            return doc;\n                        });\n                })\n            ) : useDocs;\n        const docsMap: Map<string, RxDocumentType> = new Map();\n        const insertRows: BulkWriteRow<RxDocumentType>[] = docs.map(doc => {\n            docsMap.set((doc as any)[this.schema.primaryPath] as any, doc);\n            const docData = Object.assign(doc, {\n                _attachments: {},\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision(),\n                _deleted: false\n            });\n            const row: BulkWriteRow<RxDocumentType> = { document: docData };\n            return row;\n        });\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n        // create documents\n        const successDocData: RxDocumentData<RxDocumentType>[] = Object.values(results.success);\n        const rxDocuments: any[] = successDocData\n            .map((writtenDocData) => {\n                const doc = createRxDocument(this as any, writtenDocData);\n                return doc;\n            });\n\n        if (this.hasHooks('post', 'insert')) {\n            await Promise.all(\n                rxDocuments.map(doc => {\n                    return this._runHooks(\n                        'post', 'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[],\n        error: RxStorageBulkWriteError<RxDocumentType>[]\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids);\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = clone(rxDocument.toJSON(true)) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n        const successIds: string[] = Object.keys(results.success);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments: any[] = successIds.map(id => {\n            return rxDocumentMap.get(id);\n        });\n\n        return {\n            success: rxDocuments,\n            error: Object.values(results.error)\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<RxDocument<RxDocumentType, OrmMethods>[]> {\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        let ret = insertResult.success.slice(0);\n        const updatedDocs = await Promise.all(\n            insertResult.error.map(error => {\n                const id = error.documentId;\n                const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                const docDataInDb = ensureNotFalsy(error.documentInDb);\n                const doc = createRxDocument(this.asRxCollection, docDataInDb);\n                return doc.atomicUpdate(() => writeData);\n            })\n        );\n        ret = ret.concat(updatedDocs);\n        return ret;\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        return this.bulkUpsert([json]).then(result => result[0]);\n    }\n\n    /**\n     * upserts to a RxDocument, uses atomicUpdate if document already exists\n     */\n    atomicUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it won't try 2 parallel runs\n        let queue = this._atomicUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _atomicUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _atomicUpsertUpdate(wasInserted.doc, useJson)\n                        .then(() => wasInserted.doc);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._atomicUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[]\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this.asRxCollection);\n        return query as any;\n    }\n\n    findOne(queryObj?: MangoQueryNoLimit<RxDocumentType> | string): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>\n        | null\n    > {\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritte\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            (queryObj as any).limit = 1;\n            query = createRxQuery('findOne', queryObj, this.asRxCollection);\n        }\n\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        return query as any;\n    }\n\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        number\n    > {\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n        const query = createRxQuery('count', queryObj, this.asRxCollection);\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    async findByIds(\n        ids: string[]\n    ): Promise<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n\n        const ret = new Map();\n        const mustBeQueried: string[] = [];\n\n        // first try to fill from docCache\n        ids.forEach(id => {\n            const doc = this._docCache.get(id);\n            if (doc) {\n                ret.set(id, doc);\n            } else {\n                mustBeQueried.push(id);\n            }\n        });\n\n        // find everything which was not in docCache\n        if (mustBeQueried.length > 0) {\n            const docs = await this.storageInstance.findDocumentsById(mustBeQueried, false);\n            Object.values(docs).forEach(docData => {\n                const doc = createRxDocument<RxDocumentType, OrmMethods>(this as any, docData);\n                ret.set(doc.primary, doc);\n            });\n        }\n        return ret;\n    }\n\n    /**\n     * like this.findByIds but returns an observable\n     * that always emits the current state\n     */\n    findByIds$(\n        ids: string[]\n    ): Observable<Map<string, RxDocument<RxDocumentType, OrmMethods>>> {\n        let currentValue: Map<string, RxDocument<RxDocumentType, OrmMethods>> | null = null;\n        let lastChangeEvent: number = -1;\n\n        /**\n         * Ensure we do not process events in parallel\n         */\n        let queue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n        const initialPromise = this.findByIds(ids).then(docsMap => {\n            lastChangeEvent = this._changeEventBuffer.counter;\n            currentValue = docsMap;\n        });\n        let firstEmitDone = false;\n\n        return this.$.pipe(\n            startWith(null),\n            /**\n             * Optimization shortcut.\n             * Do not proceed if the emitted RxChangeEvent\n             * is not relevant for the query.\n             */\n            filter(changeEvent => {\n                if (\n                    // first emit has no event\n                    changeEvent &&\n                    (\n                        // local documents are not relevant for the query\n                        changeEvent.isLocal ||\n                        // document of the change is not in the ids list.\n                        !ids.includes(changeEvent.documentId)\n                    )\n                ) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            mergeMap(() => initialPromise),\n            /**\n             * Because shareReplay with refCount: true\n             * will often subscribe/unsusbscribe\n             * we always ensure that we handled all missed events\n             * since the last subscription.\n             */\n            mergeMap(() => {\n                queue = queue.then(async () => {\n                    /**\n                     * We first have to clone the Map\n                     * to ensure we do not create side effects by mutating\n                     * a Map that has already been returned before.\n                     */\n                    currentValue = new Map(ensureNotFalsy(currentValue));\n                    const missedChangeEvents = this._changeEventBuffer.getFrom(lastChangeEvent + 1);\n                    lastChangeEvent = this._changeEventBuffer.counter;\n                    if (missedChangeEvents === null) {\n                        /**\n                         * changeEventBuffer is of bounds -> we must re-execute over the database\n                         * because we cannot calculate the new results just from the events.\n                         */\n                        const newResult = await this.findByIds(ids);\n                        lastChangeEvent = this._changeEventBuffer.counter;\n                        return newResult;\n                    } else {\n                        let resultHasChanged = false;\n                        missedChangeEvents\n                            .forEach(rxChangeEvent => {\n                                const docId = rxChangeEvent.documentId;\n                                if (!ids.includes(docId)) {\n                                    // document is not relevant for the result set\n                                    return;\n                                }\n                                const op = rxChangeEvent.operation;\n                                if (op === 'INSERT' || op === 'UPDATE') {\n                                    resultHasChanged = true;\n                                    const rxDocument = createRxDocument(\n                                        this.asRxCollection,\n                                        rxChangeEvent.documentData\n                                    );\n                                    ensureNotFalsy(currentValue).set(docId, rxDocument);\n                                } else {\n                                    if (ensureNotFalsy(currentValue).has(docId)) {\n                                        resultHasChanged = true;\n                                        ensureNotFalsy(currentValue).delete(docId);\n                                    }\n                                }\n                            });\n\n                        // nothing happened that affects the result -> do not emit\n                        if (!resultHasChanged && firstEmitDone) {\n                            return false as any;\n                        }\n                    }\n                    firstEmitDone = true;\n                    return currentValue;\n                });\n                return queue;\n            }),\n            filter(x => !!x),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\n        throw pluginMissing('crdt');\n    }\n\n    /**\n     * sync with a CouchDB endpoint\n     */\n    syncCouchDB(_syncOptions: SyncOptions): RxCouchDBReplicationState {\n        throw pluginMissing('replication');\n    }\n\n    /**\n     * sync with a GraphQL endpoint\n     */\n    syncGraphQL<CheckpointType = any>(_options: SyncOptionsGraphQL<RxDocumentType, CheckpointType>): RxGraphQLReplicationState<RxDocumentType, CheckpointType> {\n        throw pluginMissing('replication-graphql');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => Promise.all(this.onDestroy.map(fn => fn())))\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.destroy();\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _atomicUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.atomicUpdate((_innerDoc: RxDocumentData<RxDocType>) => {\n        return json;\n    })\n        .then(() => nextTick())\n        .then(() => {\n            return doc;\n        });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _atomicUpsertEnsureRxDocumentExists(\n    rxCollection: RxCollection,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument,\n        inserted: boolean\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docFromCache = rxCollection._docCache.get(primary);\n    if (docFromCache) {\n        return Promise.resolve({\n            doc: docFromCache,\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics,\n            conflictHandler\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"mappings":"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"}