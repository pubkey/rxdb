{"version":3,"file":"event-reduce.js","names":["calculateActionName","runAction","hasLimit","isUpdate","isDelete","isFindOne","isInsert","hasSkip","wasResultsEmpty","wasInResult","wasSortedAfterLast","previousUnknown","wasLimitReached","wasMatching","doesMatchNow","rxChangeEventToEventReduceChangeEvent","arrayFilterNotEmpty","clone","ensureNotFalsy","getFromMapOrCreate","getQueryMatcher","getSortComparator","normalizeMangoQuery","getSortFieldsOfQuery","primaryKey","query","sort","length","map","part","Object","keys","RXQUERY_QUERY_PARAMS_CACHE","WeakMap","getQueryParams","rxQuery","collection","normalizedMangoQuery","storageInstance","schema","mangoQuery","primaryPath","sortComparator","jsonSchema","useSortComparator","docA","docB","sortComparatorData","queryMatcher","useQueryMatcher","doc","queryMatcherData","ret","skip","limit","sortFields","canFillResultSetFromLimitBuffer","s","calculateNewResults","rxChangeEvents","database","eventReduce","runFullQueryAgain","queryParams","previousResults","_result","docsData","slice","previousResultsMap","docsDataMap","changed","eventReduceEvents","cE","filter","foundNonOptimizeable","find","eventReduceEvent","stateResolveFunctionInput","changeEvent","keyDocumentMap","actionName","_limitBufferResults","replacementItem","shift","undefined","push","set","newResults"],"sources":["../../src/event-reduce.ts"],"sourcesContent":["import {\n    ActionName,\n    calculateActionName,\n    runAction,\n    QueryParams,\n    QueryMatcher,\n    DeterministicSortComparator,\n    StateResolveFunctionInput,\n    ChangeEvent,\n    hasLimit,\n    isUpdate,\n    isDelete,\n    isFindOne,\n    isInsert,\n    hasSkip,\n    wasResultsEmpty,\n    wasInResult,\n    wasSortedAfterLast,\n    previousUnknown,\n    wasLimitReached,\n    wasMatching,\n    doesMatchNow\n} from 'event-reduce-js';\nimport type {\n    RxQuery,\n    MangoQuery,\n    RxChangeEvent,\n    StringKeys,\n    RxDocumentData\n} from './types';\nimport { rxChangeEventToEventReduceChangeEvent } from './rx-change-event';\nimport {\n    arrayFilterNotEmpty,\n    clone,\n    ensureNotFalsy,\n    getFromMapOrCreate\n} from './plugins/utils';\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from './rx-query-helper';\n\nexport type EventReduceResultNeg = {\n    runFullQueryAgain: true;\n};\nexport type EventReduceResultPos<RxDocumentType> = {\n    runFullQueryAgain: false;\n    changed: boolean;\n    newResults: RxDocumentType[];\n};\nexport type EventReduceResult<RxDocumentType> = EventReduceResultNeg | EventReduceResultPos<RxDocumentType>;\n\n\nexport function getSortFieldsOfQuery<RxDocType>(\n    primaryKey: StringKeys<RxDocumentData<RxDocType>>,\n    query: MangoQuery<RxDocType>\n): (string | StringKeys<RxDocType>)[] {\n    if (!query.sort || query.sort.length === 0) {\n        return [primaryKey];\n    } else {\n        return query.sort.map(part => Object.keys(part)[0]);\n    }\n}\n\n\n\nexport const RXQUERY_QUERY_PARAMS_CACHE: WeakMap<RxQuery, QueryParams<any>> = new WeakMap();\nexport function getQueryParams<RxDocType>(\n    rxQuery: RxQuery<RxDocType>\n): QueryParams<RxDocType> {\n    return getFromMapOrCreate(\n        RXQUERY_QUERY_PARAMS_CACHE,\n        rxQuery,\n        () => {\n            const collection = rxQuery.collection;\n            const normalizedMangoQuery = normalizeMangoQuery(\n                collection.storageInstance.schema,\n                clone(rxQuery.mangoQuery)\n            );\n            const primaryKey = collection.schema.primaryPath;\n\n            /**\n             * Create a custom sort comparator\n             * that uses the hooks to ensure\n             * we send for example compressed documents to be sorted by compressed queries.\n             */\n            const sortComparator = getSortComparator(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n\n            const useSortComparator: DeterministicSortComparator<RxDocType> = (docA: RxDocType, docB: RxDocType) => {\n                const sortComparatorData = {\n                    docA,\n                    docB,\n                    rxQuery\n                };\n                return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n            };\n\n            /**\n             * Create a custom query matcher\n             * that uses the hooks to ensure\n             * we send for example compressed documents to match compressed queries.\n             */\n            const queryMatcher = getQueryMatcher(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n            const useQueryMatcher: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType>) => {\n                const queryMatcherData = {\n                    doc,\n                    rxQuery\n                };\n                return queryMatcher(queryMatcherData.doc);\n            };\n\n            const ret: QueryParams<any> = {\n                primaryKey: rxQuery.collection.schema.primaryPath as any,\n                skip: normalizedMangoQuery.skip,\n                limit: normalizedMangoQuery.limit,\n                sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery) as string[],\n                sortComparator: useSortComparator,\n                queryMatcher: useQueryMatcher\n            };\n            return ret;\n        }\n    );\n}\n\n// This catches a specific case where we have a limit query (of say LIMIT items), and then\n// a document is removed from the result set by the current change. In this case,\n// the event-reduce library (rightly) tells us we need to recompute the query to get a\n// full result set of LIMIT items.\n// However, if we have a \"limit buffer\", we can instead fill in the missing result from there.\n// For more info, see the rx-query.test tests under \"Limit Buffer\".\n// This function checks if we are actually in the specific case where the limit buffer can be used.\nfunction canFillResultSetFromLimitBuffer<RxDocumentType>(s: StateResolveFunctionInput<RxDocumentType>) {\n    // We figure out if this event is our special case using the same \"state resolve\" functions that event-reduce uses:\n    // https://github.com/pubkey/event-reduce/blob/fcb46947b29eac97c97dcb05e08af337f362fe5c/javascript/src/states/index.ts#L87\n    // (we also keep the state resolve functions in the same order they're defined in event-reduce.js)\n    return (\n        !isInsert(s) && // inserts can never cause\n        (isUpdate(s) || isDelete(s)) && // both updates and deletes can remove a doc from our results\n        hasLimit(s) && // only limit queries\n        !isFindOne(s) && // if it's a findOne, we have no buffer and have to re-compute\n        !hasSkip(s) && // we could potentially make skip queries work later, but for now ignore them -- too hard\n        !wasResultsEmpty(s) && // this should never happen\n        !previousUnknown(s) && // we need to have had the prev result set\n        wasLimitReached(s) && // if not, the event reducer shouldn't have a problem\n        // any value of wasFirst(s), position is not relevant for this case, as wasInResults\n        // any value of wasLast(s) , position is not relevant for this case, as wasInResults\n        // any value of sortParamsChanged(s), eg a doc could be archived but also have last_status_update changed\n        wasInResult(s) && // we only care about docs already in the results set being removed\n        // any value of wasSortedBeforeFirst(s) -- this is true when the doc is first in the results set\n        !wasSortedAfterLast(s) && // I don't think this could be true anyways, but whatever\n        // any value of isSortedBeforeFirst(s) -- this is true when the doc is first in order (but it could still be filtered out)\n        // any value of isSortedAfterLast(s)\n        wasMatching(s) && // it couldn't have been wasInResult unless it was also matching\n        !doesMatchNow(s) // Limit buffer only cares rn when the changed doc was indeed removed (so no longer matching)\n    );\n}\n\n\n\nexport function calculateNewResults<RxDocumentType>(\n    rxQuery: RxQuery<RxDocumentType>,\n    rxChangeEvents: RxChangeEvent<RxDocumentType>[]\n): EventReduceResult<RxDocumentType> {\n    if (!rxQuery.collection.database.eventReduce) {\n        return {\n            runFullQueryAgain: true\n        };\n    }\n    const queryParams = getQueryParams(rxQuery);\n    const previousResults: RxDocumentType[] = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n    const previousResultsMap: Map<string, RxDocumentType> = ensureNotFalsy(rxQuery._result).docsDataMap;\n    let changed: boolean = false;\n\n    const eventReduceEvents: ChangeEvent<RxDocumentType>[] = rxChangeEvents\n        .map(cE => rxChangeEventToEventReduceChangeEvent(cE))\n        .filter(arrayFilterNotEmpty);\n    const foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n        const stateResolveFunctionInput: StateResolveFunctionInput<RxDocumentType> = {\n            queryParams,\n            changeEvent: eventReduceEvent,\n            previousResults,\n            keyDocumentMap: previousResultsMap\n        };\n\n        const actionName: ActionName = calculateActionName(stateResolveFunctionInput);\n        if (actionName === 'runFullQueryAgain') {\n            if (canFillResultSetFromLimitBuffer(stateResolveFunctionInput) && rxQuery._limitBufferResults !== null && rxQuery._limitBufferResults.length > 0) {\n                // replace the missing item with an item from our limit buffer!\n                const replacementItem = rxQuery._limitBufferResults.shift();\n                if (replacementItem === undefined) {\n                    return true;\n                }\n\n                changed = true;\n                runAction(\n                    'removeExisting',\n                    queryParams,\n                    eventReduceEvent,\n                    previousResults,\n                    previousResultsMap,\n                );\n                previousResults.push(replacementItem);\n                if (previousResultsMap) {\n                    // We have to assume the primaryKey value is a string. According to the rxdb docs, this is always the case:\n                    // https://github.com/pubkey/rxdb/blob/c8162c25c7b033fa9f70191512ee84d44d0dd913/docs/rx-schema.html#L2523\n                    previousResultsMap.set(replacementItem[rxQuery.collection.schema.primaryPath] as string, replacementItem);\n                }\n                return false;\n            }\n            return true;\n        } else if (actionName !== 'doNothing') {\n            changed = true;\n            runAction(\n                actionName,\n                queryParams,\n                eventReduceEvent,\n                previousResults,\n                previousResultsMap\n            );\n            return false;\n        }\n    });\n    if (foundNonOptimizeable) {\n        return {\n            runFullQueryAgain: true,\n        };\n    } else {\n        return {\n            runFullQueryAgain: false,\n            changed,\n            newResults: previousResults\n        };\n    }\n}\n"],"mappings":"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"}