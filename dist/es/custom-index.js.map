{"version":3,"sources":["../../src/custom-index.ts"],"names":["getSchemaByObjectPath","objectPath","ensureNotFalsy","getIndexableString","schema","index","docData","str","forEach","fieldName","schemaPart","fieldValue","get","type","maxLength","padStart","boolToStr","parsedLengths","getStringLengthOfIndexNumber","getNumberIndexString","Error","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","length","multipleOfParts","split","decimals","roundedMinimum","nonDecimalsValueAsString","splittedByDecimalPoint","decimalValueAsString","padEnd","getStartIndexStringFromLowerBound","lowerBound","idx","bound","repeat","MAX_CHAR","String","fromCharCode","getStartIndexStringFromUpperBound","upperBound"],"mappings":"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","sourcesContent":["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport { JsonSchema, RxDocumentData, RxJsonSchema } from './types';\nimport objectPath from 'object-path';\nimport { ensureNotFalsy } from './util';\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above \n * another documents, dependent on the index values.\n */\nexport function getIndexableString<RxDocType>(\n    schema: RxJsonSchema<RxDocType>,\n    index: string[],\n    docData: RxDocumentData<RxDocType>\n): string {\n    let str = '';\n    index.forEach(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        let fieldValue = objectPath.get(docData, fieldName);\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = schemaPart.maxLength as number;\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                str += fieldValue.padStart(maxLength, ' ');\n                break;\n            case 'boolean':\n                const boolToStr = fieldValue ? '1' : '0';\n                str += boolToStr;\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (!fieldValue) {\n                    fieldValue = 0;\n                }\n                str += getNumberIndexString(\n                    parsedLengths,\n                    fieldValue\n                );\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\ndeclare type ParsedLengths = {\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    let str: string = '';\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    str += nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    const splittedByDecimalPoint = fieldValue.toString().split('.');\n    const decimalValueAsString = splittedByDecimalPoint.length > 1 ? splittedByDecimalPoint[1] : '0';\n\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, ' ');\n                } else {\n                    str += ''.padStart(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '0';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null) {\n                    str += '0'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\nexport const MAX_CHAR = String.fromCharCode(65535);\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, MAX_CHAR);\n                } else {\n                    str += ''.padStart(maxLength, MAX_CHAR);\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === MAX_CHAR) {\n                    str += '9'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n"],"file":"custom-index.js"}