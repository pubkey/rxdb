{"version":3,"file":"custom-index.js","names":["getSchemaByObjectPath","ensureNotFalsy","objectPathMonad","INDEX_MAX","getIndexableStringMonad","schema","index","fieldNameProperties","map","fieldName","schemaPart","type","parsedLengths","getStringLengthOfIndexNumber","hasComplexPath","includes","getValueFn","ret","docData","str","forEach","props","fieldValue","padStart","maxLength","boolToStr","getNumberIndexString","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","length","multipleOfParts","split","decimals","roundedMinimum","nonDecimalsValueAsString","splittedByDecimalPoint","decimalValueAsString","padEnd","getStartIndexStringFromLowerBound","lowerBound","idx","bound","repeat","Error","getStartIndexStringFromUpperBound","upperBound"],"sources":["../../src/custom-index.ts"],"sourcesContent":["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport { ensureNotFalsy, objectPathMonad, ObjectPathMonadFunction } from './util';\nimport { INDEX_MAX } from './query-planner';\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above \n * another documents, dependent on the index values.\n * @monad for better performance\n * \n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n\n    /**\n     * Prepare all relevant information\n     * outside of the returned function\n     * to save performance when the returned\n     * function is called many times.\n     */\n    const fieldNameProperties: {\n        fieldName: string;\n        schemaPart: JsonSchema;\n        /*\n         * Only in number fields.\n         */\n        parsedLengths?: ParsedLengths;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        return {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            hasComplexPath: fieldName.includes('.'),\n            getValueFn: objectPathMonad(fieldName)\n        }\n    });\n\n\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        fieldNameProperties.forEach(props => {\n            const schemaPart = props.schemaPart;\n            const type = schemaPart.type;\n\n            let fieldValue = props.getValueFn(docData);\n\n            if (type === 'string') {\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                str += fieldValue.padStart(schemaPart.maxLength as number, ' ');\n            } else if (type === 'boolean') {\n                const boolToStr = fieldValue ? '1' : '0';\n                str += boolToStr;\n            } else {\n                const parsedLengths = ensureNotFalsy(props.parsedLengths);\n                if (!fieldValue) {\n                    fieldValue = 0;\n                }\n                str += getNumberIndexString(\n                    parsedLengths,\n                    fieldValue\n                );\n            }\n        });\n        return str;\n    }\n    return ret;\n}\n\ndeclare type ParsedLengths = {\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    let str: string = '';\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    str += nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    const splittedByDecimalPoint = fieldValue.toString().split('.');\n    const decimalValueAsString = splittedByDecimalPoint.length > 1 ? splittedByDecimalPoint[1] : '0';\n\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, ' ');\n                } else {\n                    str += ''.padStart(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '0';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null) {\n                    str += '0'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padStart(maxLength, INDEX_MAX);\n                } else {\n                    str += ''.padStart(maxLength, INDEX_MAX);\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    str += '9'.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n"],"mappings":"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"}