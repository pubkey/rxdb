{"version":3,"file":"upstream.js","names":["firstValueFrom","filter","stackCheckpoints","ensureNotFalsy","flatClone","PROMISE_RESOLVE_FALSE","getLastCheckpointDoc","setCheckpoint","resolveConflictError","writeDocToDocState","getAssumedMasterState","getMetaWriteRow","pact","state","value","s","v","o","bind","then","observer","prototype","onFulfilled","onRejected","result","callback","e","_this","thenable","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","startReplicationUpstream","upstreamInitialSync","stats","up","events","canceled","getValue","checkpointQueue","lastCheckpoint","Promise","all","promises","resolvedPromises","hadConflicts","find","r","firstSyncDone","next","initialSyncStartTime","timer","input","forkInstance","getChangedDocumentsSince","pushBatchSize","upResult","documents","length","checkpoint","push","persistToMaster","replicationHandler","streamQueue","processTasks","openTasks","sub","changeStream","pipe","eventBulk","context","downstreamBulkWriteFlag","subscribe","forkChangeStreamEmit","task","time","waitBeforePersist","unsubscribe","active","docs","taskWithTime","shift","concat","map","change","operation","ret","previous","_deleted","doc","promise","persistenceQueue","nonPersistedFromMaster","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","assumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","isEqual","assumedMasterDoc","undefined","newDocumentState","metaDocument","fullDocData","isResolvedConflict","_rev","conflictHandler","realMasterState","masterWrite","values","masterWriteResult","hadConflictWrites","conflictIds","size","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","conflictsById","writeToMasterRow","resolved","resolvedConflicts","output","document","resolvedDoc","persistToMasterConflictWrites","bulkWrite","forkWriteResult","useMetaWrites","success","metaInstance","Set","conflictDoc","id","add","useWriteRowsToMeta","has","processed","unhandledError","error"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types';\nimport {\n    ensureNotFalsy,\n    flatClone,\n    PROMISE_RESOLVE_FALSE\n} from '../util';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint';\nimport { resolveConflictError } from './conflicts';\nimport { writeDocToDocState } from './helper';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For inital replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    const sub = state.input.forkInstance.changeStream()\n        .pipe(\n            filter(eventBulk => eventBulk.context !== state.downstreamBulkWriteFlag)\n        ).subscribe(eventBulk => {\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n            const upResult = await state.input.forkInstance.getChangedDocumentsSince(\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            promises.push(\n                persistToMaster(\n                    upResult.documents,\n                    ensureNotFalsy(lastCheckpoint)\n                )\n            );\n        }\n\n        /**\n         * If we had conflicts during the inital sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upastream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (!state.firstSyncDone.up.getValue()) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(() => {\n            /**\n             * Merge/filter all open tasks\n             */\n            let docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType = {} as any;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                /**\n                 * If the task came in before the last time the inital sync fetching\n                 * has run, we can ignore the task because the inital sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    continue;\n                }\n\n                docs = docs.concat(\n                    taskWithTime.task.events.map(r => {\n                        if (r.change.operation === 'DELETE') {\n                            const ret: any = flatClone(r.change.previous);\n                            ret._deleted = true;\n                            return ret;\n                        } else {\n                            return r.change.doc;\n                        }\n                    })\n                );\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n            }\n\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\n                docs,\n                checkpoint\n            );\n            return promise.then(() => {\n                if (openTasks.length === 0) {\n                    state.events.active.up.next(false);\n                } else {\n                    processTasks();\n                }\n            });\n        });\n    }\n\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistend list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n            if (docIds.length === 0) {\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        assumedMasterDoc &&\n                        // if the isResolvedConflict is correct, we do not have to compare the documents.\n                        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev &&\n                        (await state.input.conflictHandler({\n                            realMasterState: assumedMasterDoc.docData,\n                            newDocumentState: docData\n                        }, 'upstream-check-if-equal')).isEqual\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                return false;\n            }\n\n            const masterWriteResult = await replicationHandler.masterWrite(Object.values(writeRowsToMaster));\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n            masterWriteResult.forEach(conflictDoc => {\n                const id = (conflictDoc as any)[state.primaryPath];\n                conflictIds.add(id);\n                conflictsById[id] = conflictDoc;\n            });\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    useWriteRowsToMeta,\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(resolved => {\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved.output\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved.resolvedDoc\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved.resolvedDoc._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n                    /**\n                     * Errors in the forkWriteResult must not be handled\n                     * because they have been caused by a write to the forkInstance\n                     * in between which will anyway trigger a new upstream cycle\n                     * that will then resolved the conflict again.\n                     */\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                    Object\n                        .keys(forkWriteResult.success)\n                        .forEach((docId) => {\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            useMetaWrites,\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parrallel checkpoint writes,\n             * we have to use a queue.\n             */\n            state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(\n                state,\n                'up',\n                useCheckpoint\n            ));\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n\n"],"mappings":"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"}