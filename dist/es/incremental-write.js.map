{"version":3,"file":"incremental-write.js","names":["isBulkWriteConflictError","rxStorageWriteErrorToRxError","clone","ensureNotFalsy","getFromMapOrFill","getFromMapOrThrow","parseRevision","stripMetaDataFromDocument","IncrementalWriteQueue","storageInstance","primaryPath","preWrite","postWrite","queueByDocId","Map","isRunning","addWrite","lastKnownDocumentState","modifier","docId","ar","ret","Promise","resolve","reject","item","push","triggerRun","size","writeRows","itemsById","all","Array","from","entries","map","_docId","items","oldData","findNewestOfDocumentStates","i","newData","forEach","previous","document","length","bulkWrite","error","success","writeResult","Object","result","isConflict","reverse","documentInDb","unshift","rxError","modifierFromPublicToInternal","publicModifier","docData","withoutMeta","_deleted","modified","reattachedMeta","assign","_meta","_attachments","_rev","docs","newest","newestRevisionHeight","height","doc"],"sources":["../../src/incremental-write.ts"],"sourcesContent":["import {\n    isBulkWriteConflictError,\n    rxStorageWriteErrorToRxError\n} from './rx-error';\nimport type {\n    ModifyFunction,\n    BulkWriteRow,\n    MaybePromise,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxError,\n    RxStorageBulkWriteResponse,\n    RxStorageInstance,\n    StringKeys,\n    WithDeleted\n} from './types';\nimport {\n    clone,\n    ensureNotFalsy,\n    getFromMapOrFill,\n    getFromMapOrThrow,\n    parseRevision,\n    stripMetaDataFromDocument\n} from './util';\n\n\n\nexport type IncrementalWriteModifier<RxDocType> = (\n    doc: RxDocumentData<RxDocType>\n) => MaybePromise<RxDocumentData<RxDocType>> | MaybePromise<RxDocumentWriteData<RxDocType>>;\n\n\ntype IncrementalWriteQueueItem<RxDocType> = {\n    lastKnownDocumentState: RxDocumentData<RxDocType>;\n    modifier: IncrementalWriteModifier<RxDocType>;\n    resolve: (d: RxDocumentData<RxDocType>) => void;\n    reject: (error: RxError) => void;\n};\n\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport class IncrementalWriteQueue<RxDocType> {\n    public queueByDocId = new Map<string, IncrementalWriteQueueItem<RxDocType>[]>();\n    public isRunning: boolean = false;\n\n    constructor(\n        public readonly storageInstance: RxStorageInstance<RxDocType, any, any>,\n        public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>,\n        // can be used to run hooks etc.\n        public readonly preWrite: (newData: RxDocumentData<RxDocType>, oldData: RxDocumentData<RxDocType>) => MaybePromise<void>,\n        public readonly postWrite: (docData: RxDocumentData<RxDocType>) => void\n\n    ) { }\n\n    addWrite(\n        lastKnownDocumentState: RxDocumentData<RxDocType>,\n        modifier: IncrementalWriteModifier<RxDocType>\n    ): Promise<RxDocumentData<RxDocType>> {\n        const docId: string = lastKnownDocumentState[this.primaryPath] as any;\n        const ar = getFromMapOrFill(this.queueByDocId, docId, () => []);\n        const ret = new Promise<RxDocumentData<RxDocType>>((resolve, reject) => {\n            const item: IncrementalWriteQueueItem<RxDocType> = {\n                lastKnownDocumentState,\n                modifier,\n                resolve,\n                reject\n            };\n            ensureNotFalsy(ar).push(item);\n            this.triggerRun();\n        });\n        return ret;\n    }\n\n    async triggerRun(): Promise<void> {\n        if (\n            this.isRunning === true ||\n            this.queueByDocId.size === 0\n        ) {\n            // already running\n            return;\n        }\n        this.isRunning = true;\n        const writeRows: BulkWriteRow<RxDocType>[] = [];\n\n        /**\n         * 'take over' so that while the async functions runs,\n         * new incremental updates could be added from the outside.\n         */\n        const itemsById = this.queueByDocId;\n        this.queueByDocId = new Map();\n        await Promise.all(\n            Array.from(itemsById.entries())\n                .map(async ([_docId, items]) => {\n                    const oldData = findNewestOfDocumentStates(\n                        items.map(i => i.lastKnownDocumentState)\n                    );\n                    let newData = oldData;\n                    for (const item of items) {\n                        try {\n                            newData = await item.modifier(\n                                /**\n                                 * We have to clone() each time because the modifier\n                                 * might throw while it already changed some properties\n                                 * of the document.\n                                 */\n                                clone(newData)\n                            ) as any;\n                        } catch (err: any) {\n                            item.reject(err);\n                            item.reject = () => { };\n                            item.resolve = () => { };\n                        }\n                    }\n\n                    try {\n                        await this.preWrite(newData, oldData);\n                    } catch (err: any) {\n                        /**\n                         * If the before-hooks fail,\n                         * we reject all of the writes because it is\n                         * not possible to determine which one is to blame.\n                         */\n                        items.forEach(item => item.reject(err));\n                        return;\n                    }\n                    writeRows.push({\n                        previous: oldData,\n                        document: newData\n                    });\n                })\n        );\n        const writeResult: RxStorageBulkWriteResponse<RxDocType> = writeRows.length > 0 ?\n            await this.storageInstance.bulkWrite(writeRows, 'incremental-write') :\n            { error: {}, success: {} };\n\n        // process success\n        await Promise.all(\n            Array\n                .from(Object.entries(writeResult.success))\n                .map(([docId, result]) => {\n                    this.postWrite(result);\n                    const items = getFromMapOrThrow(itemsById, docId);\n                    items.forEach(item => item.resolve(result));\n                })\n        );\n\n        // process errors\n        Array\n            .from(Object.entries(writeResult.error))\n            .forEach(([docId, error]) => {\n                const items = getFromMapOrThrow(itemsById, docId);\n                const isConflict = isBulkWriteConflictError<RxDocType>(error);\n                if (isConflict) {\n                    // had conflict -> retry afterwards\n                    const ar = getFromMapOrFill(this.queueByDocId, docId, () => []);\n                    /**\n                     * Add the items back to this.queueByDocId\n                     * by maintaining the original order.\n                     */\n                    items\n                        .reverse()\n                        .forEach(item => {\n                            item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n                            ensureNotFalsy(ar).unshift(item);\n                        });\n                } else {\n                    // other error -> must be thrown\n                    const rxError = rxStorageWriteErrorToRxError(error);\n                    items.forEach(item => item.reject(rxError));\n                }\n            });\n        this.isRunning = false;\n\n        /**\n         * Always trigger another run\n         * because in between there might be new items\n         * been added to the queue.\n         */\n        return this.triggerRun();\n    }\n}\n\n\nexport function modifierFromPublicToInternal<RxDocType>(\n    publicModifier: ModifyFunction<RxDocType>\n): IncrementalWriteModifier<RxDocType> {\n    const ret = async (docData: RxDocumentData<RxDocType>) => {\n        const withoutMeta: WithDeleted<RxDocType> = stripMetaDataFromDocument(docData) as any;\n        withoutMeta._deleted = docData._deleted;\n        const modified = await publicModifier(withoutMeta);\n        const reattachedMeta: RxDocumentData<RxDocType> = Object.assign({}, modified, {\n            _meta: docData._meta,\n            _attachments: docData._attachments,\n            _rev: docData._rev,\n            _deleted: typeof (modified as WithDeleted<RxDocType>)._deleted !== 'undefined' ?\n                (modified as WithDeleted<RxDocType>)._deleted :\n                docData._deleted\n        });\n        if (typeof reattachedMeta._deleted === 'undefined') {\n            reattachedMeta._deleted = false;\n        }\n        return reattachedMeta;\n    };\n    return ret;\n}\n\n\nexport function findNewestOfDocumentStates<RxDocType>(\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType> {\n\n    let newest = docs[0];\n    let newestRevisionHeight = parseRevision(newest._rev).height;\n    docs.forEach(doc => {\n        const height = parseRevision(doc._rev).height;\n        if (height > newestRevisionHeight) {\n            newest = doc;\n            newestRevisionHeight = height;\n        }\n    });\n    return newest;\n}\n"],"mappings":"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"}