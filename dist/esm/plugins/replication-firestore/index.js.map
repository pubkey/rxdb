{"version":3,"file":"index.js","names":["appendToArray","asyncFilter","ensureNotFalsy","errorToPlainJson","flatClone","lastOfArray","toArray","doc","query","where","orderBy","limit","getDocs","getDoc","onSnapshot","runTransaction","writeBatch","serverTimestamp","waitForPendingWrites","documentId","RxDBLeaderElectionPlugin","RxReplicationState","startReplicationOnLeaderShip","addRxPlugin","getSchemaByObjectPath","newRxError","Subject","firestoreRowToDocData","getContentByIds","isoStringToServerTimestamp","serverTimestampToIsoString","stripPrimaryKey","stripServerTimestampField","RxFirestoreReplicationState","_RxReplicationState","firestore","replicationIdentifierHash","collection","pull","push","live","retryTime","autoStart","_this","call","_inheritsLoose","replicateFirestore","options","pullStream$","replicationPrimitivesPull","waitForLeadership","serverTimestampField","primaryPath","schema","schemaPart","jsonSchema","includes","field","pullFilters","filter","undefined","pullQuery","handler","lastPulledCheckpoint","batchSize","newerQuery","sameTimeQuery","lastServerTimestamp","id","mustsReRun","useDocs","database","_tx","newerQueryResult","sameTimeQueryResult","Promise","all","metadata","hasPendingWrites","docs","missingAmount","length","additionalDocs","slice","x","checkpoint","documents","lastDoc","map","row","newCheckpoint","data","ret","modifier","stream$","asObservable","initialCheckpoint","replicationPrimitivesPush","pushFilter","rows","newDocumentState","writeRowsById","docIds","docId","conflicts","getQuery","ids","then","result","catch","error","code","exists","docsInDbResult","docsInDbById","forEach","docDataInDb","batch","hasWrite","Object","entries","writeRow","docInDb","assumedMasterState","conflictHandler","isEqual","docRef","writeDocData","set","update","commit","replicationState","replicationIdentifier","startBefore","start","bind","cancelBefore","cancel","lastChangeQuery","unsubscribe","_querySnapshot","reSync","subjects","next"],"sources":["../../../../src/plugins/replication-firestore/index.ts"],"sourcesContent":["import {\n    appendToArray,\n    asyncFilter,\n    ensureNotFalsy,\n    errorToPlainJson,\n    flatClone,\n    lastOfArray,\n    toArray\n} from '../../plugins/utils/index.ts';\n\nimport {\n    doc,\n    query,\n    where,\n    orderBy,\n    limit,\n    getDocs,\n    getDoc,\n    onSnapshot,\n    runTransaction,\n    writeBatch,\n    serverTimestamp,\n    QueryDocumentSnapshot,\n    waitForPendingWrites,\n    documentId,\n    FirestoreError\n} from 'firebase/firestore';\n\nimport { RxDBLeaderElectionPlugin } from '../leader-election/index.ts';\nimport type {\n    RxCollection,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxReplicationWriteToMasterRow,\n    RxReplicationPullStreamItem\n} from '../../types/index.d.ts';\nimport {\n    RxReplicationState,\n    startReplicationOnLeaderShip\n} from '../replication/index.ts';\nimport {\n    addRxPlugin,\n    ById,\n    getSchemaByObjectPath,\n    newRxError,\n    WithDeleted\n} from '../../index.ts';\n\nimport type {\n    FirestoreCheckpointType,\n    FirestoreOptions,\n    SyncOptionsFirestore\n} from './firestore-types.ts';\nimport { Subject } from 'rxjs';\nimport {\n    firestoreRowToDocData,\n    getContentByIds,\n    isoStringToServerTimestamp,\n    serverTimestampToIsoString,\n    stripPrimaryKey,\n    stripServerTimestampField\n} from './firestore-helper.ts';\n\nexport * from './firestore-helper.ts';\nexport * from './firestore-types.ts';\n\nexport class RxFirestoreReplicationState<RxDocType> extends RxReplicationState<RxDocType, FirestoreCheckpointType> {\n    constructor(\n        public readonly firestore: FirestoreOptions<RxDocType>,\n        public readonly replicationIdentifierHash: string,\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live: boolean = true,\n        public retryTime: number = 1000 * 5,\n        public autoStart: boolean = true\n    ) {\n        super(\n            replicationIdentifierHash,\n            collection,\n            '_deleted',\n            pull,\n            push,\n            live,\n            retryTime,\n            autoStart\n        );\n    }\n}\n\nexport function replicateFirestore<RxDocType>(\n    options: SyncOptionsFirestore<RxDocType>\n): RxFirestoreReplicationState<RxDocType> {\n    const collection: RxCollection<RxDocType, any, any> = options.collection;\n    addRxPlugin(RxDBLeaderElectionPlugin);\n    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, FirestoreCheckpointType>> = new Subject();\n    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined;\n    options.live = typeof options.live === 'undefined' ? true : options.live;\n    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;\n    const serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;\n    options.serverTimestampField = serverTimestampField;\n    const primaryPath = collection.schema.primaryPath;\n\n    /**\n     * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.\n     */\n    const schemaPart = getSchemaByObjectPath(collection.schema.jsonSchema, serverTimestampField);\n    if (\n        schemaPart ||\n        // also must not be nested.\n        serverTimestampField.includes('.')\n    ) {\n        throw newRxError('RC6', {\n            field: serverTimestampField,\n            schema: collection.schema.jsonSchema\n        });\n    }\n\n    const pullFilters = options.pull?.filter !== undefined\n        ? toArray(options.pull.filter)\n        : [];\n\n    const pullQuery = query(options.firestore.collection, ...pullFilters);\n\n    if (options.pull) {\n        replicationPrimitivesPull = {\n            async handler(\n                lastPulledCheckpoint: FirestoreCheckpointType | undefined,\n                batchSize: number\n            ) {\n                let newerQuery: ReturnType<typeof query>;\n                let sameTimeQuery: ReturnType<typeof query> | undefined;\n\n                if (lastPulledCheckpoint) {\n                    const lastServerTimestamp = isoStringToServerTimestamp(lastPulledCheckpoint.serverTimestamp);\n                    newerQuery = query(pullQuery,\n                        where(serverTimestampField, '>', lastServerTimestamp),\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                    sameTimeQuery = query(pullQuery,\n                        where(serverTimestampField, '==', lastServerTimestamp),\n                        where(documentId(), '>', lastPulledCheckpoint.id),\n                        orderBy(documentId(), 'asc'),\n                        limit(batchSize)\n                    );\n                } else {\n                    newerQuery = query(pullQuery,\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                }\n\n                let mustsReRun = true;\n                let useDocs: QueryDocumentSnapshot<RxDocType>[] = [];\n                while (mustsReRun) {\n                    /**\n                     * Local writes that have not been persisted to the server\n                     * are in pending state and do not have a correct serverTimestamp set.\n                     * We have to ensure we only use document states that are in sync with the server.\n                     * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b\n                     */\n                    await waitForPendingWrites(options.firestore.database);\n                    await runTransaction(options.firestore.database, async (_tx) => {\n                        useDocs = [];\n                        const [\n                            newerQueryResult,\n                            sameTimeQueryResult\n                        ] = await Promise.all([\n                            getDocs(newerQuery),\n                            sameTimeQuery ? getDocs(sameTimeQuery) : undefined\n                        ]);\n\n                        if (\n                            newerQueryResult.metadata.hasPendingWrites ||\n                            (sameTimeQuery && ensureNotFalsy(sameTimeQueryResult).metadata.hasPendingWrites)\n                        ) {\n                            return;\n                        } else {\n                            mustsReRun = false;\n\n                            if (sameTimeQuery) {\n                                useDocs = ensureNotFalsy(sameTimeQueryResult).docs as any;\n                            }\n                            const missingAmount = batchSize - useDocs.length;\n                            if (missingAmount > 0) {\n                                const additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);\n                                appendToArray(useDocs, additionalDocs);\n                            }\n                        }\n                    });\n                }\n\n                if (useDocs.length === 0) {\n                    return {\n                        checkpoint: lastPulledCheckpoint ?? undefined,\n                        documents: []\n                    };\n                }\n                const lastDoc = ensureNotFalsy(lastOfArray(useDocs));\n                const documents: WithDeleted<RxDocType>[] = useDocs\n                    .map(row => firestoreRowToDocData(\n                        serverTimestampField,\n                        primaryPath,\n                        row\n                    ));\n                const newCheckpoint: FirestoreCheckpointType = {\n                    id: lastDoc.id,\n                    serverTimestamp: serverTimestampToIsoString(serverTimestampField, lastDoc.data())\n                };\n                const ret = {\n                    documents: documents,\n                    checkpoint: newCheckpoint\n                };\n                return ret;\n            },\n            batchSize: ensureNotFalsy(options.pull).batchSize,\n            modifier: ensureNotFalsy(options.pull).modifier,\n            stream$: pullStream$.asObservable(),\n            initialCheckpoint: options.pull.initialCheckpoint\n        };\n    }\n\n    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;\n    if (options.push) {\n        const pushFilter = options.push?.filter;\n        replicationPrimitivesPush = {\n            async handler(\n                rows: RxReplicationWriteToMasterRow<RxDocType>[]\n            ) {\n                if (pushFilter !== undefined) {\n                    rows = await asyncFilter(rows, (row) => pushFilter(row.newDocumentState));\n                }\n\n                const writeRowsById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n                const docIds: string[] = rows.map(row => {\n                    const docId = (row.newDocumentState as any)[primaryPath];\n                    writeRowsById[docId] = row;\n                    return docId;\n                });\n                await waitForPendingWrites(options.firestore.database);\n                let conflicts: WithDeleted<RxDocType>[] = [];\n\n                /**\n                 * Everything must run INSIDE of the transaction\n                 * because on tx-errors, firebase will re-run the transaction on some cases.\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions\n                 */\n                await runTransaction(options.firestore.database, async (_tx) => {\n                    conflicts = []; // reset in case the tx has re-run.\n                    /**\n                     * @link https://stackoverflow.com/a/48423626/3443137\n                     */\n\n                    const getQuery = (ids: string[]) => {\n                        return getDocs(\n                            query(\n                                options.firestore.collection,\n                                where(documentId(), 'in', ids)\n                            )\n                        )\n                        .then(result => result.docs)\n                        .catch(error => {\n                            if (error?.code && (error as FirestoreError).code === 'permission-denied') {\n                                // Query may fail due to rules using 'resource' with non existing ids\n                                // So try to get the docs one by one\n                                return Promise.all(\n                                    ids.map(\n                                        id => getDoc(doc(options.firestore.collection, id))\n                                    )\n                                )\n                                .then(docs => docs.filter(doc => doc.exists()));\n                            }\n                            throw error;\n                        });\n                    };\n\n                    const docsInDbResult = await getContentByIds<RxDocType>(docIds, getQuery);\n\n                    const docsInDbById: ById<RxDocType> = {};\n                    docsInDbResult.forEach(row => {\n                        const docDataInDb = stripServerTimestampField(serverTimestampField, row.data());\n                        const docId = row.id;\n                        (docDataInDb as any)[primaryPath] = docId;\n                        docsInDbById[docId] = docDataInDb;\n                    });\n\n                    /**\n                     * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes\n                     */\n                    const batch = writeBatch(options.firestore.database);\n                    let hasWrite = false;\n                    await Promise.all(\n                        Object.entries(writeRowsById).map(async ([docId, writeRow]) => {\n                            const docInDb: RxDocType | undefined = docsInDbById[docId];\n\n                            if (\n                                docInDb &&\n                                (\n                                    !writeRow.assumedMasterState ||\n                                    collection.conflictHandler.isEqual(docInDb as any, writeRow.assumedMasterState, 'replication-firestore-push') === false\n                                )\n                            ) {\n                                // conflict\n                                conflicts.push(docInDb as any);\n                            } else {\n                                // no conflict\n                                hasWrite = true;\n                                const docRef = doc(options.firestore.collection, docId);\n                                const writeDocData = flatClone(writeRow.newDocumentState);\n                                (writeDocData as any)[serverTimestampField] = serverTimestamp();\n                                if (!docInDb) {\n                                    // insert\n                                    batch.set(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                } else {\n                                    // update\n                                    batch.update(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                }\n                            }\n                        })\n                    );\n\n                    if (hasWrite) {\n                        await batch.commit();\n                    }\n                });\n                await waitForPendingWrites(options.firestore.database);\n                return conflicts;\n            },\n            batchSize: options.push.batchSize,\n            modifier: options.push.modifier\n        };\n    }\n\n\n    const replicationState = new RxFirestoreReplicationState<RxDocType>(\n        options.firestore,\n        options.replicationIdentifier,\n        collection,\n        replicationPrimitivesPull,\n        replicationPrimitivesPush,\n        options.live,\n        options.retryTime,\n        options.autoStart\n    );\n\n    /**\n     * Use long polling to get live changes for the pull.stream$\n     */\n    if (options.live && options.pull) {\n        const startBefore = replicationState.start.bind(replicationState);\n        const cancelBefore = replicationState.cancel.bind(replicationState);\n        replicationState.start = () => {\n            const lastChangeQuery = query(\n                pullQuery,\n                orderBy(serverTimestampField, 'desc'),\n                limit(1)\n            );\n            const unsubscribe = onSnapshot(\n                lastChangeQuery,\n                (_querySnapshot) => {\n                    /**\n                     * There is no good way to observe the event stream in firestore.\n                     * So instead we listen to any write to the collection\n                     * and then emit a 'RESYNC' flag.\n                     */\n                    replicationState.reSync();\n                },\n                (error) => {\n                    replicationState.subjects.error.next(\n                        newRxError('RC_STREAM', { error: errorToPlainJson(error) })\n                    );\n                }\n            );\n            replicationState.cancel = () => {\n                unsubscribe();\n                return cancelBefore();\n            };\n            return startBefore();\n        };\n    }\n\n    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);\n\n    return replicationState;\n}\n"],"mappings":"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","ignoreList":[]}