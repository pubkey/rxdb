{"version":3,"file":"storage-remote-types.js","names":[],"sources":["../../../../src/plugins/storage-remote/storage-remote-types.ts"],"sourcesContent":["import type { Observable } from 'rxjs';\nimport type {\n    MaybePromise,\n    PlainJsonError,\n    RxDatabase,\n    RxStorage,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from '../../types/index.d.ts';\n\n\n\nexport type MessageFromRemote = {\n    connectionId: string;\n    answerTo: string; // id of the request\n    method: keyof RxStorageInstance<any, any, any> | 'create' | 'custom';\n    error?: PlainJsonError;\n    return?: any | string;\n};\n\nexport type MessageToRemote = {\n    connectionId: string;\n    /**\n     * Unique ID of the request\n     */\n    requestId: string;\n    method: keyof RxStorageInstance<any, any, any> | 'create' | 'custom';\n    /**\n     * We send the RxDB version to the remote\n     * to ensure we are communicating with an RxDB instance\n     * of the same version. This is to prevent bugs\n     * when people forget to rebuild their workers.\n     */\n    version: string;\n    params:\n    RxStorageInstanceCreationParams<any, any> | // used in the create call\n    any[] | // used to call RxStorageInstance methods\n    any; // used in custom requests\n};\n\n\n/**\n * A message channel represents a single\n * channel that is able to communicate with the remote.\n * For example a single websocket connection or WebWorker instance.\n * The storage must be able to open and close MessageChannels\n * according to the modes settings.\n */\nexport type RemoteMessageChannel = {\n    send(msg: MessageToRemote): void;\n    messages$: Observable<MessageFromRemote>;\n    close(): Promise<void>;\n};\n\nexport type RxStorageRemoteSettings = {\n    identifier: string;\n    /**\n     * There are different modes\n     * that determine how many message channels are used.\n     * These modes can have different performance patterns.\n     *\n     * [default='storage']\n     */\n    mode?:\n    // create exactly one RemoteMessageChannel and reuse that everywhere.\n    | 'one'\n    // storage: create one RemoteMessageChannel per call to getRxStorage...()\n    | 'storage'\n    // database: create one RemoteMessageChannel for each database\n    | 'database'\n    // collection: create one RemoteMessageChannel for each collection\n    | 'collection';\n    messageChannelCreator: () => Promise<RemoteMessageChannel>;\n};\n\nexport type RxStorageRemoteInternals = {\n    params: RxStorageInstanceCreationParams<any, any>;\n    connectionId: string;\n    messageChannel: RemoteMessageChannel;\n};\n\nexport type RxStorageRemoteExposeSettingsBase = {\n    send(msg: MessageFromRemote): void;\n    messages$: Observable<MessageToRemote>;\n    customRequestHandler?: CustomRequestHandler<any, any>;\n    /**\n     * Used in tests to simulate what happens if the remote\n     * was build on a different RxDB version.\n     */\n    fakeVersion?: string;\n};\n\nexport type RxStorageRemoteExposeSettingsRxDatabase = RxStorageRemoteExposeSettingsBase & {\n    /**\n     * The database which must be mapped to the remote storage server.\n     */\n    database: RxDatabase;\n};\n\nexport type RxStorageRemoteExposeSettingsRxStorage = RxStorageRemoteExposeSettingsBase & {\n    /**\n     * The original storage\n     * which actually stores the data.\n     */\n    storage: RxStorage<any, any>;\n};\n\nexport type RxStorageRemoteExposeSettings = RxStorageRemoteExposeSettingsRxDatabase | RxStorageRemoteExposeSettingsRxStorage;\n\nexport type RxStorageRemoteExposeType = {\n    instanceByFullName: Map<string, any>;\n};\n\n/**\n * If set, the clients can send RxDB-unrelated custom messages\n * to the remote storage and it will  answer them.\n */\nexport type CustomRequestHandler<In, Out> = (data: In) => MaybePromise<Out>;\n"],"mappings":"","ignoreList":[]}