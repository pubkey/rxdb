{"version":3,"file":"dexie-query.js","names":["INDEX_MIN","getQueryMatcher","getSortComparator","dexieReplaceIfStartsWithPipe","DEXIE_DOCS_TABLE_NAME","fromDexieToStorage","mapKeyForKeyRange","k","Infinity","getKeyRangeByQueryPlan","queryPlan","IDBKeyRange","window","Error","startKeys","map","endKeys","ret","index","length","equalKeys","bound","inclusiveStart","inclusiveEnd","dexieQuery","instance","preparedQuery","state","internals","query","skip","limit","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","schema","keyRange","dexieDb","_options","queryPlanFields","rows","transaction","dexieTable","dexieTx","tx","idbtrans","store","objectStore","primaryPath","indexName","field","join","cursorReq","openCursor","Promise","res","onsuccess","e","cursor","target","result","docData","value","_deleted","push","sortFieldsSameAsIndexFields","continue","sortComparator","sort","slice","documents","dexieCount","count","request","rej","onerror","err"],"sources":["../../../../src/plugins/storage-dexie/dexie-query.ts"],"sourcesContent":["import { INDEX_MIN } from '../../query-planner.ts';\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper.ts';\nimport type {\n    DefaultPreparedQuery,\n    QueryMatcher,\n    RxDocumentData,\n    RxQueryPlan,\n    RxStorageQueryResult\n} from '../../types/index.d.ts';\nimport {\n    dexieReplaceIfStartsWithPipe,\n    DEXIE_DOCS_TABLE_NAME,\n    fromDexieToStorage\n} from './dexie-helper.ts';\nimport type { RxStorageInstanceDexie } from './rx-storage-instance-dexie.ts';\n\nexport function mapKeyForKeyRange(k: any) {\n    if (k === INDEX_MIN) {\n        return -Infinity;\n    } else {\n        return k;\n    }\n}\n\nexport function getKeyRangeByQueryPlan(\n    queryPlan: RxQueryPlan,\n    IDBKeyRange?: any\n) {\n    if (!IDBKeyRange) {\n        if (typeof window === 'undefined') {\n            throw new Error('IDBKeyRange missing');\n        } else {\n            IDBKeyRange = window.IDBKeyRange;\n        }\n    }\n\n    const startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);\n    const endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);\n\n    let ret: any;\n    /**\n     * If index has only one field,\n     * we have to pass the keys directly, not the key arrays.\n     */\n    if (queryPlan.index.length === 1) {\n        const equalKeys = startKeys[0] === endKeys[0];\n        ret = IDBKeyRange.bound(\n            startKeys[0],\n            endKeys[0],\n            equalKeys ? false : !queryPlan.inclusiveStart,\n            equalKeys ? false : !queryPlan.inclusiveEnd\n        );\n    } else {\n        ret = IDBKeyRange.bound(\n            startKeys,\n            endKeys,\n            !queryPlan.inclusiveStart,\n            !queryPlan.inclusiveEnd\n        );\n    }\n    return ret;\n}\n\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nexport async function dexieQuery<RxDocType>(\n    instance: RxStorageInstanceDexie<RxDocType>,\n    preparedQuery: DefaultPreparedQuery<RxDocType>\n): Promise<RxStorageQueryResult<RxDocType>> {\n    const state = await instance.internals;\n    const query = preparedQuery.query;\n\n    const skip = query.skip ? query.skip : 0;\n    const limit = query.limit ? query.limit : Infinity;\n    const skipPlusLimit = skip + limit;\n    const queryPlan = preparedQuery.queryPlan;\n\n    let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n    if (!queryPlan.selectorSatisfiedByIndex) {\n        queryMatcher = getQueryMatcher(\n            instance.schema,\n            preparedQuery.query\n        );\n    }\n    const keyRange = getKeyRangeByQueryPlan(\n        queryPlan,\n        (state.dexieDb as any)._options.IDBKeyRange\n    );\n\n    const queryPlanFields: string[] = queryPlan.index;\n\n    let rows: any[] = [];\n    await state.dexieDb.transaction(\n        'r',\n        state.dexieTable,\n        async (dexieTx) => {\n            /**\n             * TODO here we use the native IndexedDB transaction\n             * to get the cursor.\n             * Instead we should not leave Dexie.js API and find\n             * a way to create the cursor with Dexie.js.\n             */\n            const tx = (dexieTx as any).idbtrans;\n\n            // const nativeIndexedDB = state.dexieDb.backendDB();\n            // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n            let index: any;\n            if (\n                queryPlanFields.length === 1 &&\n                queryPlanFields[0] === instance.primaryPath\n            ) {\n                index = store;\n            } else {\n                let indexName: string;\n                if (queryPlanFields.length === 1) {\n                    indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n                } else {\n                    indexName = '[' +\n                        queryPlanFields\n                            .map(field => dexieReplaceIfStartsWithPipe(field))\n                            .join('+')\n                        + ']';\n                }\n                index = store.index(indexName);\n            }\n            const cursorReq = index.openCursor(keyRange);\n            await new Promise<void>(res => {\n                cursorReq.onsuccess = function (e: any) {\n                    const cursor = e.target.result;\n                    if (cursor) {\n                        // We have a record in cursor.value\n                        const docData = fromDexieToStorage(cursor.value);\n                        if (\n                            !docData._deleted &&\n                            (!queryMatcher || queryMatcher(docData))\n                        ) {\n                            rows.push(docData);\n                        }\n\n                        /**\n                         * If we do not have to manually sort\n                         * and have enough documents,\n                         * we can abort iterating over the cursor\n                         * because we already have every relevant document.\n                         */\n                        if (\n                            queryPlan.sortFieldsSameAsIndexFields &&\n                            rows.length === skipPlusLimit\n                        ) {\n                            res();\n                        } else {\n                            cursor.continue();\n                        }\n                    } else {\n                        // Iteration complete\n                        res();\n                    }\n                };\n            });\n\n\n        }\n    );\n\n\n    if (!queryPlan.sortFieldsSameAsIndexFields) {\n        const sortComparator = getSortComparator(instance.schema, preparedQuery.query);\n        rows = rows.sort(sortComparator);\n    }\n\n    // apply skip and limit boundaries.\n    rows = rows.slice(skip, skipPlusLimit);\n\n    /**\n     * Comment this in for debugging to check all fields in the database.\n     */\n    // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n    // let documents = docsInDb\n    //     .map(docData => stripDexieKey(docData))\n    //     .sort(sortComparator);\n    // if (preparedQuery.skip) {\n    //     documents = documents.slice(preparedQuery.skip);\n    // }\n    // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n    //     documents = documents.slice(0, preparedQuery.limit);\n    // }\n\n\n\n    return {\n        documents: rows\n    };\n}\n\n\nexport async function dexieCount<RxDocType>(\n    instance: RxStorageInstanceDexie<RxDocType>,\n    preparedQuery: DefaultPreparedQuery<RxDocType>\n): Promise<number> {\n    const state = await instance.internals;\n    const queryPlan = preparedQuery.queryPlan;\n    const queryPlanFields: string[] = queryPlan.index;\n\n    const keyRange = getKeyRangeByQueryPlan(\n        queryPlan,\n        (state.dexieDb as any)._options.IDBKeyRange\n    );\n    let count: number = -1;\n    await state.dexieDb.transaction(\n        'r',\n        state.dexieTable,\n        async (dexieTx) => {\n            const tx = (dexieTx as any).idbtrans;\n            const store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n            let index: any;\n            if (\n                queryPlanFields.length === 1 &&\n                queryPlanFields[0] === instance.primaryPath\n            ) {\n                index = store;\n            } else {\n                let indexName: string;\n                if (queryPlanFields.length === 1) {\n                    indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n                } else {\n                    indexName = '[' +\n                        queryPlanFields\n                            .map(field => dexieReplaceIfStartsWithPipe(field))\n                            .join('+')\n                        + ']';\n                }\n                index = store.index(indexName);\n            }\n\n            const request = index.count(keyRange);\n            count = await new Promise<number>((res, rej) => {\n                request.onsuccess = function () {\n                    res(request.result);\n                };\n                request.onerror = (err: any) => rej(err);\n            });\n        }\n    );\n    return count;\n}\n"],"mappings":"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"}