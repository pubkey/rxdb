{"version":3,"file":"rx-storage-instance-mongodb.js","names":["BehaviorSubject","Subject","filter","firstValueFrom","getPrimaryFieldOfPrimaryKey","ensureNotFalsy","getFromMapOrThrow","isMaybeReadonlyArray","now","PROMISE_RESOLVE_VOID","requestIdlePromise","MongoClient","categorizeBulkWriteRows","MONGO_ID_SUBSTITUTE_FIELDNAME","getMongoDBIndexName","prepareMongoDBQuery","swapMongoToRxDoc","swapRxDocToMongo","RXDB_VERSION","RxStorageInstanceMongoDB","storage","databaseName","collectionName","schema","internals","options","settings","changes$","runningOperations","writeQueue","mongoObjectIdCache","WeakMap","attachments","Error","primaryPath","primaryKey","inMongoPrimaryPath","mongoOptions","driverInfo","name","version","mongoClient","databaseSettings","connection","mongoDatabase","db","indexes","slice","map","index","arIndex","push","mongoCollectionPromise","createCollection","then","mongoCollection","createIndexes","mongoIndex","forEach","field","key","_proto","prototype","bulkWrite","documentWrites","context","next","getValue","closed","Promise","reject","ret","error","docIds","d","document","documentStates","findDocumentsById","documentStatesMap","Map","doc","docId","set","categorized","changeByDocId","eventBulk","events","change","documentId","errors","all","bulkInsertDocs","writeRow","writeResult","findOneAndUpdate","$setOnInsert","upsert","includeResultMetadata","value","conflictError","status","documentInDb","isError","event","get","bulkUpdateDocs","findOneAndReplace","_rev","previous","returnDocument","ok","currentDocState","currentDoc","length","lastState","newestRow","checkpoint","id","lwt","_meta","withDeleted","session","plainQuery","$in","_deleted","result","queryResult","find","toArray","row","query","originalPreparedQuery","preparedQuery","mongoSelector","skip","limit","sort","mongoSort","resultDocs","documents","count","countDocuments","mode","cleanup","minimumDeletedTime","maxDeletionTime","deleteMany","$lt","getAttachmentData","_documentId","_attachmentId","_digest","changeStream","remove","drop","close","pipe","c","createMongoDBStorageInstance","params","instance","resolve"],"sources":["../../../../src/plugins/storage-mongodb/rx-storage-instance-mongodb.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    Observable,\n    Subject,\n    filter,\n    firstValueFrom\n} from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PreparedQuery,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    RxStorageWriteErrorConflict,\n    StringKeys\n} from '../../types/index.d.ts';\nimport {\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    isMaybeReadonlyArray,\n    now,\n    PROMISE_RESOLVE_VOID,\n    requestIdlePromise\n} from '../../plugins/utils/index.ts';\nimport {\n    MongoDBStorageInternals,\n    MongoQuerySelector,\n    RxStorageMongoDBInstanceCreationOptions,\n    RxStorageMongoDBSettings\n} from './mongodb-types.ts';\nimport { RxStorageMongoDB } from './rx-storage-mongodb.ts';\nimport {\n    Db as MongoDatabase,\n    Collection as MongoCollection,\n    MongoClient,\n    ObjectId,\n    ClientSession\n} from 'mongodb';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper.ts';\nimport {\n    MONGO_ID_SUBSTITUTE_FIELDNAME,\n    getMongoDBIndexName,\n    prepareMongoDBQuery,\n    swapMongoToRxDoc,\n    swapRxDocToMongo\n} from './mongodb-helper.ts';\nimport { RXDB_VERSION } from '../utils/utils-rxdb-version.ts';\n\nexport class RxStorageInstanceMongoDB<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MongoDBStorageInternals,\n    RxStorageMongoDBInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public readonly inMongoPrimaryPath: string;\n    public closed?: Promise<void>;\n    private readonly changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public readonly mongoClient: MongoClient;\n    public readonly mongoDatabase: MongoDatabase;\n    public readonly mongoCollectionPromise: Promise<MongoCollection<RxDocumentData<RxDocType> | any>>;\n    // public mongoChangeStream?: MongoChangeStream<any, ChangeStreamDocument<any>>;\n\n\n    /**\n     * Closing the connection must not happen when\n     * an operation is running, otherwise we get an error.\n     * So we store all running operations here so that\n     * they can be awaited.\n     */\n    public readonly runningOperations = new BehaviorSubject(0);\n    public writeQueue: Promise<any> = PROMISE_RESOLVE_VOID;\n\n    /**\n     * We use this to be able to still fetch\n     * the objectId after transforming the document from mongo-style (with _id)\n     * to RxDB\n     */\n    public readonly mongoObjectIdCache = new WeakMap<RxDocumentData<RxDocType>, ObjectId>();\n\n    constructor(\n        public readonly storage: RxStorageMongoDB,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MongoDBStorageInternals,\n        public readonly options: Readonly<RxStorageMongoDBInstanceCreationOptions>,\n        public readonly settings: RxStorageMongoDBSettings\n    ) {\n        if (this.schema.attachments) {\n            throw new Error('attachments not supported in mongodb storage, make a PR if you need that');\n        }\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n        this.inMongoPrimaryPath = this.primaryPath === '_id' ? MONGO_ID_SUBSTITUTE_FIELDNAME : this.primaryPath;\n        \n        const mongoOptions: any = {};\n        mongoOptions.driverInfo = {\n            name: 'RxDB',\n            version: RXDB_VERSION\n        };\n        this.mongoClient = new MongoClient(storage.databaseSettings.connection, mongoOptions);\n        this.mongoDatabase = this.mongoClient.db(databaseName + '-v' + this.schema.version);\n\n        const indexes = (this.schema.indexes ? this.schema.indexes.slice() : []).map(index => {\n            const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n            return arIndex;\n        });\n        indexes.push([this.inMongoPrimaryPath]);\n\n        this.mongoCollectionPromise = this.mongoDatabase.createCollection(collectionName)\n            .then(async (mongoCollection) => {\n                await mongoCollection.createIndexes(\n                    indexes.map(index => {\n                        const mongoIndex: any = {};\n                        index.forEach(field => mongoIndex[field] = 1);\n                        return { name: getMongoDBIndexName(index), key: mongoIndex };\n                    })\n                );\n\n                /**\n                 * TODO in a setup where multiple servers run node.js\n                 * processes that use the mongodb storage, we should propagate\n                 * events by listening to the mongodb changestream.\n                 * This maybe should be a premium feature.\n                 */\n                // this.mongoChangeStream = mongoCollection.watch(\n                //     undefined, {\n                //     batchSize: 100\n                // }\n                // ).on('change', change => {\n\n\n                //     const eventBulkId = randomToken(10);\n                //     const newDocData: RxDocumentData<RxDocType> = (change as any).fullDocument;\n                //     const documentId = newDocData[this.primaryPath] as any;\n\n                //     const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint> = {\n                //         checkpoint: {\n                //             id: newDocData[this.primaryPath] as any,\n                //             lwt: newDocData._meta.lwt\n                //         },\n                //         context: 'mongodb-write',\n                //         id: eventBulkId,\n                //         events: [{\n                //             documentData: newDocData,\n                //             documentId,\n                //             operation: 'INSERT',\n                //             previousDocumentData: undefined,\n                //         }],\n                //     };\n\n                //     this.changes$.next(eventBulk);\n                // });\n\n\n                return mongoCollection;\n            });\n\n\n    }\n\n    /**\n     * Bulk writes on the mongodb storage.\n     * Notice that MongoDB does not support cross-document transactions\n     * so we have to do a update-if-previous-is-correct like operations.\n     * (Similar to what RxDB does with the revision system)\n     */\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n\n        this.writeQueue = this.writeQueue.then(async () => {\n            this.runningOperations.next(this.runningOperations.getValue() + 1);\n\n            const mongoCollection = await this.mongoCollectionPromise;\n            if (this.closed) {\n                return Promise.reject(new Error('already closed'));\n            }\n            const primaryPath = this.primaryPath;\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\n                error: []\n            };\n\n\n            const docIds = documentWrites.map(d => (d.document as any)[primaryPath]);\n            const documentStates = await this.findDocumentsById(\n                docIds,\n                true\n            );\n            const documentStatesMap = new Map();\n            documentStates.forEach(doc => {\n                const docId = doc[primaryPath];\n                documentStatesMap.set(docId, doc);\n            });\n            const categorized = categorizeBulkWriteRows<RxDocType>(\n                this,\n                primaryPath as any,\n                documentStatesMap,\n                documentWrites,\n                context\n            );\n\n            const changeByDocId = new Map<string, RxStorageChangeEvent<RxDocumentData<RxDocType>>>();\n            categorized.eventBulk.events.forEach(change => {\n                changeByDocId.set(change.documentId, change);\n            });\n\n\n            ret.error = categorized.errors;\n\n            /**\n             * Reset the event bulk because\n             * conflicts can still appear after the categorization\n             */\n            const eventBulk = categorized.eventBulk;\n            eventBulk.events = [];\n\n            await Promise.all([\n                /**\n                 * Inserts\n                 * @link https://sparkbyexamples.com/mongodb/mongodb-insert-if-not-exists/\n                 */\n                Promise.all(\n                    categorized.bulkInsertDocs.map(async (writeRow) => {\n                        const docId: string = writeRow.document[primaryPath] as any;\n                        const writeResult = await mongoCollection.findOneAndUpdate(\n                            {\n                                [this.inMongoPrimaryPath]: docId\n                            },\n                            {\n                                $setOnInsert: swapRxDocToMongo(writeRow.document)\n                            },\n                            {\n                                upsert: true,\n                                includeResultMetadata: true\n                            }\n                        );\n                        if (writeResult.value) {\n                            // had insert conflict\n                            const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\n                                status: 409,\n                                documentId: docId,\n                                writeRow,\n                                documentInDb: swapMongoToRxDoc(ensureNotFalsy(writeResult.value)),\n                                isError: true\n                            };\n                            ret.error.push(conflictError);\n                        } else {\n                            const event = changeByDocId.get(docId);\n                            if (event) {\n                                eventBulk.events.push(event);\n                            }\n                        }\n                    })\n                ),\n                /**\n                 * Updates\n                 */\n                Promise.all(\n                    categorized.bulkUpdateDocs.map(async (writeRow) => {\n                        const docId = writeRow.document[primaryPath] as string;\n                        const writeResult = await mongoCollection.findOneAndReplace(\n                            {\n                                [this.inMongoPrimaryPath]: docId,\n                                _rev: ensureNotFalsy(writeRow.previous)._rev\n                            },\n                            swapRxDocToMongo(writeRow.document),\n                            {\n                                includeResultMetadata: true,\n                                upsert: false,\n                                returnDocument: 'before'\n                            }\n                        );\n                        if (!writeResult.ok) {\n                            const currentDocState = await this.findDocumentsById([docId], true);\n                            const currentDoc = currentDocState[0];\n                            // had insert conflict\n                            const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\n                                status: 409,\n                                documentId: docId,\n                                writeRow,\n                                documentInDb: ensureNotFalsy(currentDoc),\n                                isError: true\n                            };\n                            ret.error.push(conflictError);\n                        } else {\n                            const event = getFromMapOrThrow(changeByDocId, docId);\n                            eventBulk.events.push(event);\n                        }\n\n                    })\n                )\n            ]);\n\n            if (categorized.eventBulk.events.length > 0) {\n                const lastState = ensureNotFalsy(categorized.newestRow).document;\n                categorized.eventBulk.checkpoint = {\n                    id: lastState[primaryPath],\n                    lwt: lastState._meta.lwt\n                };\n                this.changes$.next(categorized.eventBulk);\n            }\n\n            this.runningOperations.next(this.runningOperations.getValue() - 1);\n            return ret;\n        });\n        return this.writeQueue;\n\n    }\n\n    async findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean,\n        session?: ClientSession\n    ): Promise<RxDocumentData<RxDocType>[]> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const primaryPath = this.primaryPath;\n\n        const plainQuery: MongoQuerySelector<any> = {\n            [primaryPath]: {\n                $in: docIds\n            }\n        };\n        if (!withDeleted) {\n            plainQuery._deleted = false;\n        }\n        const result: RxDocumentData<RxDocType>[] = [];\n        const queryResult = await mongoCollection.find(\n            plainQuery,\n            {\n                session\n            }\n        ).toArray();\n        queryResult.forEach(row => {\n            result.push(\n                swapMongoToRxDoc(\n                    row as any\n                )\n            );\n        });\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return result;\n    }\n\n    async query(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        const preparedQuery = prepareMongoDBQuery(this.schema, originalPreparedQuery.query);\n\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        await this.writeQueue;\n        const mongoCollection = await this.mongoCollectionPromise;\n\n        let query = mongoCollection.find(preparedQuery.mongoSelector);\n        if (preparedQuery.query.skip) {\n            query = query.skip(preparedQuery.query.skip);\n        }\n        if (preparedQuery.query.limit) {\n            query = query.limit(preparedQuery.query.limit);\n        }\n        if (preparedQuery.query.sort) {\n            query = query.sort(preparedQuery.mongoSort);\n        }\n        const resultDocs = await query.toArray();\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return {\n            documents: resultDocs.map(d => swapMongoToRxDoc(d))\n        };\n    }\n\n    async count(\n        originalPreparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const preparedQuery = prepareMongoDBQuery(this.schema, originalPreparedQuery.query);\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        await this.writeQueue;\n        const mongoCollection = await this.mongoCollectionPromise;\n        const count = await mongoCollection.countDocuments(preparedQuery.mongoSelector);\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return {\n            count,\n            mode: 'fast'\n        };\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        const maxDeletionTime = now() - minimumDeletedTime;\n        await mongoCollection.deleteMany({\n            _deleted: true,\n            '_meta.lwt': {\n                $lt: maxDeletionTime\n            }\n        });\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        return true;\n    }\n\n    async getAttachmentData(\n        _documentId: string,\n        _attachmentId: string,\n        _digest: string\n    ): Promise<string> {\n        await this.mongoCollectionPromise;\n        throw new Error('attachments not implemented, make a PR');\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        return this.changes$;\n    }\n\n    async remove(): Promise<void> {\n        if (this.closed) {\n            throw new Error('already closed');\n        }\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\n        const mongoCollection = await this.mongoCollectionPromise;\n        await mongoCollection.drop();\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\n        await this.close();\n    }\n\n    async close(): Promise<void> {\n        // TODO without this next-tick we have random fails in the tests\n        await requestIdlePromise(200);\n\n        if (this.closed) {\n            return this.closed;\n        }\n        this.closed = (async () => {\n            await this.mongoCollectionPromise;\n            await firstValueFrom(this.runningOperations.pipe(filter(c => c === 0)));\n            // await ensureNotFalsy(this.mongoChangeStream).close();\n            await this.mongoClient.close();\n        })();\n        return this.closed;\n    }\n}\n\nexport function createMongoDBStorageInstance<RxDocType>(\n    storage: RxStorageMongoDB,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMongoDBInstanceCreationOptions>,\n    settings: RxStorageMongoDBSettings\n): Promise<RxStorageInstanceMongoDB<RxDocType>> {\n    const instance = new RxStorageInstanceMongoDB(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        {},\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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","ignoreList":[]}