{"version":3,"file":"rx-query.js","names":["BehaviorSubject","merge","mergeMap","filter","map","startWith","distinctUntilChanged","shareReplay","sortObject","pluginMissing","overwriteGetterForCaching","now","PROMISE_RESOLVE_FALSE","RXJS_SHARE_REPLAY_DEFAULTS","ensureNotFalsy","areRxDocumentArraysEqual","appendToArray","newRxError","rxStorageWriteErrorToRxError","runPluginHooks","calculateNewResults","triggerCacheReplacement","getQueryMatcher","normalizeMangoQuery","prepareQuery","runQueryUpdateFunction","RxQuerySingleResult","_queryCount","newQueryID","RxQueryBase","op","mangoQuery","collection","other","id","_execOverDatabaseCount","_creationTime","_lastEnsureEqual","uncached","refCount$","_result","_latestChangeEvent","_ensureEqualQueue","_getDefaultQuery","isFindOneByIdQuery","schema","primaryPath","_proto","prototype","_setResultData","newResultData","database","name","Map","Array","from","values","newQueryResult","length","_execOverDatabase","preparedQuery","getPreparedQuery","countResult","storageInstance","count","mode","allowSlowCount","queryObj","result","counter","_changeEventBuffer","getCounter","ids","selector","$in","ret","mustBeQueried","forEach","docData","_docCache","getLatestDocumentDataIfExists","_deleted","doc","getCachedRxDocument","set","push","docs","findDocumentsById","primary","queryCollection","exec","throwIfMissing","query","_ensureEqual","useResult","getValue","toString","stringObj","jsonSchema","value","JSON","stringify","hookInput","rxQuery","$eq","index","unshift","doesDocumentDataMatch","queryMatcher","remove","isArray","bulkRemove","error","success","incrementalRemove","asRxQuery","update","_updateObj","patch","incrementalPatch","modify","mutationFunction","incrementalModify","where","_queryObj","sort","_params","skip","_amount","limit","_createClass","key","get","_$","results$","eventBulks$","pipe","bulk","isLocal","prev","curr","time","reactivity","getReactivityFactory","fromObservable","$","undefined","normalizedQuery","tunnelQueryCache","_queryCache","getByQuery","createRxQuery","_isResultsInSync","currentLatestEventNumber","awaitBeforeReads","size","Promise","all","fn","then","__ensureEqual","closed","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","previousCount","newCount","cE","didMatchBefore","previousDocumentData","doesMatchNow","documentData","eventReduceResult","runFullQueryAgain","changed","newResults","docsData","resolve","docIds","docId","docsFromStorage","fromStorageList","queryResult","documents","Object","keys","find","r","isRxQuery","obj"],"sources":["../../src/rx-query.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    sortObject,\n    pluginMissing,\n    overwriteGetterForCaching,\n    now,\n    PROMISE_RESOLVE_FALSE,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    ensureNotFalsy,\n    areRxDocumentArraysEqual,\n    appendToArray\n} from './plugins/utils/index.ts';\nimport {\n    newRxError,\n    rxStorageWriteErrorToRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport type {\n    RxCollection,\n    RxDocument,\n    RxQueryOP,\n    RxQuery,\n    MangoQuery,\n    MangoQuerySortPart,\n    MangoQuerySelector,\n    PreparedQuery,\n    RxDocumentWriteData,\n    RxDocumentData,\n    QueryMatcher,\n    ModifyFunction,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport { calculateNewResults } from './event-reduce.ts';\nimport { triggerCacheReplacement } from './query-cache.ts';\nimport {\n    getQueryMatcher,\n    normalizeMangoQuery,\n    prepareQuery,\n    runQueryUpdateFunction\n\n} from './rx-query-helper.ts';\nimport { RxQuerySingleResult } from './rx-query-single-result.ts';\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\nexport class RxQueryBase<\n    RxDocType,\n    RxQueryResult,\n    OrmMethods = {},\n    Reactivity = unknown,\n> {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string | string[];\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: RxQuerySingleResult<RxDocType> | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\n        public collection: RxCollection<RxDocType>,\n        // used by some plugins\n        public other: any = {}\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): Observable<RxQueryResult> {\n        if (!this._$) {\n            const results$ = this.collection.eventBulks$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(bulk => !bulk.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    return ensureNotFalsy(result).getValue();\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n    get $$(): Reactivity {\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            this.$,\n            undefined,\n            this.collection.database\n        ) as any;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from the storage\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\n        if (typeof newResultData === 'undefined') {\n            throw newRxError('QU18', {\n                database: this.collection.database.name,\n                collection: this.collection.name\n            });\n        }\n        if (typeof newResultData === 'number') {\n            this._result = new RxQuerySingleResult<RxDocType>(\n                this as any,\n                [],\n                newResultData\n            );\n            return;\n        } else if (newResultData instanceof Map) {\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\n        }\n\n        const newQueryResult = new RxQuerySingleResult<RxDocType>(\n            this as any,\n            newResultData,\n            newResultData.length\n        );\n        this._result = newQueryResult;\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    async _execOverDatabase(): Promise<{\n        result: RxDocumentData<RxDocType>[] | number;\n        counter: number;\n    }> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        if (this.op === 'count') {\n            const preparedQuery = this.getPreparedQuery();\n            const countResult = await this.collection.storageInstance.count(preparedQuery);\n            if (countResult.mode === 'slow' && !this.collection.database.allowSlowCount) {\n                throw newRxError('QU14', {\n                    collection: this.collection,\n                    queryObj: this.mangoQuery\n                });\n            } else {\n                return {\n                    result: countResult.count,\n                    counter: this.collection._changeEventBuffer.getCounter()\n                };\n            }\n        }\n\n        if (this.op === 'findByIds') {\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\n            const ret = new Map<string, RxDocument<RxDocType>>();\n            const mustBeQueried: string[] = [];\n            // first try to fill from docCache\n            ids.forEach(id => {\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n                if (docData) {\n                    if (!docData._deleted) {\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\n                        ret.set(id, doc);\n                    }\n                } else {\n                    mustBeQueried.push(id);\n                }\n            });\n            // everything which was not in docCache must be fetched from the storage\n            if (mustBeQueried.length > 0) {\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n                docs.forEach(docData => {\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\n                    ret.set(doc.primary, doc);\n                });\n            }\n            return {\n                result: ret as any,\n                counter: this.collection._changeEventBuffer.getCounter()\n            };\n        }\n\n        const result = await queryCollection<RxDocType>(this as any);\n        return {\n            result: result.docs,\n            counter: result.counter\n        };\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    public exec(): Promise<RxQueryResult>;\n    public async exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        await _ensureEqual(this as any);\n        const useResult = ensureNotFalsy(this._result);\n        return useResult.getValue(throwIfMissing);\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\n        const schema = this.collection.schema.jsonSchema;\n        const normalizedQuery = normalizeMangoQuery(\n            this.collection.schema.jsonSchema,\n            this.mangoQuery\n        );\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            getQueryMatcher(\n                schema,\n                normalizedQuery\n            ) as any\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            ),\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj);\n        this.toString = () => value;\n        return value;\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            )\n        };\n        (hookInput.mangoQuery.selector as any)._deleted = { $eq: false };\n        if (hookInput.mangoQuery.index) {\n            hookInput.mangoQuery.index.unshift('_deleted');\n        }\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery as any\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    async remove(): Promise<RxQueryResult> {\n        const docs = await this.exec();\n        if (Array.isArray(docs)) {\n            const result = await this.collection.bulkRemove(docs);\n            if (result.error.length > 0) {\n                throw rxStorageWriteErrorToRxError(result.error[0]);\n            } else {\n                return result.success as any;\n            }\n        } else {\n            return (docs as any).remove();\n        }\n    }\n    incrementalRemove(): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalRemove(),\n        );\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n    patch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.patch(patch),\n        );\n    }\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalPatch(patch),\n        );\n    }\n    modify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.modify(mutationFunction),\n        );\n    }\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalModify(mutationFunction),\n        );\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n}\n\n\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery<RxDocType>(\n    op: RxQueryOP,\n    queryObj: MangoQuery<RxDocType>,\n    collection: RxCollection<RxDocType>,\n    other?: any\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection,\n        other\n    });\n\n    let ret = new RxQueryBase<RxDocType, any>(op, queryObj, collection, other);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase<any, any>): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery: RxQueryBase<any, any>): Promise<boolean> {\n    if (rxQuery.collection.awaitBeforeReads.size > 0) {\n        await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>): Promise<boolean> {\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.closed ||\n        // nothing happened since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n            const runChangeEvents: RxStorageChangeEvent<RxDocType>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            if (rxQuery.op === 'count') {\n                // 'count' query\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\n                let newCount = previousCount;\n                runChangeEvents.forEach(cE => {\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n\n                    if (!didMatchBefore && doesMatchNow) {\n                        newCount++;\n                    }\n                    if (didMatchBefore && !doesMatchNow) {\n                        newCount--;\n                    }\n                });\n                if (newCount !== previousCount) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newCount as any);\n                }\n            } else {\n                // 'find' or 'findOne' query\n                const eventReduceResult = calculateNewResults(\n                    rxQuery as any,\n                    runChangeEvents\n                );\n                if (eventReduceResult.runFullQueryAgain) {\n                    // could not calculate the new results, execute must be done\n                    mustReExec = true;\n                } else if (eventReduceResult.changed) {\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\n                }\n            }\n        }\n    }\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        return rxQuery._execOverDatabase()\n            .then(result => {\n                const newResultData = result.result;\n\n                /**\n                 * The RxStorage is defined to always first emit events and then return\n                 * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n                 * has been run, not the one from before.\n                 */\n                rxQuery._latestChangeEvent = result.counter;\n\n                // A count query needs a different has-changed check.\n                if (typeof newResultData === 'number') {\n                    if (\n                        !rxQuery._result ||\n                        newResultData !== rxQuery._result.count\n                    ) {\n                        ret = true;\n                        rxQuery._setResultData(newResultData as any);\n                    }\n                    return ret;\n                }\n                if (\n                    !rxQuery._result ||\n                    !areRxDocumentArraysEqual(\n                        rxQuery.collection.schema.primaryPath,\n                        newResultData,\n                        rxQuery._result.docsData\n                    )\n                ) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            });\n    }\n    return Promise.resolve(ret); // true if results have changed\n}\n\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>\n): Promise<{\n    docs: RxDocumentData<RxDocType>[];\n    /**\n     * We need to remember the counter directly here\n     * because getting if after the returned Promise is resolved,\n     * can result in a value that no longer matches the result set.\n     */\n    counter: number;\n}> {\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n            let docIds = rxQuery.isFindOneByIdQuery;\n            docIds = docIds.filter(docId => {\n                // first try to fill from docCache\n                const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n                if (docData) {\n                    if (!docData._deleted) {\n                        docs.push(docData);\n                    }\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n            // otherwise get from storage\n            if (docIds.length > 0) {\n                const docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n                appendToArray(docs, docsFromStorage);\n            }\n        } else {\n            const docId = rxQuery.isFindOneByIdQuery;\n\n            // first try to fill from docCache\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n            if (!docData) {\n                // otherwise get from storage\n                const fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n                if (fromStorageList[0]) {\n                    docData = fromStorageList[0];\n                }\n            }\n            if (docData && !docData._deleted) {\n                docs.push(docData);\n            }\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        docs = queryResult.documents;\n    }\n    return {\n        docs,\n        counter: collection._changeEventBuffer.getCounter()\n    };\n\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string | string[] {\n    // must have exactly one operator which must be $eq || $in\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        const value: any = query.selector[primaryPath];\n        if (typeof value === 'string') {\n            return value;\n        } else if (\n            Object.keys(value).length === 1 &&\n            typeof value.$eq === 'string'\n        ) {\n            return value.$eq;\n        }\n\n        // same with $in string arrays\n        if (\n            Object.keys(value).length === 1 &&\n            Array.isArray(value.$eq) &&\n            // must only contain strings\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\n        ) {\n            return value.$eq;\n        }\n    }\n    return false;\n}\n\n\n\nexport function isRxQuery(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n"],"mappings":"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","ignoreList":[]}