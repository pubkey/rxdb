{"version":3,"file":"util.d.js","names":[],"sources":["../../../src/types/util.d.ts"],"sourcesContent":["import type { RxStorage } from './rx-storage.interface';\n\nexport type MaybePromise<T> = Promise<T> | T;\n\n\nexport type PlainJsonValue = string | number | boolean | PlainSimpleJsonObject | PlainSimpleJsonObject[] | PlainJsonValue[];\nexport type PlainSimpleJsonObject = {\n    [k: string]: PlainJsonValue | PlainJsonValue[];\n};\n\n/**\n * @link https://stackoverflow.com/a/49670389/3443137\n */\ntype DeepReadonly<T> =\n    T extends (infer R)[] ? DeepReadonlyArray<R> :\n    T extends Function ? T :\n    T extends object ? DeepReadonlyObject<T> :\n    T;\n\ninterface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> { }\n\ntype DeepReadonlyObject<T> = {\n    readonly [P in keyof T]: DeepReadonly<T[P]>;\n};\n\nexport type MaybeReadonly<T> = T | Readonly<T>;\n\n\n/**\n * Opposite of DeepReadonly,\n * makes everything mutable again.\n */\ntype DeepMutable<T> = (\n    T extends object\n    ? {\n        -readonly [K in keyof T]: (\n            T[K] extends object\n            ? DeepMutable<T[K]>\n            : T[K]\n        )\n    }\n    : never\n);\n\n/**\n * Can be used like 'keyof'\n * but only represents the string keys, not the Symbols or numbers.\n * @link https://stackoverflow.com/a/51808262/3443137\n */\nexport type StringKeys<X> = Extract<keyof X, string>;\n\nexport type AnyKeys<T> = { [P in keyof T]?: T[P] | any };\nexport interface AnyObject {\n    [k: string]: any;\n}\n\n/**\n * @link https://dev.to/vborodulin/ts-how-to-override-properties-with-type-intersection-554l\n */\nexport type Override<T1, T2> = Omit<T1, keyof T2> & T2;\n\n\n\nexport type ById<T> = {\n    [id: string]: T;\n};\n\n/**\n * Must be async to support async hashing like from the WebCrypto API.\n */\nexport type HashFunction = (input: string) => Promise<string>;\n\nexport declare type QueryMatcher<DocType> = (doc: DocType | DeepReadonly<DocType>) => boolean;\n\n/**\n * To have a deterministic sorting, we cannot return 0,\n * we only return 1 or -1.\n * This ensures that we always end with the same output array, no mather of the\n * pre-sorting of the input array.\n */\nexport declare type DeterministicSortComparator<DocType> = (a: DocType, b: DocType) => 1 | -1;\n\n/**\n * To test a storage, we need these\n * configuration values.\n */\nexport type RxTestStorage = {\n    // can be used to setup async stuff\n    readonly init?: () => any;\n    readonly name: string;\n    readonly getStorage: () => RxStorage<any, any>;\n    /**\n     * Returns a storage that is used in performance tests.\n     * For example in a browser it should return the storage with an IndexedDB based adapter,\n     * while in node.js it must use the filesystem.\n     */\n    readonly getPerformanceStorage: () => {\n        storage: RxStorage<any, any>;\n        /**\n         * A description that describes the storage and setting.\n         * For example 'dexie-native'.\n         */\n        description: string;\n    };\n    /**\n     * True if the storage is able to\n     * keep data after an instance is closed and opened again.\n     */\n    readonly hasPersistence: boolean;\n    readonly hasMultiInstance: boolean;\n    readonly hasAttachments: boolean;\n\n    /**\n     * Some storages likes the memory-synced storage,\n     * are not able to provide a replication while guaranteeing\n     * data integrity.\n     */\n    readonly hasReplication: boolean;\n\n    /**\n     * To make it possible to test alternative encryption plugins,\n     * you can specify hasEncryption to signal\n     * the test runner that the given storage already contains an\n     * encryption plugin that should be used to test encryption tests.\n     * Otherwise the encryption-crypto-js plugin will be tested.\n     *\n     * hasEncryption must contain a function that is able\n     * to create a new password.\n     */\n    readonly hasEncryption?: () => Promise<string>;\n};\n\n\n/**\n * The paths as strings-type of nested object\n * @link https://stackoverflow.com/a/58436959/3443137\n */\ntype Join<K, P> = K extends string | number ?\n    P extends string | number ?\n    `${K}${'' extends P ? '' : '.'}${P}`\n    : never : never;\n\nexport type Paths<T, D extends number = 10> = [D] extends [never] ? never : T extends object ?\n    { [K in keyof T]-?: K extends string | number ?\n        `${K}` | (Paths<T[K], Prev[D]> extends infer R ? Join<K, R> : never)\n        : never\n    }[keyof T] : '';\n\nexport type Leaves<T, D extends number = 10> = [D] extends [never] ? never : T extends object ?\n    { [K in keyof T]-?: Join<K, Leaves<T[K], Prev[D]>> }[keyof T] : '';\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];\n"],"mappings":"","ignoreList":[]}