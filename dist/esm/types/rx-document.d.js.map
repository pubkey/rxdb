{"version":3,"file":"rx-document.d.js","names":[],"sources":["../../../src/types/rx-document.d.ts"],"sourcesContent":["import {\n    Observable\n} from 'rxjs';\n\nimport type {\n    RxCollection,\n} from './rx-collection.d.ts';\nimport type {\n    RxAttachment,\n    RxAttachmentCreator,\n    RxAttachmentCreatorBase64\n} from './rx-attachment.d.ts';\nimport type { RxDocumentData, WithDeleted } from './rx-storage.d.ts';\nimport type { RxChangeEvent } from './rx-change-event.d.ts';\nimport type { DeepReadonly, MaybePromise, PlainJsonValue } from './util.d.ts';\nimport type { UpdateQuery } from './plugins/update.d.ts';\nimport type { CRDTEntry } from './plugins/crdt.d.ts';\n\n\n\nexport type RxDocument<RxDocumentType = {}, OrmMethods = {}, Reactivity = unknown> = RxDocumentBase<\n    RxDocumentType,\n    OrmMethods,\n    Reactivity\n> & RxDocumentType & OrmMethods & ExtendObservables<RxDocumentType> & ExtendReactivity<RxDocumentType, Reactivity>;\n\n\n/**\n * Extend the base properties by the property$ fields\n * so it knows that RxDocument.age also has RxDocument.age$ which is\n * an observable.\n * TODO how to do this for the nested fields?\n */\ntype ExtendObservables<RxDocumentType> = {\n    [P in keyof RxDocumentType as `${string & P}$`]: Observable<RxDocumentType[P]>;\n};\n\ntype ExtendReactivity<RxDocumentType, Reactivity> = {\n    [P in keyof RxDocumentType as `${string & P}$$`]: Reactivity;\n};\n\n/**\n * The public facing modify update function.\n * It only gets the document parts as input, that\n * are mutateable by the user.\n */\nexport type ModifyFunction<RxDocumentType> = (\n    doc: WithDeleted<RxDocumentType>\n) => MaybePromise<WithDeleted<RxDocumentType>> | MaybePromise<RxDocumentType>;\n\n/**\n * Meta data that is attached to each document by RxDB.\n */\nexport type RxDocumentMeta = {\n    /**\n     * Last write time.\n     * Unix epoch in milliseconds.\n     */\n    lwt: number;\n\n    /**\n     * Any other value can be attached to the _meta data.\n     * Mostly done by plugins to mark documents.\n     */\n    [k: string]: PlainJsonValue;\n};\n\nexport declare interface RxDocumentBase<RxDocType, OrmMethods = {}, Reactivity = unknown> {\n    isInstanceOfRxDocument: true;\n    collection: RxCollection<RxDocType, OrmMethods, Reactivity>;\n    readonly deleted: boolean;\n\n    readonly $: Observable<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    readonly $$: Reactivity;\n    readonly deleted$: Observable<boolean>;\n    readonly deleted$$: Reactivity;\n\n    readonly primary: string;\n    readonly allAttachments$: Observable<RxAttachment<RxDocType, OrmMethods, Reactivity>[]>;\n\n    // internal things\n    _data: RxDocumentData<RxDocType>;\n    primaryPath: string;\n    revision: string;\n    /**\n     * Used to de-duplicate the enriched property objects\n     * of the document.\n     */\n    _propertyCache: Map<string, any>;\n    $emit(cE: RxChangeEvent<RxDocType>): void;\n    _saveData(newData: any, oldData: any): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    // /internal things\n\n    // Returns the latest state of the document\n    getLatest(): RxDocument<RxDocType, OrmMethods, Reactivity>;\n\n\n    get$(path: string): Observable<any>;\n    get$$(path: string): Reactivity;\n    get(objPath: string): DeepReadonly<any>;\n    populate(objPath: string): Promise<RxDocument<RxDocType, OrmMethods, Reactivity> | any | null>;\n\n    /**\n     * mutate the document with a function\n     */\n    modify(mutationFunction: ModifyFunction<RxDocType>, context?: string): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>, context?: string): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n\n    /**\n     * patches the given properties\n     */\n    patch(patch: Partial<RxDocType>): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n\n    update(updateObj: UpdateQuery<RxDocType>): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    incrementalUpdate(updateObj: UpdateQuery<RxDocType>): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n\n    updateCRDT(updateObj: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n\n    remove(): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    incrementalRemove(): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n\n    // only for temporary documents\n    set(objPath: string, value: any): RxDocument<RxDocType, OrmMethods, Reactivity>;\n    save(): Promise<boolean>;\n\n    // attachments\n    putAttachment(\n        creator: RxAttachmentCreator\n    ): Promise<RxAttachment<RxDocType, OrmMethods, Reactivity>>;\n    putAttachmentBase64(\n        creator: RxAttachmentCreatorBase64\n    ): Promise<RxAttachment<RxDocType, OrmMethods, Reactivity>>;\n    getAttachment(id: string): RxAttachment<RxDocType, OrmMethods, Reactivity> | null;\n    allAttachments(): RxAttachment<RxDocType, OrmMethods, Reactivity>[];\n\n    toJSON(withRevAndAttachments: true): DeepReadonly<RxDocumentData<RxDocType>>;\n    toJSON(withRevAndAttachments?: false): DeepReadonly<RxDocType>;\n\n    toMutableJSON(withRevAndAttachments: true): RxDocumentData<RxDocType>;\n    toMutableJSON(withRevAndAttachments?: false): RxDocType;\n\n    close(): void;\n}\n"],"mappings":"","ignoreList":[]}