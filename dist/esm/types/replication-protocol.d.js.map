{"version":3,"file":"replication-protocol.d.js","names":[],"sources":["../../../src/types/replication-protocol.d.ts"],"sourcesContent":["import { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport type {\n    RxConflictHandler,\n    RxConflictHandlerInput\n} from './conflict-handling.d.ts';\nimport type { RxError, RxTypeError } from './rx-error.d.ts';\nimport type {\n    BulkWriteRow,\n    RxDocumentData,\n    WithDeleted,\n    WithDeletedAndAttachments\n} from './rx-storage.d.ts';\nimport type {\n    RxStorageInstance\n} from './rx-storage.interface.d.ts';\nimport type { HashFunction } from './util.d.ts';\n\nexport type RxStorageReplicationMeta<RxDocType, CheckpointType> = {\n\n    /**\n     * Combined primary key consisting\n     * of: [replicationId, itemId, isCheckpoint]\n     * so that the same RxStorageInstance\n     * can be used for multiple replication states.\n     */\n    id: string;\n\n    /**\n     * Either the document primaryKey\n     * or the id of the replication checkpoint.\n     */\n    itemId: string;\n\n    /**\n     * True if the doc data is about a checkpoint,\n     * False if it is about a document state from the master.\n     * Stored as a string so it can be used\n     * in the combined primary key 'id'\n     */\n    isCheckpoint: '0' | '1';\n    checkpointData?: CheckpointType;\n\n    /**\n     * the document state of the master\n     * only set if not checkpoint.\n     */\n    docData?: RxDocType | RxDocumentData<RxDocType> | any;\n    /**\n     * If the current assumed master was written while\n     * resolving a conflict, this field contains\n     * the revision of the conflict-solution that\n     * is stored in the forkInstance.\n     */\n    isResolvedConflict?: string;\n};\n\nexport type RxReplicationWriteToMasterRow<RxDocType> = {\n    assumedMasterState?: WithDeletedAndAttachments<RxDocType>;\n    newDocumentState: WithDeletedAndAttachments<RxDocType>;\n};\n\n\nexport type DocumentsWithCheckpoint<RxDocType, CheckpointType> = {\n    documents: WithDeletedAndAttachments<RxDocType>[];\n    checkpoint: CheckpointType;\n};\n\n\nexport type RxReplicationPullStreamItem<RxDocType, MasterCheckpointType> = DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> |\n    /**\n         * Emit this when the masterChangeStream$ might have missed out\n         * some events because the fork lost the connection to the master.\n         * Like when the user went offline and reconnects.\n         */\n    'RESYNC';\n\n/**\n * The replication handler contains all logic\n * that is required by the replication protocol\n * to interact with the master instance.\n * This is an abstraction so that we can use different\n * handlers for GraphQL, REST or any other transportation layer.\n * Even a RxStorageInstance can be wrapped in a way to represent a replication handler.\n *\n * The RxStorage instance of the master branch that is\n * replicated with the fork branch.\n * The replication algorithm is made to make\n * as less writes on the master as possible.\n * The master instance is always 'the truth' which\n * does never contain conflicting document states.\n * All conflicts are handled on the fork branch\n * before being replicated to the master.\n */\nexport type RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n    masterChangeStream$: Observable<RxReplicationPullStreamItem<RxDocType, MasterCheckpointType>>;\n    masterChangesSince(\n        checkpoint: MasterCheckpointType | undefined,\n        batchSize: number\n    ): Promise<DocumentsWithCheckpoint<RxDocType, MasterCheckpointType | undefined>>;\n    /**\n     * Writes the fork changes to the master.\n     * Only returns the conflicts if there are any.\n     * (otherwise returns an empty array.)\n     */\n    masterWrite(\n        rows: RxReplicationWriteToMasterRow<RxDocType>[]\n    ): Promise<WithDeleted<RxDocType>[]>;\n};\n\nexport type RxStorageInstanceReplicationInput<RxDocType> = {\n    /**\n     * A string that uniquely identifies\n     * the replication.\n     * Ensures that checkpoint are not\n     * mixed with other replications.\n     */\n    identifier: string;\n    pullBatchSize: number;\n    pushBatchSize: number;\n    replicationHandler: RxReplicationHandler<RxDocType, any>;\n    conflictHandler: RxConflictHandler<RxDocType>;\n\n    // can be set to also replicate the _meta field of the document.\n    keepMeta?: boolean;\n\n    /**\n     * The fork is the one that contains the forked chain of document writes.\n     * All conflicts are solved on the fork and only resolved correct document data\n     * is written back to the parent.\n     */\n    forkInstance: RxStorageInstance<RxDocType, any, any>;\n\n    /**\n     * The replication needs to store some meta data\n     * for documents to know which state is at the master\n     * and how/if it diverges from the fork.\n     * In the past this was stored in the _meta field of\n     * the forkInstance documents but that was not a good design decision\n     * because it required additional writes on the forkInstance\n     * to know which documents have been upstream replicated\n     * to not cause conflicts.\n     * Using the metaInstance instead leads to better overall performance\n     * because RxDB will not re-emit query results or document state\n     * when replication meta data is written.\n     *\n     * In addition to per-document meta data,\n     * the replication checkpoints are also stored in this instance.\n     *\n     */\n    metaInstance: RxStorageInstance<RxStorageReplicationMeta<RxDocType, any>, any, any>;\n\n    /**\n     * When a write happens to the fork,\n     * normally the replication will directly try to persist.\n     *\n     * For many use cases, it is better to await the next event loop tick\n     * or to wait until the RxDatabase is idle or requestIdleCallback() calls\n     * to ensure the CPU is idle.\n     * This can improve performance because the persistence will not affect UI\n     * renders.\n     *\n     * But: The longer you wait here, the higher is the risk of losing fork\n     * writes when the replication is closed unexpected.\n     */\n    waitBeforePersist?: () => Promise<any>;\n\n    hashFunction: HashFunction;\n\n    initialCheckpoint?: {\n        upstream?: any;\n        downstream?: any;\n    };\n};\n\nexport type RxStorageInstanceReplicationState<RxDocType> = {\n    // store the primaryPath here for better reuse and performance.\n    primaryPath: string;\n    hasAttachments: boolean;\n    input: RxStorageInstanceReplicationInput<RxDocType>;\n\n    events: {\n        /**\n         * Streams all document writes that have successfully\n         * been written in one direction.\n         */\n        processed: {\n            up: Subject<RxReplicationWriteToMasterRow<RxDocType>>;\n            down: Subject<BulkWriteRow<RxDocType>>;\n        };\n        resolvedConflicts: Subject<{\n            input: RxConflictHandlerInput<RxDocType>;\n            output: WithDeleted<RxDocType>;\n        }>;\n        /**\n         * Contains the cancel state.\n         * Emit true here to cancel the replication.\n         */\n        canceled: BehaviorSubject<boolean>;\n        /**\n         * Contains the pause state.\n         * Emit true here to pause the replication.\n         */\n        paused: BehaviorSubject<boolean>;\n        /**\n         * Contains true if the replication is doing something\n         * at this point in time.\n         * If this is false, it means that the replication\n         * is idle AND in sync.\n         */\n        active: {\n            [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\n        };\n        /**\n         * All errors that would otherwise be unhandled,\n         * get emitted here.\n         */\n        error: Subject<RxError | RxTypeError>;\n    };\n\n\n    /**\n     * Contains counters that can be used in tests\n     * or to debug problems.\n     */\n    stats: {\n        down: {\n            addNewTask: number;\n            downstreamResyncOnce: number;\n            downstreamProcessChanges: number;\n            masterChangeStreamEmit: number;\n            persistFromMaster: number;\n        };\n        up: {\n            upstreamInitialSync: number;\n            forkChangeStreamEmit: number;\n            processTasks: number;\n            persistToMaster: number;\n            persistToMasterHadConflicts: number;\n            persistToMasterConflictWrites: number;\n        };\n    };\n\n    /**\n     * Used in checkpoints and ._meta fields\n     * to ensure we do not mix up meta data of\n     * different replications.\n     * We have to use the promise because the key is hashed which runs async.\n     */\n    checkpointKey: Promise<string>;\n\n    /**\n     * Storage.bulkWrites() that are initialized from the\n     * downstream, get this flag as context-param\n     * so that the emitted event bulk can be identified\n     * to be sourced from the downstream and it will not try\n     * to upstream these documents again.\n     */\n    downstreamBulkWriteFlag: Promise<string>;\n\n    /**\n     * Tracks if the streams have been in sync\n     * for at least one time.\n     */\n    firstSyncDone: {\n        [direction in RxStorageReplicationDirection]: BehaviorSubject<boolean>;\n    };\n\n    /**\n     * Can be used to detect if the replication is doing something\n     * or if it is in an idle state.\n     */\n    streamQueue: {\n        [direction in RxStorageReplicationDirection]: Promise<any>;\n    };\n\n    checkpointQueue: Promise<any>;\n\n    /**\n     * For better performance we store the last known checkpoint\n     * document so that we can likely do checkpoint storing without\n     * conflicts.\n     */\n    lastCheckpointDoc: {\n        [direction in RxStorageReplicationDirection]?: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\n    };\n};\n\nexport type RxStorageReplicationDirection = 'up' | 'down';\n"],"mappings":"","ignoreList":[]}