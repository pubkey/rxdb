{"version":3,"file":"upstream.js","names":["firstValueFrom","filter","stackCheckpoints","appendToArray","batchArray","clone","ensureNotFalsy","parseRevision","PROMISE_RESOLVE_FALSE","getLastCheckpointDoc","setCheckpoint","resolveConflictError","stripAttachmentsDataFromMetaWriteRows","writeDocToDocState","getAssumedMasterState","getMetaWriteRow","fillWriteDataForAttachmentsChange","startReplicationUpstream","state","input","initialCheckpoint","upstream","checkpointDoc","replicationHandler","streamQueue","up","then","upstreamInitialSync","processTasks","timer","initialSyncStartTime","openTasks","persistenceQueue","nonPersistedFromMaster","docs","sub","forkInstance","changeStream","subscribe","eventBulk","context","downstreamBulkWriteFlag","stats","forkChangeStreamEmit","push","task","time","waitBeforePersist","events","canceled","pipe","unsubscribe","getValue","checkpointQueue","lastCheckpoint","promises","upResult","getChangedDocumentsSince","pushBatchSize","documents","length","checkpoint","persistToMaster","resolvedPromises","Promise","all","hadConflicts","find","r","firstSyncDone","next","active","taskWithTime","shift","map","documentData","promise","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","assumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","fullDocData","hasAttachments","keepMeta","assumedMasterDoc","metaDocument","isResolvedConflict","_rev","conflictHandler","realMasterState","newDocumentState","isEqual","height","_meta","identifier","undefined","writeRowsArray","values","conflictIds","Set","conflictsById","writeBatches","writeBatch","row","masterWriteResult","masterWrite","conflictDoc","id","add","useWriteRowsToMeta","has","processed","metaInstance","bulkWrite","hadConflictWrites","size","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","writeToMasterRow","resolved","resolvedConflicts","output","previous","document","resolvedDoc","persistToMasterConflictWrites","forkWriteResult","useMetaWrites","success","catch","unhandledError","error"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    appendToArray,\n    batchArray,\n    clone,\n    ensureNotFalsy,\n    parseRevision,\n    PROMISE_RESOLVE_FALSE\n} from '../plugins/utils/index.ts';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint.ts';\nimport { resolveConflictError } from './conflicts.ts';\nimport {\n    stripAttachmentsDataFromMetaWriteRows,\n    writeDocToDocState\n} from './helper.ts';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    if (\n        state.input.initialCheckpoint &&\n        state.input.initialCheckpoint.upstream\n    ) {\n        const checkpointDoc = await getLastCheckpointDoc(state, 'up');\n        if (!checkpointDoc) {\n            await setCheckpoint(\n                state,\n                'up',\n                state.input.initialCheckpoint.upstream\n            );\n        }\n    }\n\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    const sub = state.input.forkInstance.changeStream()\n        .subscribe(async (eventBulk) => {\n            // ignore writes that came from the downstream\n            if (eventBulk.context === await state.downstreamBulkWriteFlag) {\n                return;\n            }\n\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n            const upResult = await state.input.forkInstance.getChangedDocumentsSince(\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            promises.push(\n                persistToMaster(\n                    upResult.documents,\n                    ensureNotFalsy(lastCheckpoint)\n                )\n            );\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upstream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (\n            !state.firstSyncDone.up.getValue() &&\n            !state.events.canceled.getValue()\n        ) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(() => {\n            /**\n             * Merge/filter all open tasks\n             */\n            const docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType = {} as any;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                /**\n                 * If the task came in before the last time the initial sync fetching\n                 * has run, we can ignore the task because the initial sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    continue;\n                }\n                appendToArray(\n                    docs,\n                    taskWithTime.task.events.map(r => {\n                        return r.documentData as any;\n                    })\n                );\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n            }\n\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\n                docs,\n                checkpoint\n            );\n            return promise.then(() => {\n                if (openTasks.length === 0) {\n                    state.events.active.up.next(false);\n                } else {\n                    processTasks();\n                }\n            });\n        });\n    }\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistent list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n            if (docIds.length === 0) {\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        (\n                            assumedMasterDoc &&\n                            // if the isResolvedConflict is correct, we do not have to compare the documents.\n                            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\n                            &&\n                            (await state.input.conflictHandler({\n                                realMasterState: assumedMasterDoc.docData,\n                                newDocumentState: docData\n                            }, 'upstream-check-if-equal')).isEqual\n                        )\n                        ||\n                        /**\n                         * If the master works with _rev fields,\n                         * we use that to check if our current doc state\n                         * is different from the assumedMasterDoc.\n                         */\n                        (\n                            assumedMasterDoc &&\n                            (assumedMasterDoc.docData as any)._rev &&\n                            parseRevision(fullDocData._rev).height === fullDocData._meta[state.input.identifier]\n                        )\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = await getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                return false;\n            }\n\n\n            const writeRowsArray = Object.values(writeRowsToMaster);\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n\n            /**\n             * To always respect the push.batchSize,\n             * we have to split the write rows into batches\n             * to ensure that replicationHandler.masterWrite() is never\n             * called with more documents than what the batchSize limits.\n             */\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n            await Promise.all(\n                writeBatches.map(async (writeBatch) => {\n\n                    // enhance docs with attachments\n                    if (state.hasAttachments) {\n                        await Promise.all(\n                            writeBatch.map(async (row) => {\n                                row.newDocumentState = await fillWriteDataForAttachmentsChange(\n                                    state.primaryPath,\n                                    state.input.forkInstance,\n                                    clone(row.newDocumentState),\n                                    row.assumedMasterState\n                                );\n                            })\n                        );\n                    }\n\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n                    masterWriteResult.forEach(conflictDoc => {\n                        const id = (conflictDoc as any)[state.primaryPath];\n                        conflictIds.add(id);\n                        conflictsById[id] = conflictDoc;\n                    });\n                })\n            );\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta),\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(async (resolved) => {\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved.output\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved.resolvedDoc\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = await getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved.resolvedDoc._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n                    /**\n                     * Errors in the forkWriteResult must not be handled\n                     * because they have been caused by a write to the forkInstance\n                     * in between which will anyway trigger a new upstream cycle\n                     * that will then resolved the conflict again.\n                     */\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n                    forkWriteResult.success\n                        .forEach(docData => {\n                            const docId = (docData as any)[state.primaryPath];\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites),\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parallel checkpoint writes,\n             * we have to use a queue.\n             */\n            state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(\n                state,\n                'up',\n                useCheckpoint\n            ));\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n"],"mappings":"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"}