{"version":3,"file":"index.js","names":["BehaviorSubject","combineLatest","filter","firstValueFrom","mergeMap","Subject","getPrimaryFieldOfPrimaryKey","clone","ensureNotFalsy","flatClone","PROMISE_RESOLVE_VOID","getCheckpointKey","startReplicationDownstream","docStateToWriteDoc","getUnderlyingPersistentStorage","writeDocToDocState","startReplicationUpstream","fillWriteDataForAttachmentsChange","getChangedDocumentsSince","newRxError","replicateRxStorageInstance","input","forkInstance","metaInstance","checkpointKeyPromise","state","primaryPath","schema","primaryKey","hasAttachments","attachments","checkpointKey","downstreamBulkWriteFlag","then","events","canceled","paused","active","down","up","processed","resolvedConflicts","error","stats","addNewTask","downstreamProcessChanges","downstreamResyncOnce","masterChangeStreamEmit","persistFromMaster","forkChangeStreamEmit","persistToMaster","persistToMasterConflictWrites","persistToMasterHadConflicts","processTasks","upstreamInitialSync","firstSyncDone","streamQueue","checkpointQueue","lastCheckpointDoc","awaitRxStorageReplicationFirstInSync","pipe","v","awaitRxStorageReplicationInSync","replicationState","Promise","all","awaitRxStorageReplicationIdle","rxStorageInstanceToReplicationHandler","instance","conflictHandler","databaseInstanceToken","keepMeta","replicationHandler","masterChangeStream$","changeStream","eventBulk","ret","checkpoint","documents","map","event","docData","documentData","undefined","masterChangesSince","batchSize","result","length","plainDocumentData","masterWrite","rows","rowById","forEach","row","docId","newDocumentState","ids","Object","keys","masterDocsStateList","findDocumentsById","masterDocsState","Map","doc","set","conflicts","writeRows","entries","id","masterState","get","push","document","assumedMasterState","isEqual","previous","bulkWrite","err","status","name","documentInDb","cancelRxStorageReplication","next","complete"],"sources":["../../../src/replication-protocol/index.ts"],"sourcesContent":["/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    firstValueFrom,\n    mergeMap,\n    Subject\n} from 'rxjs';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from '../rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    ById,\n    DocumentsWithCheckpoint,\n    RxConflictHandler,\n    RxDocumentData,\n    RxReplicationHandler,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getCheckpointKey\n} from './checkpoint.ts';\nimport { startReplicationDownstream } from './downstream.ts';\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from './helper.ts';\nimport { startReplicationUpstream } from './upstream.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\nimport { getChangedDocumentsSince } from '../rx-storage-helper.ts';\nimport { newRxError } from '../rx-error.ts';\n\n\nexport * from './checkpoint.ts';\nexport * from './downstream.ts';\nexport * from './upstream.ts';\nexport * from './meta-instance.ts';\nexport * from './conflicts.ts';\nexport * from './helper.ts';\nexport * from './default-conflict-handler.ts';\n\n\nexport function replicateRxStorageInstance<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): RxStorageInstanceReplicationState<RxDocType> {\n    input = flatClone(input);\n    input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n    input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n    const checkpointKeyPromise = getCheckpointKey(input);\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n        hasAttachments: !!input.forkInstance.schema.attachments,\n        input,\n        checkpointKey: checkpointKeyPromise,\n        downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n        events: {\n            canceled: new BehaviorSubject<boolean>(false),\n            paused: new BehaviorSubject<boolean>(false),\n            active: {\n                down: new BehaviorSubject<boolean>(true),\n                up: new BehaviorSubject<boolean>(true)\n            },\n            processed: {\n                down: new Subject(),\n                up: new Subject()\n            },\n            resolvedConflicts: new Subject(),\n            error: new Subject()\n        },\n        stats: {\n            down: {\n                addNewTask: 0,\n                downstreamProcessChanges: 0,\n                downstreamResyncOnce: 0,\n                masterChangeStreamEmit: 0,\n                persistFromMaster: 0\n            },\n            up: {\n                forkChangeStreamEmit: 0,\n                persistToMaster: 0,\n                persistToMasterConflictWrites: 0,\n                persistToMasterHadConflicts: 0,\n                processTasks: 0,\n                upstreamInitialSync: 0\n            }\n        },\n        firstSyncDone: {\n            down: new BehaviorSubject<boolean>(false),\n            up: new BehaviorSubject<boolean>(false)\n        },\n        streamQueue: {\n            down: PROMISE_RESOLVE_VOID,\n            up: PROMISE_RESOLVE_VOID\n        },\n        checkpointQueue: PROMISE_RESOLVE_VOID,\n        lastCheckpointDoc: {}\n    };\n\n    startReplicationDownstream(state);\n    startReplicationUpstream(state);\n    return state;\n}\n\nexport function awaitRxStorageReplicationFirstInSync(\n    state: RxStorageInstanceReplicationState<any>\n): Promise<void> {\n    return firstValueFrom(\n        combineLatest([\n            state.firstSyncDone.down.pipe(\n                filter(v => !!v)\n            ),\n            state.firstSyncDone.up.pipe(\n                filter(v => !!v)\n            )\n        ])\n    ).then(() => { });\n}\n\nexport function awaitRxStorageReplicationInSync(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    return Promise.all([\n        replicationState.streamQueue.up,\n        replicationState.streamQueue.down,\n        replicationState.checkpointQueue\n    ]);\n}\n\n\nexport async function awaitRxStorageReplicationIdle(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    await awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n        const { down, up } = state.streamQueue;\n        await Promise.all([\n            up,\n            down\n        ]);\n        /**\n         * If the Promises have not been reassigned\n         * after awaiting them, we know that the replication\n         * is in idle state at this point in time.\n         */\n        if (\n            down === state.streamQueue.down &&\n            up === state.streamQueue.up\n        ) {\n            return;\n        }\n    }\n}\n\n\nexport function rxStorageInstanceToReplicationHandler<RxDocType, MasterCheckpointType>(\n    instance: RxStorageInstance<RxDocType, any, any, MasterCheckpointType>,\n    conflictHandler: RxConflictHandler<RxDocType>,\n    databaseInstanceToken: string,\n    /**\n     * If set to true,\n     * the _meta.lwt from the pushed documents is kept.\n     * (Used in the migration to ensure checkpoints are still valid)\n     */\n    keepMeta: boolean = false\n): RxReplicationHandler<RxDocType, MasterCheckpointType> {\n    instance = getUnderlyingPersistentStorage(instance);\n\n    const hasAttachments = !!instance.schema.attachments;\n    const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n    const replicationHandler: RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n        masterChangeStream$: instance.changeStream().pipe(\n            mergeMap(async (eventBulk) => {\n                const ret: DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> = {\n                    checkpoint: eventBulk.checkpoint,\n                    documents: await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            let docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice that the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n                            return docData;\n                        })\n                    )\n                };\n                return ret;\n            })\n        ),\n        masterChangesSince(\n            checkpoint,\n            batchSize\n        ) {\n            return getChangedDocumentsSince(\n                instance,\n                batchSize,\n                checkpoint\n            ).then(async (result) => {\n                return {\n                    checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n                    documents: await Promise.all(\n                        result.documents.map(async (plainDocumentData) => {\n                            let docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice the the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n                            return docData;\n                        })\n                    )\n                };\n            });\n        },\n        async masterWrite(\n            rows\n        ) {\n            const rowById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            rows.forEach(row => {\n                const docId: string = (row.newDocumentState as any)[primaryPath];\n                rowById[docId] = row;\n            });\n            const ids = Object.keys(rowById);\n\n            const masterDocsStateList = await instance.findDocumentsById(\n                ids,\n                true\n            );\n            const masterDocsState = new Map<string, RxDocumentData<RxDocType>>();\n            masterDocsStateList.forEach(doc => masterDocsState.set((doc as any)[primaryPath], doc));\n            const conflicts: WithDeleted<RxDocType>[] = [];\n            const writeRows: BulkWriteRow<RxDocType>[] = [];\n            await Promise.all(\n                Object.entries(rowById)\n                    .map(([id, row]) => {\n                        const masterState = masterDocsState.get(id);\n                        if (!masterState) {\n                            writeRows.push({\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n                            });\n                        } else if (\n                            masterState &&\n                            !row.assumedMasterState\n                        ) {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        } else if (\n                            conflictHandler.isEqual(\n                                writeDocToDocState(masterState, hasAttachments, keepMeta),\n                                ensureNotFalsy(row.assumedMasterState),\n                                'rxStorageInstanceToReplicationHandler-masterWrite'\n                            ) === true\n                        ) {\n                            writeRows.push({\n                                previous: masterState,\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n                            });\n                        } else {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        }\n                    })\n            );\n\n            if (writeRows.length > 0) {\n                const result = await instance.bulkWrite(\n                    writeRows,\n                    'replication-master-write'\n                );\n\n                result.error.forEach(err => {\n                    if (err.status !== 409) {\n                        throw newRxError('SNH', {\n                            name: 'non conflict error',\n                            error: err as any\n                        });\n                    } else {\n                        conflicts.push(\n                            writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta)\n                        );\n                    }\n                });\n            }\n            return conflicts;\n        }\n    };\n\n    return replicationHandler;\n}\n\n\nexport async function cancelRxStorageReplication(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    replicationState.events.canceled.next(true);\n    replicationState.events.active.up.complete();\n    replicationState.events.active.down.complete();\n    replicationState.events.processed.up.complete();\n    replicationState.events.processed.down.complete();\n    replicationState.events.resolvedConflicts.complete();\n    replicationState.events.canceled.complete();\n    await replicationState.checkpointQueue;\n}\n"],"mappings":"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","ignoreList":[]}