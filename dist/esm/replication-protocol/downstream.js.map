{"version":3,"file":"downstream.js","names":["firstValueFrom","filter","mergeMap","newRxError","getWrittenDocumentsFromBulkWriteResponse","stackCheckpoints","appendToArray","createRevision","ensureNotFalsy","flatClone","getDefaultRevision","getHeightOfRevision","now","PROMISE_RESOLVE_VOID","getLastCheckpointDoc","setCheckpoint","stripAttachmentsDataFromMetaWriteRows","writeDocToDocState","getAssumedMasterState","getMetaWriteRow","startReplicationDownstream","state","input","initialCheckpoint","downstream","checkpointDoc","identifierHash","hashFunction","identifier","replicationHandler","timer","openTasks","addNewTask","task","stats","down","taskWithTime","time","push","streamQueue","then","useTasks","length","events","active","next","innerTaskWithTime","shift","lastTimeMasterChangesRequested","downstreamResyncOnce","downstreamProcessChanges","firstSyncDone","getValue","canceled","sub","masterChangeStream$","pipe","ev","up","s","subscribe","masterChangeStreamEmit","unsubscribe","checkpointQueue","lastCheckpoint","promises","downResult","masterChangesSince","pullBatchSize","documents","checkpoint","persistFromMaster","Promise","all","tasks","docsOfAllTasks","forEach","Error","persistenceQueue","nonPersistedFromMaster","docs","primaryPath","docData","docId","downDocsById","useCheckpoint","docIds","Object","keys","writeRowsToFork","writeRowsToForkById","writeRowsToMeta","useMetaWriteRows","forkInstance","findDocumentsById","currentForkStateList","assumedMasterState","currentForkState","Map","doc","set","map","forkStateFullDoc","get","forkStateDocData","hasAttachments","undefined","masterState","assumedMaster","metaDocument","isResolvedConflict","_rev","isAssumedMasterEqualToForkState","conflictHandler","isEqual","_meta","areStatesExactlyEqual","newForkState","assign","_attachments","lwt","nextRevisionHeight","keepMeta","forkWriteRow","previous","document","bulkWrite","downstreamBulkWriteFlag","forkWriteResult","success","processed","mustThrow","error","status","throwMe","writeError","metaInstance","metaWriteResult","id","documentId","catch","unhandledError"],"sources":["../../../src/replication-protocol/downstream.ts"],"sourcesContent":["import {\n    firstValueFrom,\n    filter,\n    mergeMap\n} from 'rxjs';\nimport { newRxError } from '../rx-error.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\nimport type {\n    RxStorageInstanceReplicationState,\n    BulkWriteRow,\n    BulkWriteRowById,\n    RxStorageReplicationMeta,\n    RxDocumentData,\n    ById,\n    WithDeleted,\n    DocumentsWithCheckpoint,\n    WithDeletedAndAttachments,\n    RxError\n} from '../types/index.d.ts';\nimport {\n    appendToArray,\n    createRevision,\n    ensureNotFalsy,\n    flatClone,\n    getDefaultRevision,\n    getHeightOfRevision,\n    now,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint.ts';\nimport {\n    stripAttachmentsDataFromMetaWriteRows,\n    writeDocToDocState\n} from './helper.ts';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance.ts';\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream<RxDocType, CheckpointType = any>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    if (\n        state.input.initialCheckpoint &&\n        state.input.initialCheckpoint.downstream\n    ) {\n        const checkpointDoc = await getLastCheckpointDoc(state, 'down');\n        if (!checkpointDoc) {\n            await setCheckpoint(\n                state,\n                'down',\n                state.input.initialCheckpoint.downstream\n            );\n        }\n    }\n\n    const identifierHash = await state.input.hashFunction(state.input.identifier);\n    const replicationHandler = state.input.replicationHandler;\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n\n\n    type Task = DocumentsWithCheckpoint<RxDocType, any> | 'RESYNC';\n    type TaskWithTime = {\n        time: number;\n        task: Task;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    function addNewTask(task: Task): void {\n        state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n        const taskWithTime = {\n            time: timer++,\n            task\n        };\n        openTasks.push(taskWithTime);\n        state.streamQueue.down = state.streamQueue.down\n            .then(() => {\n                const useTasks: Task[] = [];\n                while (openTasks.length > 0) {\n                    state.events.active.down.next(true);\n                    const innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n                    /**\n                     * If the task came in before the last time we started the pull\n                     * from the master, then we can drop the task.\n                     */\n                    if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n                        continue;\n                    }\n\n                    if (innerTaskWithTime.task === 'RESYNC') {\n                        if (useTasks.length === 0) {\n                            useTasks.push(innerTaskWithTime.task);\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    useTasks.push(innerTaskWithTime.task);\n                }\n                if (useTasks.length === 0) {\n                    return;\n                }\n\n                if (useTasks[0] === 'RESYNC') {\n                    return downstreamResyncOnce();\n                } else {\n                    return downstreamProcessChanges(useTasks);\n                }\n            }).then(() => {\n                state.events.active.down.next(false);\n                if (\n                    !state.firstSyncDone.down.getValue() &&\n                    !state.events.canceled.getValue()\n                ) {\n                    state.firstSyncDone.down.next(true);\n                }\n            });\n    }\n    addNewTask('RESYNC');\n\n    /**\n     * If a write on the master happens, we have to trigger the downstream.\n     * Only do this if not canceled yet, otherwise firstValueFrom errors\n     * when running on a completed observable.\n     */\n    if (!state.events.canceled.getValue()) {\n        const sub = replicationHandler\n            .masterChangeStream$\n            .pipe(\n                mergeMap(async (ev) => {\n                    /**\n                     * While a push is running, we have to delay all incoming\n                     * events from the server to not mix up the replication state.\n                     */\n                    await firstValueFrom(\n                        state.events.active.up.pipe(filter(s => !s))\n                    );\n                    return ev;\n                })\n            )\n            .subscribe((task: Task) => {\n                state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n                addNewTask(task);\n            });\n        // unsubscribe when replication is canceled\n        firstValueFrom(\n            state.events.canceled.pipe(\n                filter(canceled => !!canceled)\n            )\n        ).then(() => sub.unsubscribe());\n    }\n\n\n    /**\n     * For faster performance, we directly start each write\n     * and then await all writes at the end.\n     */\n    let lastTimeMasterChangesRequested: number = -1;\n    async function downstreamResyncOnce() {\n        state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            lastTimeMasterChangesRequested = timer++;\n            const downResult = await replicationHandler.masterChangesSince(\n                lastCheckpoint,\n                state.input.pullBatchSize\n            );\n\n            if (downResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n\n            promises.push(\n                persistFromMaster(\n                    downResult.documents,\n                    lastCheckpoint\n                )\n            );\n\n            /**\n             * By definition we stop pull when the pulled documents\n             * do not fill up the pullBatchSize because we\n             * can assume that the remote has no more documents.\n             */\n            if (downResult.documents.length < state.input.pullBatchSize) {\n                break;\n            }\n\n        }\n        await Promise.all(promises);\n    }\n\n\n    function downstreamProcessChanges(tasks: Task[]) {\n        state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n        const docsOfAllTasks: WithDeleted<RxDocType>[] = [];\n        let lastCheckpoint: CheckpointType | undefined = null as any;\n\n        tasks.forEach(task => {\n            if (task === 'RESYNC') {\n                throw new Error('SNH');\n            }\n            appendToArray(docsOfAllTasks, task.documents);\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n        });\n        return persistFromMaster(\n            docsOfAllTasks,\n            ensureNotFalsy(lastCheckpoint)\n        );\n    }\n\n\n    /**\n     * It can happen that the calls to masterChangesSince() or the changeStream()\n     * are way faster then how fast the documents can be persisted.\n     * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n     * and process them together if possible.\n     * This often bundles up single writes and improves performance\n     * by processing the documents in bulks.\n     */\n    let persistenceQueue = PROMISE_RESOLVE_VOID;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<WithDeleted<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    function persistFromMaster(\n        docs: WithDeleted<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<void> {\n        const primaryPath = state.primaryPath;\n        state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistent list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n        /**\n         * Run in the queue\n         * with all open documents from nonPersistedFromMaster.\n         */\n        persistenceQueue = persistenceQueue.then(() => {\n            const downDocsById: ById<WithDeletedAndAttachments<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(downDocsById);\n\n            if (\n                state.events.canceled.getValue() ||\n                docIds.length === 0\n            ) {\n                return PROMISE_RESOLVE_VOID;\n            }\n\n            const writeRowsToFork: BulkWriteRow<RxDocType>[] = [];\n            const writeRowsToForkById: ById<BulkWriteRow<RxDocType>> = {};\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {};\n            const useMetaWriteRows: BulkWriteRow<RxStorageReplicationMeta<RxDocType, CheckpointType>>[] = [];\n\n            return Promise.all([\n                state.input.forkInstance.findDocumentsById(docIds, true),\n                getAssumedMasterState(\n                    state,\n                    docIds\n                )\n            ]).then(([\n                currentForkStateList,\n                assumedMasterState\n            ]) => {\n                const currentForkState = new Map<string, RxDocumentData<RxDocType>>();\n                currentForkStateList.forEach(doc => currentForkState.set((doc as any)[primaryPath], doc));\n                return Promise.all(\n                    docIds.map(async (docId) => {\n                        const forkStateFullDoc: RxDocumentData<RxDocType> | undefined = currentForkState.get(docId);\n                        const forkStateDocData: WithDeletedAndAttachments<RxDocType> | undefined = forkStateFullDoc\n                            ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false)\n                            : undefined\n                            ;\n                        const masterState = downDocsById[docId];\n                        const assumedMaster = assumedMasterState[docId];\n\n                        if (\n                            assumedMaster &&\n                            forkStateFullDoc &&\n                            assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev\n                        ) {\n                            /**\n                             * The current fork state represents a resolved conflict\n                             * that first must be send to the master in the upstream.\n                             * All conflicts are resolved by the upstream.\n                             */\n                            // return PROMISE_RESOLVE_VOID;\n                            await state.streamQueue.up;\n                        }\n\n                        let isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ?\n                            false :\n                            state.input.conflictHandler.isEqual(\n                                assumedMaster.docData,\n                                forkStateDocData,\n                                'downstream-check-if-equal-0'\n                            );\n                        if (\n                            !isAssumedMasterEqualToForkState &&\n                            (\n                                assumedMaster &&\n                                (assumedMaster.docData as any)._rev &&\n                                forkStateFullDoc &&\n                                forkStateFullDoc._meta[state.input.identifier] &&\n                                getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]\n                            )\n                        ) {\n                            isAssumedMasterEqualToForkState = true;\n                        }\n                        if (\n                            (\n                                forkStateFullDoc &&\n                                assumedMaster &&\n                                isAssumedMasterEqualToForkState === false\n                            ) ||\n                            (\n                                forkStateFullDoc && !assumedMaster\n                            )\n                        ) {\n                            /**\n                             * We have a non-upstream-replicated\n                             * local write to the fork.\n                             * This means we ignore the downstream of this document\n                             * because anyway the upstream will first resolve the conflict.\n                             */\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        const areStatesExactlyEqual = !forkStateDocData\n                            ? false\n                            : state.input.conflictHandler.isEqual(\n                                masterState,\n                                forkStateDocData,\n                                'downstream-check-if-equal-1'\n                            );\n                        if (\n                            forkStateDocData &&\n                            areStatesExactlyEqual\n                        ) {\n                            /**\n                             * Document states are exactly equal.\n                             * This can happen when the replication is shut down\n                             * unexpected like when the user goes offline.\n                             *\n                             * Only when the assumedMaster is different from the forkState,\n                             * we have to patch the document in the meta instance.\n                             */\n                            if (\n                                !assumedMaster ||\n                                isAssumedMasterEqualToForkState === false\n                            ) {\n                                useMetaWriteRows.push(\n                                    await getMetaWriteRow(\n                                        state,\n                                        forkStateDocData,\n                                        assumedMaster ? assumedMaster.metaDocument : undefined\n                                    )\n                                );\n                            }\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        /**\n                         * All other master states need to be written to the forkInstance\n                         * and metaInstance.\n                         */\n                        const newForkState = Object.assign(\n                            {},\n                            masterState,\n                            forkStateFullDoc ? {\n                                _meta: flatClone(forkStateFullDoc._meta),\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n                                _rev: getDefaultRevision()\n                            } : {\n                                _meta: {\n                                    lwt: now()\n                                },\n                                _rev: getDefaultRevision(),\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n                            }\n                        );\n                        /**\n                         * If the remote works with revisions,\n                         * we store the height of the next fork-state revision\n                         * inside of the documents meta data.\n                         * By doing so we can filter it out in the upstream\n                         * and detect the document as being equal to master or not.\n                         * This is used for example in the CouchDB replication plugin.\n                         */\n                        if ((masterState as any)._rev) {\n                            const nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n                            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n                            if (state.input.keepMeta) {\n                                newForkState._rev = (masterState as any)._rev;\n                            }\n                        }\n                        if (\n                            state.input.keepMeta &&\n                            (masterState as any)._meta\n                        ) {\n                            newForkState._meta = (masterState as any)._meta;\n                        }\n\n                        const forkWriteRow = {\n                            previous: forkStateFullDoc,\n                            document: newForkState\n                        };\n\n                        forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(\n                            identifierHash,\n                            forkWriteRow.previous\n                        );\n                        writeRowsToFork.push(forkWriteRow);\n                        writeRowsToForkById[docId] = forkWriteRow;\n                        writeRowsToMeta[docId] = await getMetaWriteRow(\n                            state,\n                            masterState,\n                            assumedMaster ? assumedMaster.metaDocument : undefined\n                        );\n                    })\n                );\n            }).then(async () => {\n                if (writeRowsToFork.length > 0) {\n                    return state.input.forkInstance.bulkWrite(\n                        writeRowsToFork,\n                        await state.downstreamBulkWriteFlag\n                    ).then((forkWriteResult) => {\n                        const success = getWrittenDocumentsFromBulkWriteResponse(\n                            state.primaryPath,\n                            writeRowsToFork,\n                            forkWriteResult\n                        );\n                        success.forEach(doc => {\n                            const docId = (doc as any)[primaryPath];\n                            state.events.processed.down.next(writeRowsToForkById[docId]);\n                            useMetaWriteRows.push(writeRowsToMeta[docId]);\n                        });\n                        let mustThrow: RxError | undefined;\n                        forkWriteResult.error.forEach(error => {\n                            /**\n                             * We do not have to care about downstream conflict errors here\n                             * because on conflict, it will be solved locally and result in another write.\n                             */\n                            if (error.status === 409) {\n                                return;\n                            }\n                            // other non-conflict errors must be handled\n                            const throwMe = newRxError('RC_PULL', {\n                                writeError: error\n                            });\n                            state.events.error.next(throwMe);\n                            mustThrow = throwMe;\n                        });\n                        if (mustThrow) {\n                            throw mustThrow;\n                        }\n                    });\n                }\n            }).then(() => {\n                if (useMetaWriteRows.length > 0) {\n                    return state.input.metaInstance.bulkWrite(\n                        stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows),\n                        'replication-down-write-meta'\n                    ).then(metaWriteResult => {\n                        metaWriteResult.error\n                            .forEach(writeError => {\n                                state.events.error.next(newRxError('RC_PULL', {\n                                    id: writeError.documentId,\n                                    writeError\n                                }));\n                            });\n                    });\n                }\n            }).then(() => {\n                /**\n                 * For better performance we do not await checkpoint writes,\n                 * but to ensure order on parallel checkpoint writes,\n                 * we have to use a queue.\n                 */\n                setCheckpoint(\n                    state,\n                    'down',\n                    useCheckpoint\n                );\n            });\n        }).catch(unhandledError => state.events.error.next(unhandledError));\n        return persistenceQueue;\n    }\n}\n"],"mappings":"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","ignoreList":[]}