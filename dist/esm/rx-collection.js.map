{"version":3,"file":"rx-collection.js","names":["filter","map","mergeMap","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","removeCollectionStorages","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocumentCache","mapDocumentsDataToCacheDocs","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createNewRxDocument","getWrappedStorageInstance","storageChangeEventToRxChangeEvent","throwIfIsStorageWriteError","defaultConflictHandler","IncrementalWriteQueue","beforeDocumentUpdateWrite","overwritable","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","conflictHandler","storageInstance","timeouts","Set","incrementalWriteQueue","_incrementalUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","checkpoint$","_changeEventBuffer","onDestroy","destroyed","_applyHookFunctions","asRxCollection","_proto","prototype","prepare","jsonSchema","primaryPath","newData","oldData","result","_runHooks","collectionEventBulks$","eventBulks$","pipe","changeEventBulk","collectionName","events","checkpoint","cE","isLocal","docData","databaseStorageToken","storageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","ev","databaseToken","token","context","endTime","startTime","$emit","push","conflictResultionTasks","task","input","then","output","resolveConflictResultionTask","cleanup","_minimumDeletedTime","migrationNeeded","getMigrationState","startMigration","batchSize","migratePromise","insert","json","writeResult","bulkInsert","isError","error","insertResult","success","docsData","length","useDocs","useDocData","docs","hasHooks","Promise","all","doc","insertRows","row","document","results","bulkWrite","rxDocuments","docsMap","forEach","set","get","primary","bulkRemove","ids","rxDocumentMap","findByIds","exec","Array","from","values","rxDocument","data","toMutableJSON","removeDocs","writeDoc","_deleted","previous","successIds","d","bulkUpsert","insertData","useJsonByDocId","useJson","slice","err","status","documentId","writeData","docDataInDb","documentInDb","getCachedRxDocument","newDoc","incrementalModify","upsert","bulkResult","incrementalUpsert","queue","_incrementalUpsertEnsureRxDocumentExists","wasInserted","inserted","_incrementalUpsertUpdate","find","queryObj","query","findOne","isArray","selector","limit","count","mangoQuery","$in","exportJSON","importJSON","_exportedJSON","insertCRDT","_updateObj","addHook","when","key","fun","parallel","includes","boundFun","bind","runName","series","getHooks","instance","tasks","hook","_runHooksSync","promiseWait","time","ret","res","timeout","setTimeout","delete","add","destroy","clearTimeout","requestIdlePromise","fn","close","sub","unsubscribe","collections","remove","storage","internalStore","password","hashFunction","_createClass","operation","collection","colProto","Object","getPrototypeOf","fnName","_innerDoc","rxCollection","docDataFromCache","getLatestDocumentDataIfExists","resolve","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","multiInstance","devMode","isDevMode","entries","funName","defineProperty","version","creator","catch","reject","isRxCollection","obj"],"sources":["../../src/rx-collection.ts"],"sourcesContent":["import {\n    filter,\n    map,\n    mergeMap\n} from 'rxjs';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages\n} from './rx-collection-helper.ts';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query.ts';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error.ts';\nimport type {\n    RxMigrationState\n} from './plugins/migration-schema/index.ts';\nimport {\n    DocumentCache, mapDocumentsDataToCacheDocs\n} from './doc-cache.ts';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache.ts';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer.ts';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks.ts';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageWriteError,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise,\n    CRDTEntry,\n    MangoQuerySelectorAndIndex,\n    MigrationStrategies\n} from './types/index.d.ts';\n\nimport {\n    RxSchema\n} from './rx-schema.ts';\n\nimport {\n    createNewRxDocument\n} from './rx-document-prototype-merge.ts';\nimport {\n    getWrappedStorageInstance,\n    storageChangeEventToRxChangeEvent,\n    throwIfIsStorageWriteError,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport { defaultConflictHandler } from './replication-protocol/index.ts';\nimport { IncrementalWriteQueue } from './incremental-write.ts';\nimport { beforeDocumentUpdateWrite } from './rx-document.ts';\nimport { overwritable } from './overwritable.ts';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any; },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any; },\n    Reactivity = any\n> {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: WrappedRxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n    public incrementalWriteQueue: IncrementalWriteQueue<RxDocumentType> = {} as any;\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions, Reactivity>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: MigrationStrategies = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _incrementalUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocumentCache<RxDocumentType, OrmMethods> = {} as any;\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public checkpoint$: Observable<any> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer<RxDocumentType> = {} as ChangeEventBuffer<RxDocumentType>;\n\n\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n    public onDestroy: (() => MaybePromise<any>)[] = [];\n    public destroyed = false;\n\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n        this.incrementalWriteQueue = new IncrementalWriteQueue<RxDocumentType>(\n            this.storageInstance,\n            this.schema.primaryPath,\n            (newData, oldData) => beforeDocumentUpdateWrite(this as any, newData, oldData),\n            result => this._runHooks('post', 'save', result)\n        );\n\n        const collectionEventBulks$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n        );\n        this.$ = collectionEventBulks$.pipe(\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this.checkpoint$ = collectionEventBulks$.pipe(\n            map(changeEventBulk => changeEventBulk.checkpoint),\n        );\n\n        this._changeEventBuffer = createChangeEventBuffer<RxDocumentType>(this.asRxCollection);\n        this._docCache = new DocumentCache(\n            this.schema.primaryPath,\n            this.$.pipe(filter(cE => !cE.isLocal)),\n            docData => createNewRxDocument(this.asRxCollection, docData)\n        );\n\n        /**\n         * Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(\n                    false,\n                    ev,\n                    this as any\n                )),\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context,\n                endTime: eventBulk.endTime,\n                startTime: eventBulk.startTime\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * Resolve the conflict tasks\n         * of the RxStorageInstance\n         */\n        this._subs.push(\n            this.storageInstance\n                .conflictResultionTasks()\n                .subscribe(task => {\n                    this\n                        .conflictHandler(task.input, task.context)\n                        .then(output => {\n                            this.storageInstance.resolveConflictResultionTask({\n                                id: task.id,\n                                output\n                            });\n                        });\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    /**\n     * Manually call the cleanup function of the storage.\n     * @link https://rxdb.info/cleanup.html\n     */\n    cleanup(_minimumDeletedTime?: number): Promise<boolean> {\n        throw pluginMissing('cleanup');\n    }\n\n    // overwritten by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration-schema');\n    }\n    getMigrationState(): RxMigrationState {\n        throw pluginMissing('migration-schema');\n    }\n    startMigration(batchSize: number = 10): Promise<void> {\n        return this.getMigrationState().startMigration(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getMigrationState().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const writeResult = await this.bulkInsert([json as any]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, (json as any)[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n        */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const primaryPath = this.schema.primaryPath;\n        const useDocs = docsData.map(docData => {\n            const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n            return useDocData;\n        });\n        const docs = this.hasHooks('pre', 'insert') ?\n            await Promise.all(\n                useDocs.map(doc => {\n                    return this._runHooks('pre', 'insert', doc)\n                        .then(() => {\n                            return doc;\n                        });\n                })\n            ) : useDocs;\n        const insertRows: BulkWriteRow<RxDocumentType>[] = docs.map(doc => {\n            const row: BulkWriteRow<RxDocumentType> = { document: doc };\n            return row;\n        });\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n        // create documents\n        const rxDocuments = mapDocumentsDataToCacheDocs<RxDocumentType, OrmMethods>(this._docCache, results.success);\n\n        if (this.hasHooks('post', 'insert')) {\n            const docsMap: Map<string, RxDocumentType> = new Map();\n            docs.forEach(doc => {\n                docsMap.set((doc as any)[primaryPath] as any, doc);\n            });\n            await Promise.all(\n                rxDocuments.map(doc => {\n                    return this._runHooks(\n                        'post', 'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return {\n            success: rxDocuments,\n            error: results.error\n        };\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        const primaryPath = this.schema.primaryPath;\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids).exec();\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = rxDocument.toMutableJSON(true) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n        const successIds: string[] = results.success.map(d => d[primaryPath] as string);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments = successIds.map(id => getFromMapOrThrow(rxDocumentMap, id));\n\n        return {\n            success: rxDocuments,\n            error: results.error\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        const success = insertResult.success.slice(0);\n        const error: RxStorageWriteError<RxDocumentType>[] = [];\n\n        // update the ones that existed already\n        await Promise.all(\n            insertResult.error.map(async (err) => {\n                if (err.status !== 409) {\n                    error.push(err);\n                } else {\n                    const id = err.documentId;\n                    const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                    const docDataInDb = ensureNotFalsy(err.documentInDb);\n                    const doc = this._docCache.getCachedRxDocument(docDataInDb);\n                    const newDoc = await doc.incrementalModify(() => writeData);\n                    success.push(newDoc);\n                }\n            })\n        );\n        return {\n            error,\n            success\n        };\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    async upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const bulkResult = await this.bulkUpsert([json]);\n        throwIfIsStorageWriteError<RxDocumentType>(\n            this.asRxCollection,\n            (json as any)[this.schema.primaryPath],\n            json as any,\n            bulkResult.error[0]\n        );\n        return bulkResult.success[0];\n    }\n\n    /**\n     * upserts to a RxDocument, uses incrementalModify if document already exists\n     */\n    incrementalUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it won't try 2 parallel runs\n        let queue = this._incrementalUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _incrementalUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._incrementalUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[],\n        OrmMethods,\n        Reactivity\n    > {\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(\n        queryObj?: MangoQueryNoLimit<RxDocumentType> | string\n    ): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods> | null,\n        OrmMethods,\n        Reactivity\n    > {\n\n        // TODO move this check to dev-mode plugin\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n\n            // cannot have limit on findOne queries because it will be overwritten\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            queryObj = flatClone(queryObj);\n            (queryObj as any).limit = 1;\n            query = createRxQuery<RxDocumentType>('findOne', queryObj, this as any);\n        }\n\n\n        return query as any;\n    }\n\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        number,\n        OrmMethods,\n        Reactivity\n    > {\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n        const query = createRxQuery('count', queryObj, this as any);\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    findByIds(\n        ids: string[]\n    ): RxQuery<\n        RxDocumentType,\n        Map<string, RxDocument<RxDocumentType, OrmMethods>>,\n        OrmMethods,\n        Reactivity\n    > {\n        const mangoQuery: MangoQuery<RxDocumentType> = {\n            selector: {\n                [this.schema.primaryPath]: {\n                    $in: ids.slice(0)\n                }\n            } as any\n        };\n        const query = createRxQuery('findByIds', mangoQuery, this as any);\n        return query as any;\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\n        throw pluginMissing('crdt');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => Promise.all(this.onDestroy.map(fn => fn())))\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.destroy();\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.password,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods, any, Reactivity> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _incrementalUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.incrementalModify((_innerDoc) => {\n        return json;\n    });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists<RxDocType>(\n    rxCollection: RxCollection<RxDocType>,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument<RxDocType>;\n        inserted: boolean;\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n    if (docDataFromCache) {\n        return Promise.resolve({\n            doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password,\n        devMode: overwritable.isDevMode()\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics,\n            conflictHandler\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n"],"mappings":";AAAA,SACIA,MAAM,EACNC,GAAG,EACHC,QAAQ,QACL,MAAM;AAEb,SACIC,OAAO,EACPC,SAAS,EACTC,aAAa,EACbC,aAAa,EACbC,cAAc,EACdC,iBAAiB,EACjBC,qBAAqB,EACrBC,oBAAoB,QACjB,0BAA0B;AACjC,SACIC,0BAA0B,EAC1BC,iCAAiC,EACjCC,wBAAwB,QACrB,2BAA2B;AAClC,SACIC,aAAa,EACbC,gBAAgB,QACb,eAAe;AACtB,SACIC,UAAU,EACVC,cAAc,QACX,eAAe;AAItB,SACIC,aAAa,EAAEC,2BAA2B,QACvC,gBAAgB;AACvB,SAEIC,gBAAgB,EAChBC,6BAA6B,QAC1B,kBAAkB;AACzB,SAEIC,uBAAuB,QACpB,0BAA0B;AACjC,SACIC,mBAAmB,EACnBC,cAAc,QACX,YAAY;AA0CnB,SACIC,mBAAmB,QAChB,kCAAkC;AACzC,SACIC,yBAAyB,EACzBC,iCAAiC,EACjCC,0BAA0B,QAEvB,wBAAwB;AAC/B,SAASC,sBAAsB,QAAQ,iCAAiC;AACxE,SAASC,qBAAqB,QAAQ,wBAAwB;AAC9D,SAASC,yBAAyB,QAAQ,kBAAkB;AAC5D,SAASC,YAAY,QAAQ,mBAAmB;AAEhD,IAAMC,UAAU,GAAG,CAAC,KAAK,EAAE,MAAM,CAAU;AAE3C,IAAMC,UAAU,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAU;AAElE,IAAIC,YAAY,GAAG,KAAK;AAExB,WAAaC,gBAAgB;EASzB;AACJ;AACA;;EAKI,SAAAA,iBACWC,QAAqF,EACrFC,IAAY,EACZC,MAAgC,EAChCC,uBAAwF,EACxFC,uBAAgD,GAAG,CAAC,CAAQ,EAC5DC,mBAAwC,GAAG,CAAC,CAAC,EAC7CC,OAAuB,GAAG,CAAC,CAAC,EAC5BC,WAA2B,GAAG,CAAC,CAAC,EAChCC,OAAY,GAAG,CAAC,CAAC,EACjBC,sBAAgD,GAAGzB,6BAA6B,EAChF0B,OAAuB,GAAG,CAAC,CAAC,EAC5BC,eAAkD,GAAGnB,sBAAsB,EACpF;IAAA,KAjBKoB,eAAe,GAA2E,CAAC,CAAC;IAAA,KACnFC,QAAQ,GAAuC,IAAIC,GAAG,CAAC,CAAC;IAAA,KACjEC,qBAAqB,GAA0C,CAAC,CAAC;IAAA,KAmCjEC,wBAAwB,GAA8B,IAAIC,GAAG,CAAC,CAAC;IAAA,KAE/DC,MAAM,GAAY,KAAK;IAAA,KACvBC,KAAK,GAOR,CAAC,CAAC;IAAA,KACCC,KAAK,GAAmB,EAAE;IAAA,KAE1BC,SAAS,GAA8C,CAAC,CAAC;IAAA,KAEzDC,WAAW,GAAevC,gBAAgB,CAAC,CAAC;IAAA,KAC5CwC,CAAC,GAA8C,CAAC,CAAC;IAAA,KACjDC,WAAW,GAAoB,CAAC,CAAC;IAAA,KACjCC,kBAAkB,GAAsC,CAAC,CAAC;IAAA,KAU1DC,SAAS,GAAgC,EAAE;IAAA,KAC3CC,SAAS,GAAG,KAAK;IAAA,KA7Db3B,QAAqF,GAArFA,QAAqF;IAAA,KACrFC,IAAY,GAAZA,IAAY;IAAA,KACZC,MAAgC,GAAhCA,MAAgC;IAAA,KAChCC,uBAAwF,GAAxFA,uBAAwF;IAAA,KACxFC,uBAAgD,GAAhDA,uBAAgD;IAAA,KAChDC,mBAAwC,GAAxCA,mBAAwC;IAAA,KACxCC,OAAuB,GAAvBA,OAAuB;IAAA,KACvBC,WAA2B,GAA3BA,WAA2B;IAAA,KAC3BC,OAAY,GAAZA,OAAY;IAAA,KACZC,sBAAgD,GAAhDA,sBAAgD;IAAA,KAChDC,OAAuB,GAAvBA,OAAuB;IAAA,KACvBC,eAAkD,GAAlDA,eAAkD;IAEzDiB,mBAAmB,CAAC,IAAI,CAACC,cAAc,CAAC;EAC5C;EAAC,IAAAC,MAAA,GAAA/B,gBAAA,CAAAgC,SAAA;EAAAD,MAAA,CAiDYE,OAAO,GAApB,eAAAA,QAAA,EAAsC;IAClC,IAAI,CAACpB,eAAe,GAAGvB,yBAAyB,CAC5C,IAAI,CAACW,QAAQ,EACb,IAAI,CAACG,uBAAuB,EAC5B,IAAI,CAACD,MAAM,CAAC+B,UAChB,CAAC;IACD,IAAI,CAAClB,qBAAqB,GAAG,IAAItB,qBAAqB,CAClD,IAAI,CAACmB,eAAe,EACpB,IAAI,CAACV,MAAM,CAACgC,WAAW,EACvB,CAACC,OAAO,EAAEC,OAAO,KAAK1C,yBAAyB,CAAC,IAAI,EAASyC,OAAO,EAAEC,OAAO,CAAC,EAC9EC,MAAM,IAAI,IAAI,CAACC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAED,MAAM,CACnD,CAAC;IAED,IAAME,qBAAqB,GAAG,IAAI,CAACvC,QAAQ,CAACwC,WAAW,CAACC,IAAI,CACxD9E,MAAM,CAAC+E,eAAe,IAAIA,eAAe,CAACC,cAAc,KAAK,IAAI,CAAC1C,IAAI,CAC1E,CAAC;IACD,IAAI,CAACsB,CAAC,GAAGgB,qBAAqB,CAACE,IAAI,CAC/B5E,QAAQ,CAAC6E,eAAe,IAAIA,eAAe,CAACE,MAAM,CACtD,CAAC;IACD,IAAI,CAACpB,WAAW,GAAGe,qBAAqB,CAACE,IAAI,CACzC7E,GAAG,CAAC8E,eAAe,IAAIA,eAAe,CAACG,UAAU,CACrD,CAAC;IAED,IAAI,CAACpB,kBAAkB,GAAGxC,uBAAuB,CAAiB,IAAI,CAAC4C,cAAc,CAAC;IACtF,IAAI,CAACR,SAAS,GAAG,IAAIxC,aAAa,CAC9B,IAAI,CAACqB,MAAM,CAACgC,WAAW,EACvB,IAAI,CAACX,CAAC,CAACkB,IAAI,CAAC9E,MAAM,CAACmF,EAAE,IAAI,CAACA,EAAE,CAACC,OAAO,CAAC,CAAC,EACtCC,OAAO,IAAI5D,mBAAmB,CAAC,IAAI,CAACyC,cAAc,EAAEmB,OAAO,CAC/D,CAAC;;IAED;AACR;AACA;AACA;AACA;IACQ,IAAMC,oBAAoB,GAAG,MAAM,IAAI,CAACjD,QAAQ,CAACkD,YAAY;IAC7D,IAAMC,OAAO,GAAG,IAAI,CAACvC,eAAe,CAACwC,YAAY,CAAC,CAAC,CAACC,SAAS,CAACC,SAAS,IAAI;MACvE,IAAMZ,eAAwE,GAAG;QAC7Ea,EAAE,EAAED,SAAS,CAACC,EAAE;QAChBC,QAAQ,EAAE,KAAK;QACfb,cAAc,EAAE,IAAI,CAAC1C,IAAI;QACzBiD,YAAY,EAAED,oBAAoB;QAClCL,MAAM,EAAEU,SAAS,CAACV,MAAM,CAAChF,GAAG,CAAC6F,EAAE,IAAInE,iCAAiC,CAChE,KAAK,EACLmE,EAAE,EACF,IACJ,CAAC,CAAC;QACFC,aAAa,EAAE,IAAI,CAAC1D,QAAQ,CAAC2D,KAAK;QAClCd,UAAU,EAAES,SAAS,CAACT,UAAU;QAChCe,OAAO,EAAEN,SAAS,CAACM,OAAO;QAC1BC,OAAO,EAAEP,SAAS,CAACO,OAAO;QAC1BC,SAAS,EAAER,SAAS,CAACQ;MACzB,CAAC;MACD,IAAI,CAAC9D,QAAQ,CAAC+D,KAAK,CAACrB,eAAe,CAAC;IACxC,CAAC,CAAC;IACF,IAAI,CAACtB,KAAK,CAAC4C,IAAI,CAACb,OAAO,CAAC;;IAExB;AACR;AACA;AACA;IACQ,IAAI,CAAC/B,KAAK,CAAC4C,IAAI,CACX,IAAI,CAACpD,eAAe,CACfqD,sBAAsB,CAAC,CAAC,CACxBZ,SAAS,CAACa,IAAI,IAAI;MACf,IAAI,CACCvD,eAAe,CAACuD,IAAI,CAACC,KAAK,EAAED,IAAI,CAACN,OAAO,CAAC,CACzCQ,IAAI,CAACC,MAAM,IAAI;QACZ,IAAI,CAACzD,eAAe,CAAC0D,4BAA4B,CAAC;UAC9Cf,EAAE,EAAEW,IAAI,CAACX,EAAE;UACXc;QACJ,CAAC,CAAC;MACN,CAAC,CAAC;IACV,CAAC,CACT,CAAC;IAED,OAAOhG,oBAAoB;EAC/B;;EAGA;AACJ;AACA;AACA,KAHI;EAAAyD,MAAA,CAIAyC,OAAO,GAAP,SAAAA,QAAQC,mBAA4B,EAAoB;IACpD,MAAMvG,aAAa,CAAC,SAAS,CAAC;EAClC;;EAEA;EAAA;EAAA6D,MAAA,CACA2C,eAAe,GAAf,SAAAA,gBAAA,EAAoC;IAChC,MAAMxG,aAAa,CAAC,kBAAkB,CAAC;EAC3C,CAAC;EAAA6D,MAAA,CACD4C,iBAAiB,GAAjB,SAAAA,kBAAA,EAAsC;IAClC,MAAMzG,aAAa,CAAC,kBAAkB,CAAC;EAC3C,CAAC;EAAA6D,MAAA,CACD6C,cAAc,GAAd,SAAAA,eAAeC,SAAiB,GAAG,EAAE,EAAiB;IAClD,OAAO,IAAI,CAACF,iBAAiB,CAAC,CAAC,CAACC,cAAc,CAACC,SAAS,CAAC;EAC7D,CAAC;EAAA9C,MAAA,CACD+C,cAAc,GAAd,SAAAA,eAAeD,SAAiB,GAAG,EAAE,EAAgB;IACjD,OAAO,IAAI,CAACF,iBAAiB,CAAC,CAAC,CAACG,cAAc,CAACD,SAAS,CAAC;EAC7D,CAAC;EAAA9C,MAAA,CAEKgD,MAAM,GAAZ,eAAAA,OACIC,IAAiC,EACc;IAC/C,IAAMC,WAAW,GAAG,MAAM,IAAI,CAACC,UAAU,CAAC,CAACF,IAAI,CAAQ,CAAC;IAExD,IAAMG,OAAO,GAAGF,WAAW,CAACG,KAAK,CAAC,CAAC,CAAC;IACpC5F,0BAA0B,CAAC,IAAI,EAAUwF,IAAI,CAAS,IAAI,CAAC7E,MAAM,CAACgC,WAAW,CAAC,EAAS6C,IAAI,EAAEG,OAAO,CAAC;IACrG,IAAME,YAAY,GAAGlH,cAAc,CAAC8G,WAAW,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;IAC3D,OAAOD,YAAY;EACvB,CAAC;EAAAtD,MAAA,CAEKmD,UAAU,GAAhB,eAAAA,WACIK,QAA0B,EAI3B;IACC;AACR;AACA;AACA;IACQ,IAAIA,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MACvB,OAAO;QACHF,OAAO,EAAE,EAAE;QACXF,KAAK,EAAE;MACX,CAAC;IACL;IAEA,IAAMjD,WAAW,GAAG,IAAI,CAAChC,MAAM,CAACgC,WAAW;IAC3C,IAAMsD,OAAO,GAAGF,QAAQ,CAAC1H,GAAG,CAACoF,OAAO,IAAI;MACpC,IAAMyC,UAAU,GAAGnH,0BAA0B,CAAC,IAAI,CAAC4B,MAAM,EAAE8C,OAAO,CAAC;MACnE,OAAOyC,UAAU;IACrB,CAAC,CAAC;IACF,IAAMC,IAAI,GAAG,IAAI,CAACC,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,GACvC,MAAMC,OAAO,CAACC,GAAG,CACbL,OAAO,CAAC5H,GAAG,CAACkI,GAAG,IAAI;MACf,OAAO,IAAI,CAACxD,SAAS,CAAC,KAAK,EAAE,QAAQ,EAAEwD,GAAG,CAAC,CACtC1B,IAAI,CAAC,MAAM;QACR,OAAO0B,GAAG;MACd,CAAC,CAAC;IACV,CAAC,CACL,CAAC,GAAGN,OAAO;IACf,IAAMO,UAA0C,GAAGL,IAAI,CAAC9H,GAAG,CAACkI,GAAG,IAAI;MAC/D,IAAME,GAAiC,GAAG;QAAEC,QAAQ,EAAEH;MAAI,CAAC;MAC3D,OAAOE,GAAG;IACd,CAAC,CAAC;IACF,IAAME,OAAO,GAAG,MAAM,IAAI,CAACtF,eAAe,CAACuF,SAAS,CAChDJ,UAAU,EACV,2BACJ,CAAC;;IAED;IACA,IAAMK,WAAW,GAAGtH,2BAA2B,CAA6B,IAAI,CAACuC,SAAS,EAAE6E,OAAO,CAACb,OAAO,CAAC;IAE5G,IAAI,IAAI,CAACM,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;MACjC,IAAMU,OAAoC,GAAG,IAAIpF,GAAG,CAAC,CAAC;MACtDyE,IAAI,CAACY,OAAO,CAACR,GAAG,IAAI;QAChBO,OAAO,CAACE,GAAG,CAAET,GAAG,CAAS5D,WAAW,CAAC,EAAS4D,GAAG,CAAC;MACtD,CAAC,CAAC;MACF,MAAMF,OAAO,CAACC,GAAG,CACbO,WAAW,CAACxI,GAAG,CAACkI,GAAG,IAAI;QACnB,OAAO,IAAI,CAACxD,SAAS,CACjB,MAAM,EAAE,QAAQ,EAChB+D,OAAO,CAACG,GAAG,CAACV,GAAG,CAACW,OAAO,CAAC,EACxBX,GACJ,CAAC;MACL,CAAC,CACL,CAAC;IACL;IAEA,OAAO;MACHT,OAAO,EAAEe,WAAW;MACpBjB,KAAK,EAAEe,OAAO,CAACf;IACnB,CAAC;EACL,CAAC;EAAArD,MAAA,CAEK4E,UAAU,GAAhB,eAAAA,WACIC,GAAa,EAId;IACC,IAAMzE,WAAW,GAAG,IAAI,CAAChC,MAAM,CAACgC,WAAW;IAC3C;AACR;AACA;AACA;IACQ,IAAIyE,GAAG,CAACpB,MAAM,KAAK,CAAC,EAAE;MAClB,OAAO;QACHF,OAAO,EAAE,EAAE;QACXF,KAAK,EAAE;MACX,CAAC;IACL;IAEA,IAAMyB,aAAa,GAAG,MAAM,IAAI,CAACC,SAAS,CAACF,GAAG,CAAC,CAACG,IAAI,CAAC,CAAC;IACtD,IAAMxB,QAA0C,GAAG,EAAE;IACrD,IAAMe,OAAoD,GAAG,IAAIpF,GAAG,CAAC,CAAC;IACtE8F,KAAK,CAACC,IAAI,CAACJ,aAAa,CAACK,MAAM,CAAC,CAAC,CAAC,CAACX,OAAO,CAACY,UAAU,IAAI;MACrD,IAAMC,IAAoC,GAAGD,UAAU,CAACE,aAAa,CAAC,IAAI,CAAQ;MAClF9B,QAAQ,CAACtB,IAAI,CAACmD,IAAI,CAAC;MACnBd,OAAO,CAACE,GAAG,CAACW,UAAU,CAACT,OAAO,EAAEU,IAAI,CAAC;IACzC,CAAC,CAAC;IAEF,MAAMvB,OAAO,CAACC,GAAG,CACbP,QAAQ,CAAC1H,GAAG,CAACkI,GAAG,IAAI;MAChB,IAAMW,OAAO,GAAIX,GAAG,CAAS,IAAI,CAAC5F,MAAM,CAACgC,WAAW,CAAC;MACrD,OAAO,IAAI,CAACI,SAAS,CAAC,KAAK,EAAE,QAAQ,EAAEwD,GAAG,EAAEc,aAAa,CAACJ,GAAG,CAACC,OAAO,CAAC,CAAC;IAC3E,CAAC,CACL,CAAC;IACD,IAAMY,UAA0C,GAAG/B,QAAQ,CAAC1H,GAAG,CAACkI,GAAG,IAAI;MACnE,IAAMwB,QAAQ,GAAGvJ,SAAS,CAAC+H,GAAG,CAAC;MAC/BwB,QAAQ,CAACC,QAAQ,GAAG,IAAI;MACxB,OAAO;QACHC,QAAQ,EAAE1B,GAAG;QACbG,QAAQ,EAAEqB;MACd,CAAC;IACL,CAAC,CAAC;IACF,IAAMpB,OAAO,GAAG,MAAM,IAAI,CAACtF,eAAe,CAACuF,SAAS,CAChDkB,UAAU,EACV,2BACJ,CAAC;IAED,IAAMI,UAAoB,GAAGvB,OAAO,CAACb,OAAO,CAACzH,GAAG,CAAC8J,CAAC,IAAIA,CAAC,CAACxF,WAAW,CAAW,CAAC;;IAE/E;IACA,MAAM0D,OAAO,CAACC,GAAG,CACb4B,UAAU,CAAC7J,GAAG,CAAC2F,EAAE,IAAI;MACjB,OAAO,IAAI,CAACjB,SAAS,CACjB,MAAM,EACN,QAAQ,EACR+D,OAAO,CAACG,GAAG,CAACjD,EAAE,CAAC,EACfqD,aAAa,CAACJ,GAAG,CAACjD,EAAE,CACxB,CAAC;IACL,CAAC,CACL,CAAC;IAED,IAAM6C,WAAW,GAAGqB,UAAU,CAAC7J,GAAG,CAAC2F,EAAE,IAAIpF,iBAAiB,CAACyI,aAAa,EAAErD,EAAE,CAAC,CAAC;IAE9E,OAAO;MACH8B,OAAO,EAAEe,WAAW;MACpBjB,KAAK,EAAEe,OAAO,CAACf;IACnB,CAAC;EACL;;EAEA;AACJ;AACA,KAFI;EAAArD,MAAA,CAGM6F,UAAU,GAAhB,eAAAA,WAAiBrC,QAAmC,EAGjD;IACC,IAAMsC,UAA4B,GAAG,EAAE;IACvC,IAAMC,cAA2C,GAAG,IAAI5G,GAAG,CAAC,CAAC;IAC7DqE,QAAQ,CAACgB,OAAO,CAACtD,OAAO,IAAI;MACxB,IAAM8E,OAAO,GAAGxJ,0BAA0B,CAAC,IAAI,CAAC4B,MAAM,EAAE8C,OAAO,CAAC;MAChE,IAAMyD,OAAe,GAAGqB,OAAO,CAAC,IAAI,CAAC5H,MAAM,CAACgC,WAAW,CAAQ;MAC/D,IAAI,CAACuE,OAAO,EAAE;QACV,MAAM9H,UAAU,CAAC,MAAM,EAAE;UACrBuD,WAAW,EAAE,IAAI,CAAChC,MAAM,CAACgC,WAAqB;UAC9CiF,IAAI,EAAEW,OAAO;UACb5H,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC+B;QACxB,CAAC,CAAC;MACN;MACA4F,cAAc,CAACtB,GAAG,CAACE,OAAO,EAAEqB,OAAO,CAAC;MACpCF,UAAU,CAAC5D,IAAI,CAAC8D,OAAO,CAAC;IAC5B,CAAC,CAAC;IAEF,IAAM1C,YAAY,GAAG,MAAM,IAAI,CAACH,UAAU,CAAC2C,UAAU,CAAC;IACtD,IAAMvC,OAAO,GAAGD,YAAY,CAACC,OAAO,CAAC0C,KAAK,CAAC,CAAC,CAAC;IAC7C,IAAM5C,KAA4C,GAAG,EAAE;;IAEvD;IACA,MAAMS,OAAO,CAACC,GAAG,CACbT,YAAY,CAACD,KAAK,CAACvH,GAAG,CAAC,MAAOoK,GAAG,IAAK;MAClC,IAAIA,GAAG,CAACC,MAAM,KAAK,GAAG,EAAE;QACpB9C,KAAK,CAACnB,IAAI,CAACgE,GAAG,CAAC;MACnB,CAAC,MAAM;QACH,IAAMzE,EAAE,GAAGyE,GAAG,CAACE,UAAU;QACzB,IAAMC,SAAS,GAAGhK,iBAAiB,CAAC0J,cAAc,EAAEtE,EAAE,CAAC;QACvD,IAAM6E,WAAW,GAAGlK,cAAc,CAAC8J,GAAG,CAACK,YAAY,CAAC;QACpD,IAAMvC,GAAG,GAAG,IAAI,CAACzE,SAAS,CAACiH,mBAAmB,CAACF,WAAW,CAAC;QAC3D,IAAMG,MAAM,GAAG,MAAMzC,GAAG,CAAC0C,iBAAiB,CAAC,MAAML,SAAS,CAAC;QAC3D9C,OAAO,CAACrB,IAAI,CAACuE,MAAM,CAAC;MACxB;IACJ,CAAC,CACL,CAAC;IACD,OAAO;MACHpD,KAAK;MACLE;IACJ,CAAC;EACL;;EAEA;AACJ;AACA,KAFI;EAAAvD,MAAA,CAGM2G,MAAM,GAAZ,eAAAA,OAAa1D,IAA6B,EAAmD;IACzF,IAAM2D,UAAU,GAAG,MAAM,IAAI,CAACf,UAAU,CAAC,CAAC5C,IAAI,CAAC,CAAC;IAChDxF,0BAA0B,CACtB,IAAI,CAACsC,cAAc,EAClBkD,IAAI,CAAS,IAAI,CAAC7E,MAAM,CAACgC,WAAW,CAAC,EACtC6C,IAAI,EACJ2D,UAAU,CAACvD,KAAK,CAAC,CAAC,CACtB,CAAC;IACD,OAAOuD,UAAU,CAACrD,OAAO,CAAC,CAAC,CAAC;EAChC;;EAEA;AACJ;AACA,KAFI;EAAAvD,MAAA,CAGA6G,iBAAiB,GAAjB,SAAAA,kBAAkB5D,IAA6B,EAAmD;IAC9F,IAAM+C,OAAO,GAAGxJ,0BAA0B,CAAC,IAAI,CAAC4B,MAAM,EAAE6E,IAAI,CAAC;IAC7D,IAAM0B,OAAe,GAAGqB,OAAO,CAAC,IAAI,CAAC5H,MAAM,CAACgC,WAAW,CAAQ;IAC/D,IAAI,CAACuE,OAAO,EAAE;MACV,MAAM9H,UAAU,CAAC,MAAM,EAAE;QACrBwI,IAAI,EAAEpC;MACV,CAAC,CAAC;IACN;;IAEA;IACA,IAAI6D,KAAK,GAAG,IAAI,CAAC5H,wBAAwB,CAACwF,GAAG,CAACC,OAAO,CAAC;IACtD,IAAI,CAACmC,KAAK,EAAE;MACRA,KAAK,GAAGvK,oBAAoB;IAChC;IACAuK,KAAK,GAAGA,KAAK,CACRxE,IAAI,CAAC,MAAMyE,wCAAwC,CAAC,IAAI,EAASpC,OAAO,EAASqB,OAAO,CAAC,CAAC,CAC1F1D,IAAI,CAAE0E,WAAW,IAAK;MACnB,IAAI,CAACA,WAAW,CAACC,QAAQ,EAAE;QACvB,OAAOC,wBAAwB,CAACF,WAAW,CAAChD,GAAG,EAAEgC,OAAO,CAAC;MAC7D,CAAC,MAAM;QACH,OAAOgB,WAAW,CAAChD,GAAG;MAC1B;IACJ,CAAC,CAAC;IACN,IAAI,CAAC9E,wBAAwB,CAACuF,GAAG,CAACE,OAAO,EAAEmC,KAAK,CAAC;IACjD,OAAOA,KAAK;EAChB,CAAC;EAAA9G,MAAA,CAEDmH,IAAI,GAAJ,SAAAA,KAAKC,QAAqC,EAKxC;IACE,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MAC9B,MAAMvK,UAAU,CAAC,MAAM,EAAE;QACrBuK;MACJ,CAAC,CAAC;IACN;IAEA,IAAI,CAACA,QAAQ,EAAE;MACXA,QAAQ,GAAGxK,gBAAgB,CAAC,CAAC;IACjC;IAEA,IAAMyK,KAAK,GAAG1K,aAAa,CAAC,MAAM,EAAEyK,QAAQ,EAAE,IAAW,CAAC;IAC1D,OAAOC,KAAK;EAChB,CAAC;EAAArH,MAAA,CAEDsH,OAAO,GAAP,SAAAA,QACIF,QAAqD,EAMvD;IAEE;IACA,IACI,OAAOA,QAAQ,KAAK,QAAQ,IAC5BnC,KAAK,CAACsC,OAAO,CAACH,QAAQ,CAAC,EACzB;MACE,MAAMtK,cAAc,CAAC,MAAM,EAAE;QACzBsK;MACJ,CAAC,CAAC;IACN;IAEA,IAAIC,KAAK;IAET,IAAI,OAAOD,QAAQ,KAAK,QAAQ,EAAE;MAC9BC,KAAK,GAAG1K,aAAa,CAAC,SAAS,EAAE;QAC7B6K,QAAQ,EAAE;UACN,CAAC,IAAI,CAACpJ,MAAM,CAACgC,WAAW,GAAGgH;QAC/B,CAAC;QACDK,KAAK,EAAE;MACX,CAAC,EAAE,IAAW,CAAC;IACnB,CAAC,MAAM;MACH,IAAI,CAACL,QAAQ,EAAE;QACXA,QAAQ,GAAGxK,gBAAgB,CAAC,CAAC;MACjC;;MAGA;MACA,IAAKwK,QAAQ,CAAgBK,KAAK,EAAE;QAChC,MAAM5K,UAAU,CAAC,KAAK,CAAC;MAC3B;MAEAuK,QAAQ,GAAGnL,SAAS,CAACmL,QAAQ,CAAC;MAC7BA,QAAQ,CAASK,KAAK,GAAG,CAAC;MAC3BJ,KAAK,GAAG1K,aAAa,CAAiB,SAAS,EAAEyK,QAAQ,EAAE,IAAW,CAAC;IAC3E;IAGA,OAAOC,KAAK;EAChB,CAAC;EAAArH,MAAA,CAED0H,KAAK,GAAL,SAAAA,MAAMN,QAAqD,EAKzD;IACE,IAAI,CAACA,QAAQ,EAAE;MACXA,QAAQ,GAAGxK,gBAAgB,CAAC,CAAC;IACjC;IACA,IAAMyK,KAAK,GAAG1K,aAAa,CAAC,OAAO,EAAEyK,QAAQ,EAAE,IAAW,CAAC;IAC3D,OAAOC,KAAK;EAChB;;EAEA;AACJ;AACA;AACA,KAHI;EAAArH,MAAA,CAIA+E,SAAS,GAAT,SAAAA,UACIF,GAAa,EAMf;IACE,IAAM8C,UAAsC,GAAG;MAC3CH,QAAQ,EAAE;QACN,CAAC,IAAI,CAACpJ,MAAM,CAACgC,WAAW,GAAG;UACvBwH,GAAG,EAAE/C,GAAG,CAACoB,KAAK,CAAC,CAAC;QACpB;MACJ;IACJ,CAAC;IACD,IAAMoB,KAAK,GAAG1K,aAAa,CAAC,WAAW,EAAEgL,UAAU,EAAE,IAAW,CAAC;IACjE,OAAON,KAAK;EAChB;;EAEA;AACJ;AACA,KAFI;EAAArH,MAAA,CAKA6H,UAAU,GAAV,SAAAA,WAAA,EAA2B;IACvB,MAAM1L,aAAa,CAAC,WAAW,CAAC;EACpC;;EAEA;AACJ;AACA;AACA,KAHI;EAAA6D,MAAA,CAIA8H,UAAU,GAAV,SAAAA,WAAWC,aAAkD,EAAiB;IAC1E,MAAM5L,aAAa,CAAC,WAAW,CAAC;EACpC,CAAC;EAAA6D,MAAA,CAEDgI,UAAU,GAAV,SAAAA,WAAWC,UAA6C,EAA0C;IAC9F,MAAM9L,aAAa,CAAC,MAAM,CAAC;EAC/B;;EAEA;AACJ;AACA,KAFI;EAAA6D,MAAA,CAGAkI,OAAO,GAAP,SAAAA,QAAQC,IAAkB,EAAEC,GAAgB,EAAEC,GAAQ,EAAEC,QAAQ,GAAG,KAAK,EAAE;IACtE,IAAI,OAAOD,GAAG,KAAK,UAAU,EAAE;MAC3B,MAAMvL,cAAc,CAAC,MAAM,EAAE;QACzBsL,GAAG;QACHD;MACJ,CAAC,CAAC;IACN;IAEA,IAAI,CAACrK,UAAU,CAACyK,QAAQ,CAACJ,IAAI,CAAC,EAAE;MAC5B,MAAMrL,cAAc,CAAC,MAAM,EAAE;QACzBsL,GAAG;QACHD;MACJ,CAAC,CAAC;IACN;IAEA,IAAI,CAACpK,UAAU,CAACwK,QAAQ,CAACH,GAAG,CAAC,EAAE;MAC3B,MAAMvL,UAAU,CAAC,MAAM,EAAE;QACrBuL;MACJ,CAAC,CAAC;IACN;IAEA,IAAID,IAAI,KAAK,MAAM,IAAIC,GAAG,KAAK,QAAQ,IAAIE,QAAQ,KAAK,IAAI,EAAE;MAC1D,MAAMzL,UAAU,CAAC,OAAO,EAAE;QACtBsL,IAAI;QACJC,GAAG;QACHE;MACJ,CAAC,CAAC;IACN;;IAEA;IACA,IAAME,QAAQ,GAAGH,GAAG,CAACI,IAAI,CAAC,IAAI,CAAC;IAE/B,IAAMC,OAAO,GAAGJ,QAAQ,GAAG,UAAU,GAAG,QAAQ;IAEhD,IAAI,CAACjJ,KAAK,CAAC+I,GAAG,CAAC,GAAG,IAAI,CAAC/I,KAAK,CAAC+I,GAAG,CAAC,IAAI,CAAC,CAAC;IACvC,IAAI,CAAC/I,KAAK,CAAC+I,GAAG,CAAC,CAACD,IAAI,CAAC,GAAG,IAAI,CAAC9I,KAAK,CAAC+I,GAAG,CAAC,CAACD,IAAI,CAAC,IAAI;MAC7CQ,MAAM,EAAE,EAAE;MACVL,QAAQ,EAAE;IACd,CAAC;IACD,IAAI,CAACjJ,KAAK,CAAC+I,GAAG,CAAC,CAACD,IAAI,CAAC,CAACO,OAAO,CAAC,CAACxG,IAAI,CAACsG,QAAQ,CAAC;EACjD,CAAC;EAAAxI,MAAA,CAED4I,QAAQ,GAAR,SAAAA,SAAST,IAAkB,EAAEC,GAAgB,EAAE;IAC3C,IACI,CAAC,IAAI,CAAC/I,KAAK,CAAC+I,GAAG,CAAC,IAChB,CAAC,IAAI,CAAC/I,KAAK,CAAC+I,GAAG,CAAC,CAACD,IAAI,CAAC,EACxB;MACE,OAAO;QACHQ,MAAM,EAAE,EAAE;QACVL,QAAQ,EAAE;MACd,CAAC;IACL;IACA,OAAO,IAAI,CAACjJ,KAAK,CAAC+I,GAAG,CAAC,CAACD,IAAI,CAAC;EAChC,CAAC;EAAAnI,MAAA,CAED6D,QAAQ,GAAR,SAAAA,SAASsE,IAAkB,EAAEC,GAAgB,EAAE;IAC3C,IAAM/I,KAAK,GAAG,IAAI,CAACuJ,QAAQ,CAACT,IAAI,EAAEC,GAAG,CAAC;IACtC,IAAI,CAAC/I,KAAK,EAAE;MACR,OAAO,KAAK;IAChB;IACA,OAAOA,KAAK,CAACsJ,MAAM,CAAClF,MAAM,GAAG,CAAC,IAAIpE,KAAK,CAACiJ,QAAQ,CAAC7E,MAAM,GAAG,CAAC;EAC/D,CAAC;EAAAzD,MAAA,CAEDQ,SAAS,GAAT,SAAAA,UAAU2H,IAAkB,EAAEC,GAAgB,EAAE/C,IAAS,EAAEwD,QAAc,EAAgB;IACrF,IAAMxJ,KAAK,GAAG,IAAI,CAACuJ,QAAQ,CAACT,IAAI,EAAEC,GAAG,CAAC;IAEtC,IAAI,CAAC/I,KAAK,EAAE;MACR,OAAO9C,oBAAoB;IAC/B;;IAEA;IACA,IAAMuM,KAAK,GAAGzJ,KAAK,CAACsJ,MAAM,CAAC7M,GAAG,CAAEiN,IAAS,IAAK,MAAMA,IAAI,CAAC1D,IAAI,EAAEwD,QAAQ,CAAC,CAAC;IACzE,OAAO3M,aAAa,CAAC4M,KAAK;IACtB;IAAA,CACCxG,IAAI,CAAC,MAAMwB,OAAO,CAACC,GAAG,CACnB1E,KAAK,CAACiJ,QAAQ,CACTxM,GAAG,CAAEiN,IAAS,IAAKA,IAAI,CAAC1D,IAAI,EAAEwD,QAAQ,CAAC,CAChD,CAAC,CAAC;EACV;;EAEA;AACJ;AACA,KAFI;EAAA7I,MAAA,CAGAgJ,aAAa,GAAb,SAAAA,cAAcb,IAAkB,EAAEC,GAAgB,EAAE/C,IAAS,EAAEwD,QAAa,EAAE;IAC1E,IAAMxJ,KAAK,GAAG,IAAI,CAACuJ,QAAQ,CAACT,IAAI,EAAEC,GAAG,CAAC;IACtC,IAAI,CAAC/I,KAAK,EAAE;IACZA,KAAK,CAACsJ,MAAM,CAACnE,OAAO,CAAEuE,IAAS,IAAKA,IAAI,CAAC1D,IAAI,EAAEwD,QAAQ,CAAC,CAAC;EAC7D;;EAEA;AACJ;AACA;AACA;AACA,KAJI;EAAA7I,MAAA,CAKAiJ,WAAW,GAAX,SAAAA,YAAYC,IAAY,EAAiB;IACrC,IAAMC,GAAG,GAAG,IAAIrF,OAAO,CAAOsF,GAAG,IAAI;MACjC,IAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;QAC7B,IAAI,CAACvK,QAAQ,CAACwK,MAAM,CAACF,OAAO,CAAC;QAC7BD,GAAG,CAAC,CAAC;MACT,CAAC,EAAEF,IAAI,CAAC;MACR,IAAI,CAACnK,QAAQ,CAACyK,GAAG,CAACH,OAAO,CAAC;IAC9B,CAAC,CAAC;IACF,OAAOF,GAAG;EACd,CAAC;EAAAnJ,MAAA,CAEDyJ,OAAO,GAAP,SAAAA,QAAA,EAA4B;IACxB,IAAI,IAAI,CAAC5J,SAAS,EAAE;MAChB,OAAOvD,qBAAqB;IAChC;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACuD,SAAS,GAAG,IAAI;IAGrBoF,KAAK,CAACC,IAAI,CAAC,IAAI,CAACnG,QAAQ,CAAC,CAACyF,OAAO,CAAC6E,OAAO,IAAIK,YAAY,CAACL,OAAO,CAAC,CAAC;IACnE,IAAI,IAAI,CAAC1J,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAAC8J,OAAO,CAAC,CAAC;IACrC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,OAAO,IAAI,CAACvL,QAAQ,CAACyL,kBAAkB,CAAC,CAAC,CACpCrH,IAAI,CAAC,MAAMwB,OAAO,CAACC,GAAG,CAAC,IAAI,CAACnE,SAAS,CAAC9D,GAAG,CAAC8N,EAAE,IAAIA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CACvDtH,IAAI,CAAC,MAAM,IAAI,CAACxD,eAAe,CAAC+K,KAAK,CAAC,CAAC,CAAC,CACxCvH,IAAI,CAAC,MAAM;MACR;AAChB;AACA;AACA;AACA;AACA;MACgB,IAAI,CAAChD,KAAK,CAACkF,OAAO,CAACsF,GAAG,IAAIA,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC;MAE5C,OAAO,IAAI,CAAC7L,QAAQ,CAAC8L,WAAW,CAAC,IAAI,CAAC7L,IAAI,CAAC;MAC3C,OAAOf,mBAAmB,CAAC,yBAAyB,EAAE,IAAI,CAAC,CAACkF,IAAI,CAAC,MAAM,IAAI,CAAC;IAChF,CAAC,CAAC;EACV;;EAEA;AACJ;AACA,KAFI;EAAAtC,MAAA,CAGMiK,MAAM,GAAZ,eAAAA,OAAA,EAA6B;IACzB,MAAM,IAAI,CAACR,OAAO,CAAC,CAAC;IACpB,MAAM/M,wBAAwB,CAC1B,IAAI,CAACwB,QAAQ,CAACgM,OAAO,EACrB,IAAI,CAAChM,QAAQ,CAACiM,aAAa,EAC3B,IAAI,CAACjM,QAAQ,CAAC2D,KAAK,EACnB,IAAI,CAAC3D,QAAQ,CAACC,IAAI,EAClB,IAAI,CAACA,IAAI,EACT,IAAI,CAACD,QAAQ,CAACkM,QAAQ,EACtB,IAAI,CAAClM,QAAQ,CAACmM,YAClB,CAAC;EACL,CAAC;EAAAC,YAAA,CAAArM,gBAAA;IAAAmK,GAAA;IAAA1D,GAAA,EAnqBD,SAAAA,CAAA,EAA+D;MAC3D,OAAO,IAAI,CAACjF,CAAC,CAACkB,IAAI,CACd9E,MAAM,CAACmF,EAAE,IAAIA,EAAE,CAACuJ,SAAS,KAAK,QAAQ,CAC1C,CAAC;IACL;EAAC;IAAAnC,GAAA;IAAA1D,GAAA,EACD,SAAAA,CAAA,EAA+D;MAC3D,OAAO,IAAI,CAACjF,CAAC,CAACkB,IAAI,CACd9E,MAAM,CAACmF,EAAE,IAAIA,EAAE,CAACuJ,SAAS,KAAK,QAAQ,CAC1C,CAAC;IACL;EAAC;IAAAnC,GAAA;IAAA1D,GAAA,EACD,SAAAA,CAAA,EAA+D;MAC3D,OAAO,IAAI,CAACjF,CAAC,CAACkB,IAAI,CACd9E,MAAM,CAACmF,EAAE,IAAIA,EAAE,CAACuJ,SAAS,KAAK,QAAQ,CAC1C,CAAC;IACL;;IAGA;;IAqBA;AACJ;AACA;AACA;AACA;AACA;EALI;IAAAnC,GAAA;IAAA1D,GAAA,EA+nBA,SAAAA,CAAA,EAA+F;MAC3F,OAAO,IAAI;IACf;EAAC;EAAA,OAAAzG,gBAAA;AAAA;;AAGL;AACA;AACA;AACA;AACA,SAAS6B,mBAAmBA,CACxB0K,UAAkC,EACpC;EACE,IAAIxM,YAAY,EAAE,OAAO,CAAC;EAC1BA,YAAY,GAAG,IAAI;EACnB,IAAMyM,QAAQ,GAAGC,MAAM,CAACC,cAAc,CAACH,UAAU,CAAC;EAClDzM,UAAU,CAACyG,OAAO,CAAC4D,GAAG,IAAI;IACtBtK,UAAU,CAAChC,GAAG,CAACqM,IAAI,IAAI;MACnB,IAAMyC,MAAM,GAAGzC,IAAI,GAAGnM,OAAO,CAACoM,GAAG,CAAC;MAClCqC,QAAQ,CAACG,MAAM,CAAC,GAAG,UAAUvC,GAAW,EAAEC,QAAiB,EAAE;QACzD,OAAO,IAAI,CAACJ,OAAO,CAACC,IAAI,EAAEC,GAAG,EAAEC,GAAG,EAAEC,QAAQ,CAAC;MACjD,CAAC;IACL,CAAC,CAAC;EACN,CAAC,CAAC;AACN;AAEA,SAASpB,wBAAwBA,CAC7BlD,GAA8B,EAC9Bf,IAA+B,EACG;EAClC,OAAOe,GAAG,CAAC0C,iBAAiB,CAAEmE,SAAS,IAAK;IACxC,OAAO5H,IAAI;EACf,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA,SAAS8D,wCAAwCA,CAC7C+D,YAAqC,EACrCnG,OAAe,EACf1B,IAAS,EAMX;EACE;AACJ;AACA;AACA;EACI,IAAM8H,gBAAgB,GAAGD,YAAY,CAACvL,SAAS,CAACyL,6BAA6B,CAACrG,OAAO,CAAC;EACtF,IAAIoG,gBAAgB,EAAE;IAClB,OAAOjH,OAAO,CAACmH,OAAO,CAAC;MACnBjH,GAAG,EAAE8G,YAAY,CAACvL,SAAS,CAACiH,mBAAmB,CAACuE,gBAAgB,CAAC;MACjE9D,QAAQ,EAAE;IACd,CAAC,CAAC;EACN;EACA,OAAO6D,YAAY,CAACxD,OAAO,CAAC3C,OAAO,CAAC,CAACK,IAAI,CAAC,CAAC,CACtC1C,IAAI,CAAC0B,GAAG,IAAI;IACT,IAAI,CAACA,GAAG,EAAE;MACN,OAAO8G,YAAY,CAAC9H,MAAM,CAACC,IAAI,CAAC,CAACX,IAAI,CAACmE,MAAM,KAAK;QAC7CzC,GAAG,EAAEyC,MAAM;QACXQ,QAAQ,EAAE;MACd,CAAC,CAAC,CAAC;IACP,CAAC,MAAM;MACH,OAAO;QACHjD,GAAG;QACHiD,QAAQ,EAAE;MACd,CAAC;IACL;EACJ,CAAC,CAAC;AACV;;AAEA;AACA;AACA;AACA,OAAO,SAASiE,kBAAkBA,CAC9B;EACIhN,QAAQ;EACRC,IAAI;EACJC,MAAM;EACNE,uBAAuB,GAAG,CAAC,CAAC;EAC5BC,mBAAmB,GAAG,CAAC,CAAC;EACxB4M,WAAW,GAAG,IAAI;EAClBvM,OAAO,GAAG,CAAC,CAAC;EACZJ,OAAO,GAAG,CAAC,CAAC;EACZC,WAAW,GAAG,CAAC,CAAC;EAChBC,OAAO,GAAG,CAAC,CAAC;EACZ0M,cAAc,GAAG,KAAK;EACtBzM,sBAAsB,GAAGzB,6BAA6B;EACtD2B,eAAe,GAAGnB;AACjB,CAAC,EACe;EACrB,IAAM2N,6BAAwE,GAAG;IAC7EC,qBAAqB,EAAEpN,QAAQ,CAAC2D,KAAK;IACrC0J,YAAY,EAAErN,QAAQ,CAACC,IAAI;IAC3B0C,cAAc,EAAE1C,IAAI;IACpBC,MAAM,EAAEA,MAAM,CAAC+B,UAAU;IACzBzB,OAAO,EAAEJ,uBAAuB;IAChCkN,aAAa,EAAEtN,QAAQ,CAACsN,aAAa;IACrCpB,QAAQ,EAAElM,QAAQ,CAACkM,QAAQ;IAC3BqB,OAAO,EAAE5N,YAAY,CAAC6N,SAAS,CAAC;EACpC,CAAC;EAEDrO,cAAc,CACV,4BAA4B,EAC5BgO,6BACJ,CAAC;EAED,OAAO5O,iCAAiC,CACpCyB,QAAQ,EACRmN,6BACJ,CAAC,CAAC/I,IAAI,CAACxD,eAAe,IAAI;IACtB,IAAM0L,UAAU,GAAG,IAAIvM,gBAAgB,CACnCC,QAAQ,EACRC,IAAI,EACJC,MAAM,EACNU,eAAe,EACfR,uBAAuB,EACvBC,mBAAmB,EACnBC,OAAO,EACPC,WAAW,EACXC,OAAO,EACPC,sBAAsB,EACtBC,OAAO,EACPC,eACJ,CAAC;IAED,OAAO2L,UAAU,CACZtK,OAAO,CAAC,CAAC,CACToC,IAAI,CAAC,MAAM;MACR;MACAoI,MAAM,CACDiB,OAAO,CAAC/M,OAAO,CAAC,CAChB4F,OAAO,CAAC,CAAC,CAACoH,OAAO,EAAEvD,GAAG,CAAC,KAAK;QACzBqC,MAAM,CAACmB,cAAc,CAACrB,UAAU,EAAEoB,OAAO,EAAE;UACvClH,GAAG,EAAEA,CAAA,KAAO2D,GAAG,CAASI,IAAI,CAAC+B,UAAU;QAC3C,CAAC,CAAC;MACN,CAAC,CAAC;MAEN,IAAIrB,GAAG,GAAG5M,oBAAoB;MAC9B,IAAI4O,WAAW,IAAIX,UAAU,CAACpM,MAAM,CAAC0N,OAAO,KAAK,CAAC,EAAE;QAChD3C,GAAG,GAAGqB,UAAU,CAACzH,cAAc,CAAC,CAAC;MACrC;MACA,OAAOoG,GAAG;IACd,CAAC,CAAC,CACD7G,IAAI,CAAC,MAAM;MACRjF,cAAc,CAAC,oBAAoB,EAAE;QACjCmN,UAAU;QACVuB,OAAO,EAAE;UACL5N,IAAI;UACJC,MAAM;UACNU,eAAe;UACfR,uBAAuB;UACvBC,mBAAmB;UACnBC,OAAO;UACPC,WAAW;UACXC,OAAO;UACPC,sBAAsB;UACtByM,cAAc;UACdxM;QACJ;MACJ,CAAC,CAAC;MACF,OAAO4L,UAAU;IACrB,CAAC;IACD;AACZ;AACA;AACA,OAHY,CAICwB,KAAK,CAAC9F,GAAG,IAAI;MACV,OAAOpH,eAAe,CAAC+K,KAAK,CAAC,CAAC,CACzBvH,IAAI,CAAC,MAAMwB,OAAO,CAACmI,MAAM,CAAC/F,GAAG,CAAC,CAAC;IACxC,CAAC,CAAC;EACV,CAAC,CAAC;AACN;AAEA,OAAO,SAASgG,cAAcA,CAACC,GAAQ,EAAW;EAC9C,OAAOA,GAAG,YAAYlO,gBAAgB;AAC1C","ignoreList":[]}