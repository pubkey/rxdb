{"version":3,"file":"memory.worker.js","mappings":"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","sources":["webpack://rxdb/./node_modules/is-observable/index.js","webpack://rxdb/./node_modules/threads/dist/common.js","webpack://rxdb/./node_modules/threads/dist/serializers.js","webpack://rxdb/./node_modules/threads/dist/symbols.js","webpack://rxdb/./node_modules/threads/dist/transferable.js","webpack://rxdb/./node_modules/threads/dist/types/messages.js","webpack://rxdb/./node_modules/threads/dist/worker/implementation.browser.js","webpack://rxdb/./node_modules/threads/dist/worker/index.js","webpack://rxdb/webpack/bootstrap","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/construct.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","webpack://rxdb/./src/overwritable.ts","webpack://rxdb/./src/rx-error.ts","webpack://rxdb/./src/plugins/utils/utils-other.ts","webpack://rxdb/./src/plugins/utils/utils-string.ts","webpack://rxdb/./src/plugins/utils/utils-time.ts","webpack://rxdb/./src/plugins/utils/utils-hash.ts","webpack://rxdb/./src/plugins/utils/utils-object.ts","webpack://rxdb/./src/rx-storage-helper.ts","webpack://rxdb/./node_modules/tslib/tslib.es6.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subscription.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/config.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/noop.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/errorContext.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subscriber.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/symbol/observable.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/identity.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/pipe.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Observable.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js","webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subject.js","webpack://rxdb/./src/plugins/utils/utils-object-dot-prop.ts","webpack://rxdb/./src/rx-schema-helper.ts","webpack://rxdb/./src/query-planner.ts","webpack://rxdb/./src/custom-index.ts","webpack://rxdb/./src/plugins/utils/utils-promise.ts","webpack://rxdb/./src/plugins/storage-memory/binary-search-bounds.ts","webpack://rxdb/./src/plugins/storage-memory/memory-helper.ts","webpack://rxdb/./node_modules/array-push-at-sort-position/dist/es/index.js","webpack://rxdb/./src/plugins/storage-memory/memory-indexes.ts","webpack://rxdb/./src/plugins/utils/utils-array.ts","webpack://rxdb/./node_modules/mingo/es/util.js","webpack://rxdb/./node_modules/mingo/es/core.js","webpack://rxdb/./node_modules/mingo/es/lazy.js","webpack://rxdb/./node_modules/mingo/es/aggregator.js","webpack://rxdb/./node_modules/mingo/es/cursor.js","webpack://rxdb/./node_modules/mingo/es/query.js","webpack://rxdb/./node_modules/mingo/es/operators/pipeline/project.js","webpack://rxdb/./node_modules/mingo/es/operators/pipeline/sort.js","webpack://rxdb/./node_modules/mingo/es/operators/_predicates.js","webpack://rxdb/./node_modules/mingo/es/operators/query/array/all.js","webpack://rxdb/./node_modules/mingo/es/operators/query/array/elemMatch.js","webpack://rxdb/./node_modules/mingo/es/operators/query/array/size.js","webpack://rxdb/./node_modules/mingo/es/operators/query/bitwise/_internal.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/eq.js","webpack://rxdb/./node_modules/mingo/es/operators/query/bitwise/bitsAllClear.js","webpack://rxdb/./node_modules/mingo/es/operators/query/bitwise/bitsAllSet.js","webpack://rxdb/./node_modules/mingo/es/operators/query/bitwise/bitsAnyClear.js","webpack://rxdb/./node_modules/mingo/es/operators/query/bitwise/bitsAnySet.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/gt.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/gte.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/in.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/lt.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/lte.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/ne.js","webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/nin.js","webpack://rxdb/./node_modules/mingo/es/operators/query/element/exists.js","webpack://rxdb/./node_modules/mingo/es/operators/query/element/type.js","webpack://rxdb/./node_modules/mingo/es/operators/query/evaluation/mod.js","webpack://rxdb/./node_modules/mingo/es/operators/query/evaluation/regex.js","webpack://rxdb/./node_modules/mingo/es/operators/query/logical/and.js","webpack://rxdb/./node_modules/mingo/es/operators/query/logical/or.js","webpack://rxdb/./node_modules/mingo/es/operators/query/logical/nor.js","webpack://rxdb/./node_modules/mingo/es/operators/query/logical/not.js","webpack://rxdb/./src/rx-query-mingo.ts","webpack://rxdb/./src/rx-storage-statics.ts","webpack://rxdb/./src/plugins/storage-memory/rx-storage-instance-memory.ts","webpack://rxdb/./src/plugins/utils/utils-document.ts","webpack://rxdb/./src/plugins/storage-memory/index.ts","webpack://rxdb/./node_modules/threads/worker.mjs","webpack://rxdb/./src/plugins/storage-worker/workers/memory.worker.ts","webpack://rxdb/./src/plugins/storage-worker/in-worker.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = value => {\n\tif (!value) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\tif (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') {\n\t\t// eslint-disable-next-line no-use-extend-native/no-use-extend-native\n\t\treturn value === value[Symbol.observable]();\n\t}\n\n\tif (typeof value['@@observable'] === 'function') {\n\t\treturn value === value['@@observable']();\n\t}\n\n\treturn false;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serialize = exports.deserialize = exports.registerSerializer = void 0;\nconst serializers_1 = require(\"./serializers\");\nlet registeredSerializer = serializers_1.DefaultSerializer;\nfunction registerSerializer(serializer) {\n    registeredSerializer = serializers_1.extendSerializer(registeredSerializer, serializer);\n}\nexports.registerSerializer = registerSerializer;\nfunction deserialize(message) {\n    return registeredSerializer.deserialize(message);\n}\nexports.deserialize = deserialize;\nfunction serialize(input) {\n    return registeredSerializer.serialize(input);\n}\nexports.serialize = serialize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultSerializer = exports.extendSerializer = void 0;\nfunction extendSerializer(extend, implementation) {\n    const fallbackDeserializer = extend.deserialize.bind(extend);\n    const fallbackSerializer = extend.serialize.bind(extend);\n    return {\n        deserialize(message) {\n            return implementation.deserialize(message, fallbackDeserializer);\n        },\n        serialize(input) {\n            return implementation.serialize(input, fallbackSerializer);\n        }\n    };\n}\nexports.extendSerializer = extendSerializer;\nconst DefaultErrorSerializer = {\n    deserialize(message) {\n        return Object.assign(Error(message.message), {\n            name: message.name,\n            stack: message.stack\n        });\n    },\n    serialize(error) {\n        return {\n            __error_marker: \"$$error\",\n            message: error.message,\n            name: error.name,\n            stack: error.stack\n        };\n    }\n};\nconst isSerializedError = (thing) => thing && typeof thing === \"object\" && \"__error_marker\" in thing && thing.__error_marker === \"$$error\";\nexports.DefaultSerializer = {\n    deserialize(message) {\n        if (isSerializedError(message)) {\n            return DefaultErrorSerializer.deserialize(message);\n        }\n        else {\n            return message;\n        }\n    },\n    serialize(input) {\n        if (input instanceof Error) {\n            return DefaultErrorSerializer.serialize(input);\n        }\n        else {\n            return input;\n        }\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$worker = exports.$transferable = exports.$terminate = exports.$events = exports.$errors = void 0;\nexports.$errors = Symbol(\"thread.errors\");\nexports.$events = Symbol(\"thread.events\");\nexports.$terminate = Symbol(\"thread.terminate\");\nexports.$transferable = Symbol(\"thread.transferable\");\nexports.$worker = Symbol(\"thread.worker\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transfer = exports.isTransferDescriptor = void 0;\nconst symbols_1 = require(\"./symbols\");\nfunction isTransferable(thing) {\n    if (!thing || typeof thing !== \"object\")\n        return false;\n    // Don't check too thoroughly, since the list of transferable things in JS might grow over time\n    return true;\n}\nfunction isTransferDescriptor(thing) {\n    return thing && typeof thing === \"object\" && thing[symbols_1.$transferable];\n}\nexports.isTransferDescriptor = isTransferDescriptor;\nfunction Transfer(payload, transferables) {\n    if (!transferables) {\n        if (!isTransferable(payload))\n            throw Error();\n        transferables = [payload];\n    }\n    return {\n        [symbols_1.$transferable]: true,\n        send: payload,\n        transferables\n    };\n}\nexports.Transfer = Transfer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkerMessageType = exports.MasterMessageType = void 0;\n/////////////////////////////\n// Messages sent by master:\nvar MasterMessageType;\n(function (MasterMessageType) {\n    MasterMessageType[\"cancel\"] = \"cancel\";\n    MasterMessageType[\"run\"] = \"run\";\n})(MasterMessageType = exports.MasterMessageType || (exports.MasterMessageType = {}));\n////////////////////////////\n// Messages sent by worker:\nvar WorkerMessageType;\n(function (WorkerMessageType) {\n    WorkerMessageType[\"error\"] = \"error\";\n    WorkerMessageType[\"init\"] = \"init\";\n    WorkerMessageType[\"result\"] = \"result\";\n    WorkerMessageType[\"running\"] = \"running\";\n    WorkerMessageType[\"uncaughtError\"] = \"uncaughtError\";\n})(WorkerMessageType = exports.WorkerMessageType || (exports.WorkerMessageType = {}));\n","\"use strict\";\n/// <reference lib=\"dom\" />\n// tslint:disable no-shadowed-variable\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isWorkerRuntime = function isWorkerRuntime() {\n    const isWindowContext = typeof self !== \"undefined\" && typeof Window !== \"undefined\" && self instanceof Window;\n    return typeof self !== \"undefined\" && self.postMessage && !isWindowContext ? true : false;\n};\nconst postMessageToMaster = function postMessageToMaster(data, transferList) {\n    self.postMessage(data, transferList);\n};\nconst subscribeToMasterMessages = function subscribeToMasterMessages(onMessage) {\n    const messageHandler = (messageEvent) => {\n        onMessage(messageEvent.data);\n    };\n    const unsubscribe = () => {\n        self.removeEventListener(\"message\", messageHandler);\n    };\n    self.addEventListener(\"message\", messageHandler);\n    return unsubscribe;\n};\nexports.default = {\n    isWorkerRuntime,\n    postMessageToMaster,\n    subscribeToMasterMessages\n};\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\nconst is_observable_1 = __importDefault(require(\"is-observable\"));\nconst common_1 = require(\"../common\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst implementation_1 = __importDefault(require(\"./implementation\"));\nvar common_2 = require(\"../common\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_2.registerSerializer; } });\nvar transferable_2 = require(\"../transferable\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_2.Transfer; } });\n/** Returns `true` if this code is currently running in a worker. */\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.cancel;\nconst isMasterJobRunMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = (thing) => is_observable_1.default(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return transferable_1.isTransferDescriptor(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    const { payload: error, transferables } = deconstructTransfer(rawError);\n    const errorMessage = {\n        type: messages_1.WorkerMessageType.error,\n        uid,\n        error: common_1.serialize(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    const { payload, transferables } = deconstructTransfer(resultValue);\n    const resultMessage = {\n        type: messages_1.WorkerMessageType.result,\n        uid,\n        complete: completed ? true : undefined,\n        payload\n    };\n    implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    const startMessage = {\n        type: messages_1.WorkerMessageType.running,\n        uid,\n        resultType\n    };\n    implementation_1.default.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        const errorMessage = {\n            type: messages_1.WorkerMessageType.uncaughtError,\n            error: common_1.serialize(error)\n        };\n        implementation_1.default.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let syncResult;\n        try {\n            syncResult = fn(...args);\n        }\n        catch (error) {\n            return postJobErrorMessage(jobUID, error);\n        }\n        const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n        postJobStartMessage(jobUID, resultType);\n        if (isObservable(syncResult)) {\n            const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, common_1.serialize(value)), error => {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n                activeSubscriptions.delete(jobUID);\n            }, () => {\n                postJobResultMessage(jobUID, true);\n                activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n        }\n        else {\n            try {\n                const result = yield syncResult;\n                postJobResultMessage(jobUID, true, common_1.serialize(result));\n            }\n            catch (error) {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n            }\n        }\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nfunction expose(exposed) {\n    if (!implementation_1.default.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n            }\n        });\n        const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n    }\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n        if (isMasterJobCancelMessage(messageData)) {\n            const jobUID = messageData.uid;\n            const subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nexports.expose = expose;\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    self.addEventListener(\"error\", event => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n    });\n    self.addEventListener(\"unhandledrejection\", event => {\n        const error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", (error) => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(error), 250);\n    });\n    process.on(\"unhandledRejection\", (error) => {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/**\n * functions that can or should be overwritten by plugins\n * IMPORTANT: Do not import any big stuff from RxDB here!\n * An 'overwritable' can be used inside WebWorkers for RxStorage only,\n * and we do not want to have the full RxDB lib bundled in them.\n */\n\nimport type { DeepReadonly } from './types/util';\n\nexport const overwritable = {\n    /**\n     * if this method is overwritten with one\n     * that returns true, we do additional checks\n     * which help the developer but have bad performance\n     */\n    isDevMode(): boolean {\n        return false;\n    },\n\n    /**\n     * Deep freezes and object when in dev-mode.\n     * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.\n     * Also, we can ensure the readonly state via typescript\n     * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n     */\n    deepFreezeWhenDevMode<T>(obj: T): DeepReadonly<T> {\n        return obj as any;\n    },\n\n    /**\n     * overwritten to map error-codes to text-messages\n     */\n    tunnelErrorMessage(message: string): string {\n        return `RxDB Error-Code ${message}.\n        Error messages are not included in RxDB core to reduce build size.\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=${message}\n        `;\n    }\n};\n","/**\n * here we use custom errors with the additional field 'parameters'\n */\n\nimport { overwritable } from './overwritable';\nimport type {\n    RxErrorParameters,\n    RxErrorKey,\n    RxStorageWriteError,\n    RxStorageWriteErrorConflict\n} from './types';\n\n/**\n * transform an object of parameters to a presentable string\n */\nfunction parametersToString(parameters: any): string {\n    let ret = '';\n    if (Object.keys(parameters).length === 0)\n        return ret;\n    ret += 'Given parameters: {\\n';\n    ret += Object.keys(parameters)\n        .map(k => {\n            let paramStr = '[object Object]';\n            try {\n                paramStr = JSON.stringify(\n                    parameters[k],\n                    (_k, v) => v === undefined ? null : v,\n                    2\n                );\n            } catch (e) { }\n            return k + ':' + paramStr;\n        })\n        .join('\\n');\n    ret += '}';\n    return ret;\n}\n\nfunction messageForError(\n    message: string,\n    code: string,\n    parameters: any\n): string {\n    return 'RxError (' + code + '):' + '\\n' +\n        message + '\\n' +\n        parametersToString(parameters);\n}\n\nexport class RxError extends Error {\n    public code: RxErrorKey;\n    public message: string;\n    public parameters: RxErrorParameters;\n    // always true, use this to detect if its an rxdb-error\n    public rxdb: true;\n    constructor(\n        code: RxErrorKey,\n        message: string,\n        parameters: RxErrorParameters = {}\n    ) {\n        const mes = messageForError(message, code, parameters);\n        super(mes);\n        this.code = code;\n        this.message = mes;\n        this.parameters = parameters;\n        this.rxdb = true; // tag them as internal\n    }\n    get name(): string {\n        return 'RxError (' + this.code + ')';\n    }\n    toString(): string {\n        return this.message;\n    }\n    get typeError(): boolean {\n        return false;\n    }\n}\n\nexport class RxTypeError extends TypeError {\n    public code: RxErrorKey;\n    public message: string;\n    public parameters: RxErrorParameters;\n    // always true, use this to detect if its an rxdb-error\n    public rxdb: true;\n    constructor(\n        code: RxErrorKey,\n        message: string,\n        parameters: RxErrorParameters = {}\n    ) {\n        const mes = messageForError(message, code, parameters);\n        super(mes);\n        this.code = code;\n        this.message = mes;\n        this.parameters = parameters;\n        this.rxdb = true; // tag them as internal\n    }\n    get name(): string {\n        return 'RxTypeError (' + this.code + ')';\n    }\n    toString(): string {\n        return this.message;\n    }\n    get typeError(): boolean {\n        return true;\n    }\n}\n\nexport function newRxError(\n    code: RxErrorKey,\n    parameters?: RxErrorParameters\n): RxError {\n    return new RxError(\n        code,\n        overwritable.tunnelErrorMessage(code),\n        parameters\n    );\n}\n\nexport function newRxTypeError(\n    code: RxErrorKey,\n    parameters?: RxErrorParameters\n): RxTypeError {\n    return new RxTypeError(\n        code,\n        overwritable.tunnelErrorMessage(code),\n        parameters\n    );\n}\n\n\n/**\n * Returns the error if it is a 409 conflict,\n * return false if it is another error.\n */\nexport function isBulkWriteConflictError<RxDocType>(\n    err?: RxStorageWriteError<RxDocType> | any\n): RxStorageWriteErrorConflict<RxDocType> | false {\n    if (\n        err &&\n        err.status === 409\n    ) {\n        return err;\n    } else {\n        return false;\n    }\n}\n\n\nconst STORAGE_WRITE_ERROR_CODE_TO_MESSAGE: { [k: number]: string; } = {\n    409: 'document write conflict',\n    422: 'schema validation error',\n    510: 'attachment data missing'\n};\n\nexport function rxStorageWriteErrorToRxError(err: RxStorageWriteError<any>): RxError {\n    return newRxError('COL20', {\n        name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],\n        document: err.documentId,\n        writeError: err\n    });\n}\n","export function runXTimes(xTimes: number, fn: (idx: number) => void) {\n    new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));\n}\n\nexport function ensureNotFalsy<T>(obj: T | false | undefined | null): T {\n    if (!obj) {\n        throw new Error('ensureNotFalsy() is falsy');\n    }\n    return obj;\n}\n\nexport function ensureInteger(obj: unknown): number {\n    if (!Number.isInteger(obj)) {\n        throw new Error('ensureInteger() is falsy');\n    }\n    return obj as number;\n}\n\n\nexport function getFromMapOrThrow<K, V>(map: Map<K, V> | WeakMap<any, V>, key: K): V {\n    const val = map.get(key);\n    if (typeof val === 'undefined') {\n        throw new Error('missing value from map ' + key);\n    }\n    return val;\n}\n\nexport function getFromMapOrFill<K, V>(\n    map: Map<K, V> | WeakMap<any, V>,\n    key: K,\n    fillerFunction: () => V\n): V {\n    let value = map.get(key);\n    if (!value) {\n        value = fillerFunction();\n        map.set(key, value);\n    }\n    return value;\n}\n\n\n\n\n/**\n * Using shareReplay() without settings will not unsubscribe\n * if there are no more subscribers.\n * So we use these defaults.\n * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n */\nexport const RXJS_SHARE_REPLAY_DEFAULTS = {\n    bufferSize: 1,\n    refCount: true\n};\n","/**\n * get a random string which can be used with couchdb\n * @link http://stackoverflow.com/a/1349426/3443137\n */\nexport function randomCouchString(length: number = 10): string {\n    let text = '';\n    const possible = 'abcdefghijklmnopqrstuvwxyz';\n\n    for (let i = 0; i < length; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n\n    return text;\n}\n\n\n/**\n * A random string that is never inside of any storage\n */\nexport const RANDOM_STRING = 'Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX';\n\n/**\n * uppercase first char\n */\nexport function ucfirst(str: string): string {\n    str += '';\n    const f = str.charAt(0)\n        .toUpperCase();\n    return f + str.substr(1);\n}\n\n/**\n * removes trailing and ending dots from the string\n */\nexport function trimDots(str: string): string {\n    // start\n    while (str.charAt(0) === '.')\n        str = str.substr(1);\n\n    // end\n    while (str.slice(-1) === '.')\n        str = str.slice(0, -1);\n\n    return str;\n}\n\n/**\n * returns true if the given name is likely a folder path\n */\nexport function isFolderPath(name: string) {\n    // do not check, if foldername is given\n    if (\n        name.includes('/') || // unix\n        name.includes('\\\\') // windows\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n","\n/**\n * Returns the current unix time in milliseconds (with two decmials!)\n * Because the accuracy of getTime() in javascript is bad,\n * and we cannot rely on performance.now() on all platforms,\n * this method implements a way to never return the same value twice.\n * This ensures that when now() is called often, we do not loose the information\n * about which call came first and which came after.\n *\n * We had to move from having no decimals, to having two decimal\n * because it turned out that some storages are such fast that\n * calling this method too often would return 'the future'.\n */\nlet _lastNow: number = 0;\n/**\n * Returns the current time in milliseconds,\n * also ensures to not return the same value twice.\n */\nexport function now(): number {\n    let ret = new Date().getTime();\n    ret = ret + 0.01;\n    if (ret <= _lastNow) {\n        ret = _lastNow + 0.01;\n    }\n\n    /**\n     * Strip the returned number to max two decimals.\n     * In theory we would not need this but\n     * in practice JavaScript has no such good number precision\n     * so rounding errors could add another decimal place.\n     */\n    const twoDecimals = parseFloat(ret.toFixed(2));\n\n    _lastNow = twoDecimals;\n    return twoDecimals;\n}\n","/**\n * This is a very fast hash method\n * but it is not cryptographically secure.\n * For each run it will append a number between 0 and 2147483647 (=biggest 32 bit int).\n * @link http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n * @return a string as hash-result\n */\nexport function fastUnsecureHash(\n    inputString: string,\n    // used to test the polyfill\n    doNotUseTextEncoder?: boolean\n): string {\n    let hashValue = 0,\n        i, chr, len;\n\n    /**\n     * For better performance we first transform all\n     * chars into their ascii numbers at once.\n     *\n     * This is what makes the murmurhash implementation such fast.\n     * @link https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js#L4\n     */\n    let encoded: Uint8Array | number[];\n\n    /**\n     * All modern browsers support the TextEncoder\n     * @link https://caniuse.com/textencoder\n     * But to make RxDB work in other JavaScript runtimes,\n     * like when using it in flutter or QuickJS, we need to\n     * make it work even when there is no TextEncoder.\n     */\n    if (typeof TextEncoder !== 'undefined' && !doNotUseTextEncoder) {\n        encoded = new TextEncoder().encode(inputString);\n    } else {\n        encoded = [];\n        for (let j = 0; j < inputString.length; j++) {\n            encoded.push(inputString.charCodeAt(j));\n        }\n    }\n\n    for (i = 0, len = inputString.length; i < len; i++) {\n        chr = encoded[i];\n        hashValue = ((hashValue << 5) - hashValue) + chr;\n        hashValue |= 0; // Convert to 32bit integer\n    }\n    if (hashValue < 0) {\n        hashValue = hashValue * -1;\n    }\n\n    /**\n     * To make the output smaller\n     * but still have it to represent the same value,\n     * we use the biggest radix of 36 instead of just\n     * transforming it into a hex string.\n     */\n    return hashValue.toString(36);\n}\n\n/**\n * Default hash method used to create revision hashes\n * that do not have to be cryptographically secure.\n * IMPORTANT: Changing the default hashing method\n * requires a BREAKING change!\n */\nexport function defaultHashFunction(input: string): string {\n    return fastUnsecureHash(input);\n}\n","import type {\n    DeepReadonlyObject\n} from '../../types';\n\nexport function deepFreeze<T>(o: T): T {\n    Object.freeze(o);\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (\n            (o as any).hasOwnProperty(prop)\n            &&\n            (o as any)[prop] !== null\n            &&\n            (\n                typeof (o as any)[prop] === 'object'\n                ||\n                typeof (o as any)[prop] === 'function'\n            )\n            &&\n            !Object.isFrozen((o as any)[prop])\n        ) {\n            deepFreeze((o as any)[prop]);\n        }\n    });\n    return o;\n}\n\n\n\n/**\n * To get specific nested path values from objects,\n * RxDB normally uses the 'dot-prop' npm module.\n * But when performance is really relevant, this is not fast enough.\n * Instead we use a monad that can prepare some stuff up front\n * and we can re-use the generated function.\n */\nexport type ObjectPathMonadFunction<T, R = any> = (obj: T) => R;\nexport function objectPathMonad<T, R = any>(objectPath: string): ObjectPathMonadFunction<T, R> {\n    const split = objectPath.split('.');\n\n    /**\n     * Performance shortcut,\n     * if no nested path is used,\n     * directly return the field of the object.\n     */\n    if (split.length === 1) {\n        return (obj: T) => (obj as any)[objectPath];\n    }\n\n\n    return (obj: T) => {\n        let currentVal: any = obj;\n        let t = 0;\n        while (t < split.length) {\n            const subPath = split[t];\n            currentVal = currentVal[subPath];\n            if (typeof currentVal === 'undefined') {\n                return currentVal;\n            }\n            t++;\n        }\n        return currentVal;\n    };\n}\n\n\nexport function getFromObjectOrThrow<V>(\n    obj: { [k: string]: V; },\n    key: string\n): V {\n    const val = obj[key];\n    if (!val) {\n        throw new Error('missing value from object ' + key);\n    }\n    return val;\n}\n\n/**\n * returns a flattened object\n * @link https://gist.github.com/penguinboy/762197\n */\nexport function flattenObject(ob: any) {\n    const toReturn: any = {};\n\n    for (const i in ob) {\n        if (!ob.hasOwnProperty(i)) continue;\n\n        if ((typeof ob[i]) === 'object') {\n            const flatObject = flattenObject(ob[i]);\n            for (const x in flatObject) {\n                if (!flatObject.hasOwnProperty(x)) continue;\n\n                toReturn[i + '.' + x] = flatObject[x];\n            }\n        } else {\n            toReturn[i] = ob[i];\n        }\n    }\n    return toReturn;\n}\n\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone<T>(obj: T | DeepReadonlyObject<T> | Readonly<T>): T {\n    return Object.assign({}, obj) as any;\n}\n\n/**\n * @link https://stackoverflow.com/a/11509718/3443137\n */\nexport function firstPropertyNameOfObject(obj: any): string {\n    return Object.keys(obj)[0];\n}\nexport function firstPropertyValueOfObject<T>(obj: { [k: string]: T; }): T {\n    const key = Object.keys(obj)[0];\n    return obj[key];\n}\n\n\n/**\n * deep-sort an object so its attributes are in lexical order.\n * Also sorts the arrays inside of the object if no-array-sort not set\n */\nexport function sortObject(obj: any, noArraySort = false): any {\n    if (!obj) return obj; // do not sort null, false or undefined\n\n    // array\n    if (!noArraySort && Array.isArray(obj)) {\n        return obj\n            .sort((a, b) => {\n                if (typeof a === 'string' && typeof b === 'string')\n                    return a.localeCompare(b);\n\n                if (typeof a === 'object') return 1;\n                else return -1;\n            })\n            .map(i => sortObject(i, noArraySort));\n    }\n\n    // object\n    // array is also of type object\n    if (typeof obj === 'object' && !Array.isArray(obj)) {\n        if (obj instanceof RegExp) {\n            return obj;\n        }\n\n        const out: any = {};\n        Object.keys(obj)\n            .sort((a, b) => a.localeCompare(b))\n            .forEach(key => {\n                out[key] = sortObject(obj[key], noArraySort);\n            });\n        return out;\n    }\n\n    // everything else\n    return obj;\n}\n\n\n\n/**\n * Deep clone a plain json object.\n * Does not work with recursive stuff\n * or non-plain-json.\n * IMPORANT: Performance of this is very important,\n * do not change it without running performance tests!\n *\n * @link https://github.com/zxdong262/deep-copy/blob/master/src/index.ts\n */\nfunction deepClone<T>(src: T | DeepReadonlyObject<T>): T {\n    if (!src) {\n        return src;\n    }\n    if (src === null || typeof (src) !== 'object') {\n        return src;\n    }\n    if (Array.isArray(src)) {\n        const ret = new Array(src.length);\n        let i = ret.length;\n        while (i--) {\n            ret[i] = deepClone(src[i]);\n        }\n        return ret as any;\n    }\n    const dest: any = {};\n    // eslint-disable-next-line guard-for-in\n    for (const key in src) {\n        // TODO we should not be required to deep clone RegEx objects,\n        // this must be fixed in RxDB.\n        if (src[key] instanceof RegExp) {\n            dest[key] = src[key];\n        } else {\n            dest[key] = deepClone(src[key]);\n        }\n    }\n    return dest;\n}\nexport const clone = deepClone;\n\n\n\n/**\n * overwrites the getter with the actual value\n * Mostly used for caching stuff on the first run\n */\nexport function overwriteGetterForCaching<ValueType = any>(\n    obj: any,\n    getterName: string,\n    value: ValueType\n): ValueType {\n    Object.defineProperty(obj, getterName, {\n        get: function () {\n            return value;\n        }\n    });\n    return value;\n}\n\n\n\n/**\n * used to JSON.stringify() objects that contain a regex\n * @link https://stackoverflow.com/a/33416684 thank you Fabian Jakobs!\n */\nexport function stringifyFilter(key: string, value: any) {\n    if (value instanceof RegExp) {\n        return value.toString();\n    }\n    return value;\n}\n\n\n","/**\n * Helper functions for accessing the RxStorage instances.\n */\n\nimport { overwritable } from './overwritable';\nimport { newRxError } from './rx-error';\nimport {\n    fillPrimaryKey,\n    getPrimaryFieldOfPrimaryKey\n} from './rx-schema-helper';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowProcessed,\n    ById,\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    RxAttachmentData,\n    RxAttachmentWriteData,\n    RxChangeEvent,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorageWriteError,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    StringKeys,\n    RxStorageWriteErrorConflict,\n    RxStorageWriteErrorAttachment\n} from './types';\nimport {\n    createRevision,\n    defaultHashFunction,\n    ensureNotFalsy,\n    firstPropertyValueOfObject,\n    flatClone,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    now,\n    randomCouchString\n} from './plugins/utils';\n\nexport const INTERNAL_STORAGE_NAME = '_rxdb_internal';\nexport const RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\n\nexport async function getSingleDocument<RxDocType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any>,\n    documentId: string\n): Promise<RxDocumentData<RxDocType> | null> {\n    const results = await storageInstance.findDocumentsById([documentId], false);\n    const doc = results[documentId];\n    if (doc) {\n        return doc;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nexport async function writeSingle<RxDocType>(\n    instance: RxStorageInstance<RxDocType, any, any>,\n    writeRow: BulkWriteRow<RxDocType>,\n    context: string\n): Promise<RxDocumentData<RxDocType>> {\n    const writeResult = await instance.bulkWrite(\n        [writeRow],\n        context\n    );\n    if (Object.keys(writeResult.error).length > 0) {\n        const error = firstPropertyValueOfObject(writeResult.error);\n        throw error;\n    } else {\n        const ret = firstPropertyValueOfObject(writeResult.success);\n        return ret;\n    }\n}\n\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nexport function stackCheckpoints<CheckpointType>(\n    checkpoints: CheckpointType[]\n): CheckpointType {\n    return Object.assign(\n        {},\n        ...checkpoints\n    );\n}\n\nexport function storageChangeEventToRxChangeEvent<DocType>(\n    isLocal: boolean,\n    rxStorageChangeEvent: RxStorageChangeEvent<DocType>,\n    rxCollection?: RxCollection,\n): RxChangeEvent<DocType> {\n    const documentData = rxStorageChangeEvent.documentData;\n    const previousDocumentData = rxStorageChangeEvent.previousDocumentData;\n    const ret: RxChangeEvent<DocType> = {\n        eventId: rxStorageChangeEvent.eventId,\n        documentId: rxStorageChangeEvent.documentId,\n        collectionName: rxCollection ? rxCollection.name : undefined,\n        startTime: rxStorageChangeEvent.startTime,\n        endTime: rxStorageChangeEvent.endTime,\n        isLocal,\n        operation: rxStorageChangeEvent.operation,\n        documentData: overwritable.deepFreezeWhenDevMode(documentData as any),\n        previousDocumentData: overwritable.deepFreezeWhenDevMode(previousDocumentData as any)\n    };\n    return ret;\n}\n\nexport function throwIfIsStorageWriteError<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    documentId: string,\n    writeData: RxDocumentWriteData<RxDocType> | RxDocType,\n    error: RxStorageWriteError<RxDocType> | undefined\n) {\n    if (error) {\n        if (error.status === 409) {\n            throw newRxError('CONFLICT', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else if (error.status === 422) {\n            throw newRxError('VD2', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else {\n            throw error;\n        }\n    }\n}\n\n\n/**\n * From a list of documents,\n * it will return the document that has the 'newest' state\n * which must be used to create the correct checkpoint\n * for the whole list.\n */\nexport function getNewestOfDocumentStates<RxDocType>(\n    primaryPath: string,\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType> {\n    let ret: RxDocumentData<RxDocType> | null = null;\n    docs.forEach(doc => {\n        if (\n            !ret ||\n            doc._meta.lwt > ret._meta.lwt ||\n            (\n                doc._meta.lwt === ret._meta.lwt &&\n                (doc as any)[primaryPath] > (ret as any)[primaryPath]\n            )\n        ) {\n            ret = doc;\n        }\n\n    });\n    return ensureNotFalsy(ret as any);\n}\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n */\nexport function categorizeBulkWriteRows<RxDocType>(\n    storageInstance: RxStorageInstance<any, any, any>,\n    primaryPath: StringKeys<RxDocType>,\n    /**\n     * Current state of the documents\n     * inside of the storage. Used to determine\n     * which writes cause conflicts.\n     * This can be a Map for better performance\n     * but it can also be an object because some storages\n     * need to work with something that is JSON-stringify-able\n     * and we do not want to transform a big object into a Map\n     * each time we use it.\n     */\n    docsInDb:\n        Map<RxDocumentData<RxDocType>[StringKeys<RxDocType>] | string, RxDocumentData<RxDocType>> |\n        ById<RxDocumentData<RxDocType>>,\n    /**\n     * The write rows that are passed to\n     * RxStorageInstance().bulkWrite().\n     */\n    bulkWriteRows: BulkWriteRow<RxDocType>[],\n    context: string\n): CategorizeBulkWriteRowsOutput<RxDocType> {\n    const hasAttachments = !!storageInstance.schema.attachments;\n    const bulkInsertDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const bulkUpdateDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const errors: ById<RxStorageWriteError<RxDocType>> = {};\n    const changedDocumentIds: RxDocType[StringKeys<RxDocType>][] = [];\n    const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n        id: randomCouchString(10),\n        events: [],\n        checkpoint: null,\n        context\n    };\n\n    const attachmentsAdd: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n    }[] = [];\n    const attachmentsRemove: {\n        documentId: string;\n        attachmentId: string;\n    }[] = [];\n    const attachmentsUpdate: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n    }[] = [];\n\n\n    const startTime = now();\n\n    const docsByIdIsMap = typeof docsInDb.get === 'function';\n\n    bulkWriteRows.forEach(writeRow => {\n        const id = writeRow.document[primaryPath];\n        const documentInDb = docsByIdIsMap ? (docsInDb as any).get(id) : (docsInDb as any)[id];\n        let attachmentError: RxStorageWriteErrorAttachment<RxDocType> | undefined;\n\n        if (!documentInDb) {\n            /**\n             * It is possible to insert already deleted documents,\n             * this can happen on replication.\n             */\n            const insertedIsDeleted = writeRow.document._deleted ? true : false;\n            Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {\n                if (\n                    !(attachmentData as RxAttachmentWriteData).data\n                ) {\n                    attachmentError = {\n                        documentId: id as any,\n                        isError: true,\n                        status: 510,\n                        writeRow,\n                        attachmentId\n                    };\n                    errors[id as any] = attachmentError;\n                } else {\n                    attachmentsAdd.push({\n                        documentId: id as any,\n                        attachmentId,\n                        attachmentData: attachmentData as any\n                    });\n                }\n            });\n            if (!attachmentError) {\n                if (hasAttachments) {\n                    bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n                } else {\n                    bulkInsertDocs.push(writeRow as any);\n                }\n            }\n\n            if (!insertedIsDeleted) {\n                changedDocumentIds.push(id);\n                eventBulk.events.push({\n                    eventId: getUniqueDeterministicEventKey(storageInstance, primaryPath as any, writeRow),\n                    documentId: id as any,\n                    operation: 'INSERT',\n                    documentData: hasAttachments ? stripAttachmentsDataFromDocument(writeRow.document) : writeRow.document as any,\n                    previousDocumentData: hasAttachments && writeRow.previous ? stripAttachmentsDataFromDocument(writeRow.previous) : writeRow.previous as any,\n                    startTime,\n                    endTime: now()\n                });\n            }\n        } else {\n            // update existing document\n            const revInDb: string = documentInDb._rev;\n\n            /**\n             * Check for conflict\n             */\n            if (\n                (\n                    !writeRow.previous\n                ) ||\n                (\n                    !!writeRow.previous &&\n                    revInDb !== writeRow.previous._rev\n                )\n            ) {\n                // is conflict error\n                const err: RxStorageWriteError<RxDocType> = {\n                    isError: true,\n                    status: 409,\n                    documentId: id as any,\n                    writeRow: writeRow,\n                    documentInDb\n                };\n                errors[id as any] = err;\n                return;\n            }\n\n            // handle attachments data\n\n            const updatedRow: BulkWriteRowProcessed<RxDocType> = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow as any;\n            if (writeRow.document._deleted) {\n                /**\n                 * Deleted documents must have cleared all their attachments.\n                 */\n                if (writeRow.previous) {\n                    Object\n                        .keys(writeRow.previous._attachments)\n                        .forEach(attachmentId => {\n                            attachmentsRemove.push({\n                                documentId: id as any,\n                                attachmentId\n                            });\n                        });\n                }\n            } else {\n                // first check for errors\n                Object\n                    .entries(writeRow.document._attachments)\n                    .find(([attachmentId, attachmentData]) => {\n                        const previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : undefined;\n                        if (\n                            !previousAttachmentData &&\n                            !(attachmentData as RxAttachmentWriteData).data\n                        ) {\n                            attachmentError = {\n                                documentId: id as any,\n                                documentInDb,\n                                isError: true,\n                                status: 510,\n                                writeRow,\n                                attachmentId\n                            };\n                        }\n                        return true;\n                    });\n                if (!attachmentError) {\n                    Object\n                        .entries(writeRow.document._attachments)\n                        .forEach(([attachmentId, attachmentData]) => {\n                            const previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : undefined;\n                            if (!previousAttachmentData) {\n                                attachmentsAdd.push({\n                                    documentId: id as any,\n                                    attachmentId,\n                                    attachmentData: attachmentData as any\n                                });\n                            } else {\n                                const newDigest = updatedRow.document._attachments[attachmentId].digest;\n                                if (\n                                    (attachmentData as RxAttachmentWriteData).data &&\n                                    /**\n                                     * Performance shortcut,\n                                     * do not update the attachment data if it did not change.\n                                     */\n                                    previousAttachmentData.digest !== newDigest\n                                ) {\n                                    attachmentsUpdate.push({\n                                        documentId: id as any,\n                                        attachmentId,\n                                        attachmentData: attachmentData as RxAttachmentWriteData\n                                    });\n                                }\n                            }\n                        });\n                }\n            }\n            if (attachmentError) {\n                errors[id as any] = attachmentError;\n            } else {\n                bulkUpdateDocs.push(updatedRow);\n            }\n\n            const writeDoc = writeRow.document;\n\n            let eventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let previousEventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let operation: 'INSERT' | 'UPDATE' | 'DELETE' = null as any;\n\n            if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {\n                operation = 'INSERT';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc as any;\n            } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {\n                operation = 'UPDATE';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc as any;\n                previousEventDocumentData = writeRow.previous;\n            } else if (writeDoc._deleted) {\n                operation = 'DELETE';\n                eventDocumentData = ensureNotFalsy(writeRow.document) as any;\n                previousEventDocumentData = writeRow.previous;\n            } else {\n                throw newRxError('SNH', { args: { writeRow } });\n            }\n\n            changedDocumentIds.push(id);\n            eventBulk.events.push({\n                eventId: getUniqueDeterministicEventKey(storageInstance, primaryPath as any, writeRow),\n                documentId: id as any,\n                documentData: ensureNotFalsy(eventDocumentData),\n                previousDocumentData: previousEventDocumentData,\n                operation: operation,\n                startTime,\n                endTime: now()\n            });\n        }\n    });\n\n    return {\n        bulkInsertDocs,\n        bulkUpdateDocs,\n        errors,\n        changedDocumentIds,\n        eventBulk,\n        attachmentsAdd,\n        attachmentsRemove,\n        attachmentsUpdate\n    };\n}\n\nexport function stripAttachmentsDataFromRow<RxDocType>(writeRow: BulkWriteRow<RxDocType>): BulkWriteRowProcessed<RxDocType> {\n    return {\n        previous: writeRow.previous,\n        document: stripAttachmentsDataFromDocument(writeRow.document)\n    };\n}\n\nexport function getAttachmentSize(\n    attachmentBase64String: string\n): number {\n    return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nexport function attachmentWriteDataToNormalData(writeData: RxAttachmentData | RxAttachmentWriteData): RxAttachmentData {\n    const data = (writeData as RxAttachmentWriteData).data;\n    if (!data) {\n        return writeData as any;\n    }\n    const ret: RxAttachmentData = {\n        digest: defaultHashFunction(data),\n        length: getAttachmentSize(data),\n        type: writeData.type\n    };\n    return ret;\n}\n\nexport function stripAttachmentsDataFromDocument<RxDocType>(doc: RxDocumentWriteData<RxDocType>): RxDocumentData<RxDocType> {\n    const useDoc: RxDocumentData<RxDocType> = flatClone(doc) as any;\n    useDoc._attachments = {};\n    Object\n        .entries(doc._attachments)\n        .forEach(([attachmentId, attachmentData]) => {\n            useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n        });\n    return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nexport function flatCloneDocWithMeta<RxDocType>(\n    doc: RxDocumentData<RxDocType>\n): RxDocumentData<RxDocType> {\n    const ret = flatClone(doc);\n    ret._meta = flatClone(doc._meta);\n    return ret;\n}\n\n/**\n * Each event is labeled with the id\n * to make it easy to filter out duplicates.\n */\nexport function getUniqueDeterministicEventKey(\n    storageInstance: RxStorageInstance<any, any, any>,\n    primaryPath: string,\n    writeRow: BulkWriteRow<any>\n): string {\n    const docId = writeRow.document[primaryPath];\n    const binaryValues: boolean[] = [\n        !!writeRow.previous,\n        (writeRow.previous && writeRow.previous._deleted),\n        !!writeRow.document._deleted\n    ];\n    const binary = binaryValues.map(v => v ? '1' : '0').join('');\n    const eventKey = storageInstance.databaseName + '|' + storageInstance.collectionName + '|' + docId + '|' + '|' + binary + '|' + writeRow.document._rev;\n    return eventKey;\n}\n\n\nexport type WrappedRxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions> = RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> & {\n    originalStorageInstance: RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>;\n};\n\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nexport function getWrappedStorageInstance<\n    RxDocType,\n    Internals,\n    InstanceCreationOptions,\n    CheckpointType\n>(\n    database: RxDatabase<{}, Internals, InstanceCreationOptions>,\n    storageInstance: RxStorageInstance<RxDocType, Internals, InstanceCreationOptions, CheckpointType>,\n    /**\n     * The original RxJsonSchema\n     * before it was mutated by hooks.\n     */\n    rxJsonSchema: RxJsonSchema<RxDocumentData<RxDocType>>\n): WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> {\n    overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n    const primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n\n    function transformDocumentDataFromRxDBToRxStorage(\n        writeRow: BulkWriteRow<RxDocType>\n    ) {\n        let data = flatClone(writeRow.document);\n        data._meta = flatClone(data._meta);\n\n        /**\n         * Do some checks in dev-mode\n         * that would be too performance expensive\n         * in production.\n         */\n        if (overwritable.isDevMode()) {\n            // ensure that the primary key has not been changed\n            data = fillPrimaryKey(\n                primaryPath,\n                rxJsonSchema,\n                data as any\n            );\n\n            /**\n             * Ensure that the new revision is higher\n             * then the previous one\n             */\n            if (writeRow.previous) {\n                // TODO run this in the dev-mode plugin\n                // const prev = parseRevision(writeRow.previous._rev);\n                // const current = parseRevision(writeRow.document._rev);\n                // if (current.height <= prev.height) {\n                //     throw newRxError('SNH', {\n                //         dataBefore: writeRow.previous,\n                //         dataAfter: writeRow.document,\n                //         args: {\n                //             prev,\n                //             current\n                //         }\n                //     });\n                // }\n            }\n\n            /**\n             * Ensure that _meta fields have been merged\n             * and not replaced.\n             * This is important so that when one plugin A\n             * sets a _meta field and another plugin B does a write\n             * to the document, it must be ensured that the\n             * field of plugin A was not removed.\n             */\n            if (writeRow.previous) {\n                Object.keys(writeRow.previous._meta)\n                    .forEach(metaFieldName => {\n                        if (!writeRow.document._meta.hasOwnProperty(metaFieldName)) {\n                            throw newRxError('SNH', {\n                                dataBefore: writeRow.previous,\n                                dataAfter: writeRow.document\n                            });\n                        }\n                    });\n            }\n        }\n        data._meta.lwt = now();\n\n        /**\n         * Yes we really want to set the revision here.\n         * If you make a plugin that relies on having its own revision\n         * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n         */\n        data._rev = createRevision(\n            database.token,\n            writeRow.previous\n        );\n\n        return {\n            document: data,\n            previous: writeRow.previous\n        };\n    }\n\n    const ret: WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> = {\n        originalStorageInstance: storageInstance,\n        schema: storageInstance.schema,\n        internals: storageInstance.internals,\n        collectionName: storageInstance.collectionName,\n        databaseName: storageInstance.databaseName,\n        options: storageInstance.options,\n        bulkWrite(\n            rows: BulkWriteRow<RxDocType>[],\n            context: string\n        ) {\n            const toStorageWriteRows: BulkWriteRow<RxDocType>[] = rows\n                .map(row => transformDocumentDataFromRxDBToRxStorage(row));\n\n            return database.lockedRun(\n                () => storageInstance.bulkWrite(\n                    toStorageWriteRows,\n                    context\n                )\n            )\n                /**\n                 * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n                 * without sending the previous document version.\n                 * But for better developer experience, RxDB does allow to re-insert deleted documents.\n                 * We do this by automatically fixing the conflict errors for that case\n                 * by running another bulkWrite() and merging the results.\n                 * @link https://github.com/pubkey/rxdb/pull/3839\n                 */\n                .then(writeResult => {\n                    const reInsertErrors: RxStorageWriteErrorConflict<RxDocType>[] = Object\n                        .values(writeResult.error)\n                        .filter((error) => {\n                            if (\n                                error.status === 409 &&\n                                !error.writeRow.previous &&\n                                !error.writeRow.document._deleted &&\n                                ensureNotFalsy(error.documentInDb)._deleted\n                            ) {\n                                return true;\n                            }\n                            return false;\n                        }) as any;\n\n                    if (reInsertErrors.length > 0) {\n                        const useWriteResult: typeof writeResult = {\n                            error: flatClone(writeResult.error),\n                            success: flatClone(writeResult.success)\n                        };\n                        const reInserts: BulkWriteRow<RxDocType>[] = reInsertErrors\n                            .map((error) => {\n                                delete useWriteResult.error[error.documentId];\n                                return {\n                                    previous: error.documentInDb,\n                                    document: Object.assign(\n                                        {},\n                                        error.writeRow.document,\n                                        {\n                                            _rev: createRevision(\n                                                database.token,\n                                                error.documentInDb\n                                            )\n                                        }\n                                    )\n                                };\n                            });\n\n                        return database.lockedRun(\n                            () => storageInstance.bulkWrite(\n                                reInserts,\n                                context\n                            )\n                        ).then(subResult => {\n                            useWriteResult.error = Object.assign(\n                                useWriteResult.error,\n                                subResult.error\n                            );\n                            useWriteResult.success = Object.assign(\n                                useWriteResult.success,\n                                subResult.success\n                            );\n                            return useWriteResult;\n                        });\n                    }\n\n                    return writeResult;\n                });\n        },\n        query(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.query(preparedQuery)\n            );\n        },\n        count(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.count(preparedQuery)\n            );\n        },\n        findDocumentsById(ids, deleted) {\n            return database.lockedRun(\n                () => storageInstance.findDocumentsById(ids, deleted)\n            );\n        },\n        getAttachmentData(\n            documentId: string,\n            attachmentId: string\n        ) {\n            return database.lockedRun(\n                () => storageInstance.getAttachmentData(documentId, attachmentId)\n            );\n        },\n        getChangedDocumentsSince(limit: number, checkpoint?: any) {\n            return database.lockedRun(\n                () => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint)\n            );\n        },\n        cleanup(minDeletedTime: number) {\n            return database.lockedRun(\n                () => storageInstance.cleanup(minDeletedTime)\n            );\n        },\n        remove() {\n            return database.lockedRun(\n                () => storageInstance.remove()\n            );\n        },\n        close() {\n            return database.lockedRun(\n                () => storageInstance.close()\n            );\n        },\n        changeStream() {\n            return storageInstance.changeStream();\n        },\n        conflictResultionTasks() {\n            return storageInstance.conflictResultionTasks();\n        },\n        resolveConflictResultionTask(taskSolution) {\n            if (taskSolution.output.isEqual) {\n                return storageInstance.resolveConflictResultionTask(taskSolution);\n            }\n\n            const doc = Object.assign(\n                {},\n                taskSolution.output.documentData,\n                {\n                    _meta: getDefaultRxDocumentMeta(),\n                    _rev: getDefaultRevision(),\n                    _attachments: {}\n                }\n            );\n\n            const documentData = flatClone(doc);\n            delete (documentData as any)._meta;\n            delete (documentData as any)._rev;\n            delete (documentData as any)._attachments;\n\n            return storageInstance.resolveConflictResultionTask({\n                id: taskSolution.id,\n                output: {\n                    isEqual: false,\n                    documentData\n                }\n            });\n        }\n    };\n\n    return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nexport function ensureRxStorageInstanceParamsAreCorrect(\n    params: RxStorageInstanceCreationParams<any, any>\n) {\n    if (params.schema.keyCompression) {\n        throw newRxError('UT5', { args: { params } });\n    }\n    if (hasEncryption(params.schema)) {\n        throw newRxError('UT6', { args: { params } });\n    }\n}\n\nexport function hasEncryption(jsonSchema: RxJsonSchema<any>): boolean {\n    if (\n        (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0) ||\n        (jsonSchema.attachments && jsonSchema.attachments.encrypted)\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export function isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map","export function createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map","import { createErrorClass } from './createErrorClass';\nexport var UnsubscriptionError = createErrorClass(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map","export function arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map","import { __read, __spreadArray, __values } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof UnsubscriptionError) {\n                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\nexport { Subscription };\nexport var EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export var config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map","import { __read, __spreadArray } from \"tslib\";\nexport var timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map","export function noop() { }\n//# sourceMappingURL=noop.js.map","export var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map","import { config } from '../config';\nvar context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map","import { __extends } from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = config.onStoppedNotification;\n    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nexport var EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n//# sourceMappingURL=Subscriber.js.map","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(function () {\n        var onUnhandledError = config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map","export var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map","export function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map","import { identity } from './identity';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map","import { createErrorClass } from './createErrorClass';\nexport var ObjectUnsubscribedError = createErrorClass(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map","import { __extends, __values } from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        errorContext(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(function () {\n            _this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map","/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nconst isObject = (value: null) => {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n};\n\nconst disallowedKeys = new Set([\n    '__proto__',\n    'prototype',\n    'constructor',\n]);\n\nconst digits = new Set('0123456789');\n\nfunction getPathSegments(path: string) {\n    const parts = [];\n    let currentSegment = '';\n    let currentPart = 'start';\n    let isIgnoring = false;\n\n    for (const character of path) {\n        switch (character) {\n            case '\\\\': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (isIgnoring) {\n                    currentSegment += character;\n                }\n\n                currentPart = 'property';\n                isIgnoring = !isIgnoring;\n                break;\n            }\n\n            case '.': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'property';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (disallowedKeys.has(currentSegment)) {\n                    return [];\n                }\n\n                parts.push(currentSegment);\n                currentSegment = '';\n                currentPart = 'property';\n                break;\n            }\n\n            case '[': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'index';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (currentPart === 'property') {\n                    if (disallowedKeys.has(currentSegment)) {\n                        return [];\n                    }\n\n                    parts.push(currentSegment);\n                    currentSegment = '';\n                }\n\n                currentPart = 'index';\n                break;\n            }\n\n            case ']': {\n                if (currentPart === 'index') {\n                    parts.push(Number.parseInt(currentSegment, 10));\n                    currentSegment = '';\n                    currentPart = 'indexEnd';\n                    break;\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                // Falls through\n            }\n\n            default: {\n                if (currentPart === 'index' && !digits.has(character)) {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (currentPart === 'start') {\n                    currentPart = 'property';\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += '\\\\';\n                }\n\n                currentSegment += character;\n            }\n        }\n    }\n\n    if (isIgnoring) {\n        currentSegment += '\\\\';\n    }\n\n    switch (currentPart) {\n        case 'property': {\n            if (disallowedKeys.has(currentSegment)) {\n                return [];\n            }\n\n            parts.push(currentSegment);\n\n            break;\n        }\n\n        case 'index': {\n            throw new Error('Index was not closed');\n        }\n\n        case 'start': {\n            parts.push('');\n\n            break;\n        }\n        // No default\n    }\n\n    return parts;\n}\n\nfunction isStringIndex(object: any[], key: string) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key as any];\n    }\n\n    return false;\n}\n\nfunction assertNotStringIndex(object: any, key: string | number) {\n    if (isStringIndex(object, key as any)) {\n        throw new Error('Cannot use string index');\n    }\n}\n\nexport function getProperty(object: any, path: string | string[], value?: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return value;\n    }\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        if (isStringIndex(object as any, key as any)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        } else {\n            object = (object as any)[key];\n        }\n\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n\n            break;\n        }\n    }\n\n    return object === undefined ? value : object;\n}\n\nexport function setProperty(object: any, path: string, value: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return object;\n    }\n\n    const root = object;\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            object[key] = value;\n        } else if (!isObject(object[key])) {\n            object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n        }\n\n        object = object[key];\n    }\n\n    return root;\n}\n\nexport function deleteProperty(object: any, path: string) {\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            delete object[key];\n            return true;\n        }\n\n        object = object[key];\n\n        if (!isObject(object as any)) {\n            return false;\n        }\n    }\n}\n\nexport function hasProperty(object: any, path: string) {\n    if (!isObject(object) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return false;\n    }\n\n    for (const key of pathArray) {\n        if (!isObject(object) || !(key in object) || isStringIndex(object, key as any)) {\n            return false;\n        }\n\n        object = object[key];\n    }\n\n    return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path: string) {\n    if (typeof path !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n\n    return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value: any) {\n    if (Array.isArray(value)) {\n        return value.map((v, index) => [index, v]);\n    }\n\n    return Object.entries(value);\n}\n\nfunction stringifyPath(pathSegments: never[]) {\n    let result = '';\n\n    // eslint-disable-next-line prefer-const\n    for (let [index, segment] of entries(pathSegments)) {\n        if (typeof segment === 'number') {\n            result += `[${segment}]`;\n        } else {\n            segment = escapePath(segment);\n            result += index === 0 ? segment : `.${segment}`;\n        }\n    }\n\n    return result;\n}\n\nfunction* deepKeysIterator(object: any, currentPath = []): any {\n    if (!isObject(object)) {\n        if (currentPath.length > 0) {\n            yield stringifyPath(currentPath);\n        }\n\n        return;\n    }\n\n    for (const [key, value] of entries(object)) {\n        yield* deepKeysIterator(value, [...currentPath, key] as any);\n    }\n}\n\nexport function deepKeys(object: any) {\n    return [...deepKeysIterator(object)];\n}\n","import { newRxError } from './rx-error';\nimport type {\n    CompositePrimaryKey,\n    DeepReadonly,\n    JsonSchema,\n    PrimaryKey,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageDefaultCheckpoint,\n    StringKeys\n} from './types';\nimport {\n    flatClone,\n    getProperty,\n    isMaybeReadonlyArray,\n    RX_META_LWT_MINIMUM,\n    sortObject,\n    trimDots\n} from './plugins/utils';\n\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nexport function getPseudoSchemaForVersion<T = any>(\n    version: number,\n    primaryKey: StringKeys<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    const pseudoSchema: RxJsonSchema<RxDocumentData<T>> = fillWithDefaultSettings({\n        version,\n        type: 'object',\n        primaryKey: primaryKey as any,\n        properties: {\n            [primaryKey]: {\n                type: 'string',\n                maxLength: 100\n            }\n        } as any,\n        required: [primaryKey]\n    });\n    return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nexport function getSchemaByObjectPath<T = any>(\n    rxJsonSchema: RxJsonSchema<T>,\n    path: keyof T | string\n): JsonSchema {\n    let usePath: string = path as string;\n    usePath = usePath.replace(/\\./g, '.properties.');\n    usePath = 'properties.' + usePath;\n    usePath = trimDots(usePath);\n\n    const ret = getProperty(rxJsonSchema, usePath);\n    return ret;\n}\n\nexport function fillPrimaryKey<T>(\n    primaryPath: keyof T,\n    jsonSchema: RxJsonSchema<T>,\n    documentData: RxDocumentData<T>\n): RxDocumentData<T> {\n    const cloned = flatClone(documentData);\n    const newPrimary = getComposedPrimaryKeyOfDocumentData<T>(\n        jsonSchema,\n        documentData\n    );\n    const existingPrimary: string | undefined = documentData[primaryPath] as any;\n    if (\n        existingPrimary &&\n        existingPrimary !== newPrimary\n    ) {\n        throw newRxError(\n            'DOC19',\n            {\n                args: {\n                    documentData,\n                    existingPrimary,\n                    newPrimary,\n                },\n                schema: jsonSchema\n            });\n    }\n\n    (cloned as any)[primaryPath] = newPrimary;\n    return cloned;\n}\n\nexport function getPrimaryFieldOfPrimaryKey<RxDocType>(\n    primaryKey: PrimaryKey<RxDocType>\n): StringKeys<RxDocType> {\n    if (typeof primaryKey === 'string') {\n        return primaryKey as any;\n    } else {\n        return (primaryKey as CompositePrimaryKey<RxDocType>).key;\n    }\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nexport function getComposedPrimaryKeyOfDocumentData<RxDocType>(\n    jsonSchema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    documentData: Partial<RxDocType>\n): string {\n    if (typeof jsonSchema.primaryKey === 'string') {\n        return (documentData as any)[jsonSchema.primaryKey];\n    }\n\n    const compositePrimary: CompositePrimaryKey<RxDocType> = jsonSchema.primaryKey as any;\n    return compositePrimary.fields.map(field => {\n        const value = getProperty(documentData as any, field as string);\n        if (typeof value === 'undefined') {\n            throw newRxError('DOC18', { args: { field, documentData } });\n        }\n        return value;\n    }).join(compositePrimary.separator);\n}\n\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n *\n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n * - We need this for deterministic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nexport function normalizeRxJsonSchema<T>(jsonSchema: RxJsonSchema<T>): RxJsonSchema<T> {\n    const normalizedSchema: RxJsonSchema<T> = sortObject(jsonSchema, true);\n    return normalizedSchema;\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nexport function fillWithDefaultSettings<T = any>(\n    schemaObj: RxJsonSchema<T>\n): RxJsonSchema<RxDocumentData<T>> {\n    schemaObj = flatClone(schemaObj);\n    const primaryPath: string = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);\n    schemaObj.properties = flatClone(schemaObj.properties);\n\n    // additionalProperties is always false\n    schemaObj.additionalProperties = false;\n\n    // fill with key-compression-state ()\n    if (!schemaObj.hasOwnProperty('keyCompression')) {\n        schemaObj.keyCompression = false;\n    }\n\n    // indexes must be array\n    schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n    // required must be array\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n    // encrypted must be array\n    schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n    // add _rev\n    (schemaObj.properties as any)._rev = {\n        type: 'string',\n        minLength: 1\n    };\n\n    // add attachments\n    (schemaObj.properties as any)._attachments = {\n        type: 'object'\n    };\n\n    // add deleted flag\n    (schemaObj.properties as any)._deleted = {\n        type: 'boolean'\n    };\n\n    // add meta property\n    (schemaObj.properties as any)._meta = RX_META_SCHEMA;\n\n    /**\n     * meta fields are all required\n     */\n    schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n    (schemaObj.required as string[]).push('_deleted');\n    (schemaObj.required as string[]).push('_rev');\n    (schemaObj.required as string[]).push('_meta');\n    (schemaObj.required as string[]).push('_attachments');\n\n    // final fields are always required\n    const finalFields = getFinalFields(schemaObj);\n    schemaObj.required = schemaObj.required\n        .concat(finalFields as any)\n        .filter((field: string) => !field.includes('.'))\n        .filter((elem: any, pos: any, arr: any) => arr.indexOf(elem) === pos); // unique;\n\n    // version is 0 by default\n    schemaObj.version = schemaObj.version || 0;\n\n    /**\n     * Append primary key to indexes that do not contain the primaryKey.\n     * All indexes must have the primaryKey to ensure a deterministic sort order.\n     */\n    if (schemaObj.indexes) {\n        schemaObj.indexes = schemaObj.indexes.map(index => {\n            const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\n            if (!arIndex.includes(primaryPath)) {\n                const modifiedIndex = arIndex.slice(0);\n                modifiedIndex.push(primaryPath);\n                return modifiedIndex;\n            }\n            return arIndex;\n        });\n    }\n\n    return schemaObj as any;\n}\n\n\nexport const RX_META_SCHEMA: JsonSchema = {\n    type: 'object',\n    properties: {\n        /**\n         * The last-write time.\n         * Unix time in milliseconds.\n         */\n        lwt: {\n            type: 'number',\n            /**\n             * We use 1 as minimum so that the value is never falsy.\n             */\n            minimum: RX_META_LWT_MINIMUM,\n            maximum: 1000000000000000,\n            multipleOf: 0.01\n        }\n    },\n    /**\n     * Additional properties are allowed\n     * and can be used by plugins to set various flags.\n     */\n    additionalProperties: true as any,\n    required: [\n        'lwt'\n    ]\n};\n\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nexport function getFinalFields<T = any>(\n    jsonSchema: RxJsonSchema<T>\n): string[] {\n    const ret = Object.keys(jsonSchema.properties)\n        .filter(key => (jsonSchema as any).properties[key].final);\n\n    // primary is also final\n    const primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n    ret.push(primaryPath);\n\n    // fields of composite primary are final\n    if (typeof jsonSchema.primaryKey !== 'string') {\n        (jsonSchema.primaryKey as CompositePrimaryKey<T>).fields\n            .forEach(field => ret.push(field as string));\n    }\n\n    return ret;\n}\n\n\nexport const DEFAULT_CHECKPOINT_SCHEMA: DeepReadonly<JsonSchema<RxStorageDefaultCheckpoint>> = {\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string'\n        },\n        lwt: {\n            type: 'number'\n        }\n    },\n    required: [\n        'id',\n        'lwt'\n    ],\n    additionalProperties: false\n} as const;\n","import { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    MangoQuerySelector,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanerOpts\n} from './types';\n\n\nexport const INDEX_MAX = String.fromCharCode(65535);\nexport const INDEX_MIN = -Infinity;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const selector = query.selector;\n\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    } else {\n        indexes.push([primaryPath]);\n    }\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex.join(',');\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    indexes.forEach((index) => {\n        let inclusiveEnd = true;\n        let inclusiveStart = true;\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = (selector as any)[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                matcherOpts = {\n                    startKey: inclusiveStart ? INDEX_MIN : INDEX_MAX,\n                    endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            } else {\n                operators.forEach(operator => {\n                    if (LOGICAL_OPERATORS.has(operator)) {\n                        const operatorValue = matcher[operator];\n                        const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                        matcherOpts = Object.assign(matcherOpts, partialOpts);\n                    }\n                });\n            }\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n\n            if (inclusiveStart && !matcherOpts.inclusiveStart) {\n                inclusiveStart = false;\n            }\n            if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n                inclusiveEnd = false;\n            }\n\n            return matcherOpts;\n        });\n\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys: opts.map(opt => opt.startKey),\n            endKeys: opts.map(opt => opt.endKey),\n            inclusiveEnd,\n            inclusiveStart,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(','),\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector)\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality > 0 &&\n                quality > currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * No index found, use the default index\n     */\n    if (!currentBestQueryPlan) {\n        currentBestQueryPlan = {\n            index: [primaryPath],\n            startKeys: [INDEX_MIN],\n            endKeys: [INDEX_MAX],\n            inclusiveEnd: true,\n            inclusiveStart: true,\n            sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)\n        };\n    }\n\n    return currentBestQueryPlan;\n}\n\nexport const LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport const LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport const UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\n\nexport function isSelectorSatisfiedByIndex(\n    index: string[],\n    selector: MangoQuerySelector<any>\n): boolean {\n    const selectorEntries = Object.entries(selector);\n    const hasNonMatchingOperator = selectorEntries\n        .find(([fieldName, operation]) => {\n            if (!index.includes(fieldName)) {\n                return true;\n            }\n            const hasNonLogicOperator = Object.entries(operation as any)\n                .find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n            return hasNonLogicOperator;\n        });\n    if (hasNonMatchingOperator) {\n        return false;\n    }\n\n\n    let prevLowerBoundaryField: any;\n    const hasMoreThenOneLowerBoundaryField = index.find(fieldName => {\n        const operation = selector[fieldName];\n        if (!operation) {\n            return false;\n        }\n        const hasLowerLogicOp = Object.keys(operation).find(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (prevLowerBoundaryField && hasLowerLogicOp) {\n            return true;\n        } else if (hasLowerLogicOp !== '$eq') {\n            prevLowerBoundaryField = hasLowerLogicOp;\n        }\n        return false;\n    });\n    if (hasMoreThenOneLowerBoundaryField) {\n        return false;\n    }\n\n    let prevUpperBoundaryField: any;\n    const hasMoreThenOneUpperBoundaryField = index.find(fieldName => {\n        const operation = selector[fieldName];\n        if (!operation) {\n            return false;\n        }\n        const hasUpperLogicOp = Object.keys(operation).find(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (prevUpperBoundaryField && hasUpperLogicOp) {\n            return true;\n        } else if (hasUpperLogicOp !== '$eq') {\n            prevUpperBoundaryField = hasUpperLogicOp;\n        }\n        return false;\n    });\n    if (hasMoreThenOneUpperBoundaryField) {\n        return false;\n    }\n\n    return true;\n}\n\nexport function getMatcherQueryOpts(\n    operator: string,\n    operatorValue: any\n): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n\n    const pointsPerMatchingKey = 10;\n    const idxOfFirstMinStartKey = queryPlan.startKeys.findIndex(keyValue => keyValue === INDEX_MIN);\n    if (idxOfFirstMinStartKey > 0) {\n        quality = quality + (idxOfFirstMinStartKey * pointsPerMatchingKey);\n    }\n\n    const idxOfFirstMaxEndKey = queryPlan.endKeys.findIndex(keyValue => keyValue === INDEX_MAX);\n    if (idxOfFirstMaxEndKey > 0) {\n        quality = quality + (idxOfFirstMaxEndKey * pointsPerMatchingKey);\n    }\n\n    const pointsIfNoReSortMustBeDone = 5;\n    if (queryPlan.sortFieldsSameAsIndexFields) {\n        quality = quality + pointsIfNoReSortMustBeDone;\n    }\n\n    return quality;\n}\n","/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    ensureNotFalsy,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils';\nimport { INDEX_MAX, INDEX_MIN } from './query-planner';\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n\n    /**\n     * Prepare all relevant information\n     * outside of the returned function\n     * to save performance when the returned\n     * function is called many times.\n     */\n    const fieldNameProperties: {\n        fieldName: string;\n        schemaPart: JsonSchema;\n        /*\n         * Only in number fields.\n         */\n        parsedLengths?: ParsedLengths;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        if (!schemaPart) {\n            throw new Error('not in schema: ' + fieldName);\n        }\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        return {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            hasComplexPath: fieldName.includes('.'),\n            getValueFn: objectPathMonad(fieldName)\n        };\n    });\n\n\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        fieldNameProperties.forEach(props => {\n            const schemaPart = props.schemaPart;\n            const type = schemaPart.type;\n\n            let fieldValue = props.getValueFn(docData);\n\n            if (type === 'string') {\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                str += fieldValue.padEnd(schemaPart.maxLength as number, ' ');\n            } else if (type === 'boolean') {\n                const boolToStr = fieldValue ? '1' : '0';\n                str += boolToStr;\n            } else {\n                const parsedLengths = ensureNotFalsy(props.parsedLengths);\n                if (!fieldValue) {\n                    fieldValue = 0;\n                }\n                str += getNumberIndexString(\n                    parsedLengths,\n                    fieldValue\n                );\n            }\n        });\n        return str;\n    };\n    return ret;\n}\n\ndeclare type ParsedLengths = {\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    let str: string = '';\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    str += nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    const splitByDecimalPoint = fieldValue.toString().split('.');\n    const decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[],\n    inclusiveStart: boolean\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else {\n                    // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n                    str += ''.padEnd(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += inclusiveStart ? '0' : INDEX_MAX;\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MIN) {\n                    const fillChar = inclusiveStart ? '0' : INDEX_MAX;\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[],\n    inclusiveEnd: boolean\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength);\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n                } else {\n                    str += ''.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += inclusiveEnd ? '0' : '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    const fillChar = inclusiveEnd ? '9' : '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n","/**\n * returns a promise that resolves on the next tick\n */\nexport function nextTick(): Promise<void> {\n    return new Promise(res => setTimeout(res, 0));\n}\n\nexport function promiseWait(ms: number = 0): Promise<void> {\n    return new Promise(res => setTimeout(res, ms));\n}\n\nexport function toPromise<T>(maybePromise: Promise<T> | T): Promise<T> {\n    if (maybePromise && typeof (maybePromise as any).then === 'function') {\n        // is promise\n        return maybePromise as any;\n    } else {\n        return Promise.resolve(maybePromise);\n    }\n}\n\n\nexport const PROMISE_RESOLVE_TRUE: Promise<true> = Promise.resolve(true);\nexport const PROMISE_RESOLVE_FALSE: Promise<false> = Promise.resolve(false);\nexport const PROMISE_RESOLVE_NULL: Promise<null> = Promise.resolve(null);\nexport const PROMISE_RESOLVE_VOID: Promise<void> = Promise.resolve();\n\n\nexport function requestIdlePromise(timeout: number | null = null) {\n    if (\n        typeof window === 'object' &&\n        (window as any)['requestIdleCallback']\n    ) {\n        return new Promise(\n            res => (window as any)['requestIdleCallback'](res, {\n                timeout\n            })\n        );\n    } else {\n        return promiseWait(0);\n    }\n}\n\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nexport function requestIdleCallbackIfAvailable(fun: Function): void {\n    if (\n        typeof window === 'object' &&\n        (window as any)['requestIdleCallback']\n    ) (window as any)['requestIdleCallback'](fun);\n}\n\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nexport function promiseSeries(\n    tasks: Function[],\n    initial?: any\n): Promise<any[]> {\n    return tasks\n        .reduce(\n            (current, next) => (current as any).then(next),\n            Promise.resolve(initial)\n        );\n}\n","/**\n * Everything in this file was copied and adapted from\n * @link https://github.com/mikolalysenko/binary-search-bounds\n *\n * TODO We should use the original npm module instead when this bug is fixed:\n * @link https://github.com/mikolalysenko/binary-search-bounds/pull/14\n */\n\n\n\ntype Compare<T> = ((a: T, b: T) => number | null | undefined);\n\nfunction ge<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any): number {\n    let i: number = h + 1;\n    while (l <= h) {\n        const m = (l + h) >>> 1;\n        const x: any = a[m];\n        const p: any = (c !== undefined) ? c(x, y) : (x - (y as any));\n        if (p >= 0) {\n            i = m; h = m - 1;\n        } else {\n            l = m + 1;\n        }\n    }\n    return i;\n}\n\nfunction gt<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any): number {\n    let i = h + 1;\n    while (l <= h) {\n        const m = (l + h) >>> 1;\n        const x = a[m];\n        const p: any = (c !== undefined) ? c(x, y) : ((x as any) - (y as any));\n        if (p > 0) {\n            i = m; h = m - 1;\n        } else {\n            l = m + 1;\n        }\n    }\n    return i;\n}\n\nfunction lt<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any): number {\n    let i = l - 1;\n    while (l <= h) {\n        const m = (l + h) >>> 1, x = a[m];\n        const p: any = (c !== undefined) ? c(x, y) : ((x as any) - (y as any));\n        if (p < 0) {\n            i = m; l = m + 1;\n        } else {\n            h = m - 1;\n        }\n    }\n    return i;\n}\n\nfunction le<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any): number {\n    let i = l - 1;\n    while (l <= h) {\n        const m = (l + h) >>> 1, x = a[m];\n        const p: any = (c !== undefined) ? c(x, y) : ((x as any) - (y as any));\n        if (p <= 0) {\n            i = m; l = m + 1;\n        } else {\n            h = m - 1;\n        }\n    }\n    return i;\n}\n\nfunction eq<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any): number {\n    while (l <= h) {\n        const m = (l + h) >>> 1, x = a[m];\n        const p: any = (c !== undefined) ? c(x, y) : ((x as any) - (y as any));\n        if (p === 0) {\n            return m;\n        }\n        if (p <= 0) {\n            l = m + 1;\n        } else {\n            h = m - 1;\n        }\n    }\n    return -1;\n}\n\nfunction norm<T>(a: T[], y: T, c: Compare<T>, l: any, h: any, f: any) {\n    if (typeof c === 'function') {\n        return f(a, y, c, (l === undefined) ? 0 : l | 0, (h === undefined) ? a.length - 1 : h | 0);\n    }\n    return f(a, y, undefined, (c === undefined) ? 0 : c | 0, (l === undefined) ? a.length - 1 : l | 0);\n}\n\n\nexport function boundGE<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any) {\n    return norm(a, y, c, l, h, ge);\n}\nexport function boundGT<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any) {\n    return norm(a, y, c, l, h, gt);\n}\nexport function boundLT<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any) {\n    return norm(a, y, c, l, h, lt);\n}\nexport function boundLE<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any) {\n    return norm(a, y, c, l, h, le);\n}\nexport function boundEQ<T>(a: T[], y: T, c: Compare<T>, l?: any, h?: any) {\n    return norm(a, y, c, l, h, eq);\n}\n","import type {\n    BulkWriteRow,\n    RxDocumentData,\n    RxJsonSchema\n} from '../../types';\nimport type {\n    DocWithIndexString,\n    MemoryStorageInternals,\n    MemoryStorageInternalsByIndex\n} from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function attachmentMapKey(documentId: string, attachmentId: string): string {\n    return documentId + '||' + attachmentId;\n}\n\nconst SORT_BY_INDEX_STRING = (a: DocWithIndexString<any>, b: DocWithIndexString<any>) => {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\n\n\n\nexport function putWriteRowToState<RxDocType>(\n    docId: string,\n    state: MemoryStorageInternals<RxDocType>,\n    stateByIndex: MemoryStorageInternalsByIndex<RxDocType>[],\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    state.documents.set(docId, row.document as any);\n    stateByIndex.forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = byIndex.getIndexableString(row.document as any);\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            SORT_BY_INDEX_STRING,\n            true\n        );\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = byIndex.getIndexableString(docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1);\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1);\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = byIndex.getIndexableString(doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n","/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, noCopy) {\n  var ret = noCopy ? array : array.slice(0);\n  var high = ret.length - 1;\n  var low = 0;\n  var mid = 0;\n  /**\n   * Optimization shortcut.\n   */\n\n  if (ret.length === 0) {\n    ret.push(item);\n    return [ret, 0];\n  }\n  /**\n   * So we do not have to ghet the ret[mid] doc again\n   * at the last we store it here.\n   */\n\n\n  var lastMidDoc;\n\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = ret[mid];\n\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n  /**\n   * Insert at correct position\n   */\n\n\n  ret.splice(mid, 0, item);\n  return [ret, mid];\n}","import { getIndexableStringMonad } from '../../custom-index';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport type { RxDocumentData, RxJsonSchema } from '../../types';\nimport { toArray } from '../../plugins/utils';\nimport type { MemoryStorageInternals } from './memory-types';\n\nexport function addIndexesToInternalsState<RxDocType>(\n    state: MemoryStorageInternals<RxDocType>,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\n) {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const useIndexes: string[][] = !schema.indexes ? [] : schema.indexes.map(row => toArray(row)) as any;\n\n    // we need this as default index\n    useIndexes.push([\n        primaryPath\n    ]);\n\n    // we need this index for running cleanup()\n    useIndexes.push([\n        '_meta.lwt',\n        primaryPath\n    ]);\n\n\n    useIndexes.forEach(indexAr => {\n        /**\n         * Running a query will only return non-deleted documents\n         * so all indexes must have the the deleted field as first index field.\n         */\n        indexAr.unshift('_deleted');\n\n        state.byIndex[getMemoryIndexName(indexAr)] = {\n            index: indexAr,\n            docsWithIndex: [],\n            getIndexableString: getIndexableStringMonad(schema, indexAr)\n        };\n    });\n\n    // we need this index for the changes()\n    const changesIndex = [\n        '_meta.lwt',\n        primaryPath\n    ];\n    const indexName = getMemoryIndexName(changesIndex);\n    state.byIndex[indexName] = {\n        index: changesIndex,\n        docsWithIndex: [],\n        getIndexableString: getIndexableStringMonad(schema, changesIndex)\n    };\n\n}\n\n\nexport function getMemoryIndexName(index: string[]): string {\n    return index.join(',');\n}\n","import type {\n    MaybeReadonly\n} from '../../types';\n\nexport function lastOfArray<T>(ar: T[]): T | undefined {\n    return ar[ar.length - 1];\n}\n\n/**\n * shuffle the given array\n */\nexport function shuffleArray<T>(arr: T[]): T[] {\n    return arr.sort(() => (Math.random() - 0.5));\n}\n\nexport function toArray<T>(input: T | T[] | Readonly<T> | Readonly<T[]>): T[] {\n    return Array.isArray(input) ? (input as any[]).slice(0) : [input];\n}\n\n/**\n * Split array with items into smaller arrays with items\n * @link https://stackoverflow.com/a/7273794/3443137\n */\nexport function batchArray<T>(array: T[], batchSize: number): T[][] {\n    array = array.slice(0);\n    const ret: T[][] = [];\n    while (array.length) {\n        const batch = array.splice(0, batchSize);\n        ret.push(batch);\n    }\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/15996017\n */\nexport function removeOneFromArrayIfMatches<T>(ar: T[], condition: (x: T) => boolean): T[] {\n    ar = ar.slice();\n    let i = ar.length;\n    let done = false;\n    while (i-- && !done) {\n        if (condition(ar[i])) {\n            done = true;\n            ar.splice(i, 1);\n        }\n    }\n    return ar;\n}\n\n/**\n * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>\n */\nexport function isMaybeReadonlyArray(x: any): x is MaybeReadonly<any[]> {\n    // While this looks strange, it's a workaround for an issue in TypeScript:\n    // https://github.com/microsoft/TypeScript/issues/17002\n    //\n    // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,\n    // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.\n    // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while\n    // still performing runtime type inspection.\n    return Array.isArray(x);\n}\n\n\n\n\n\n/**\n * Use this in array.filter() to remove all empty slots\n * and have the correct typings afterwards.\n * @link https://stackoverflow.com/a/46700791/3443137\n */\nexport function arrayFilterNotEmpty<TValue>(value: TValue | null | undefined): value is TValue {\n    if (value === null || value === undefined) {\n        return false;\n    }\n    return true;\n}\n","/**\n * Utility constants and functions\n */\nexport const MAX_INT = 2147483647;\nexport const MIN_INT = -2147483648;\nexport const MAX_LONG = Number.MAX_SAFE_INTEGER;\nexport const MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = (value) => {\n    const s = stringify(value);\n    let hash = 0;\n    let i = s.length;\n    while (i)\n        hash = ((hash << 5) - hash) ^ s.charCodeAt(--i);\n    return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\n    \"null\",\n    \"undefined\",\n    \"boolean\",\n    \"number\",\n    \"string\",\n    \"date\",\n    \"regexp\",\n]);\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n    null: 0,\n    undefined: 0,\n    number: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    boolean: 5,\n    date: 6,\n    regexp: 7,\n    function: 8,\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nexport const DEFAULT_COMPARATOR = (a, b) => {\n    if (a === MISSING)\n        a = undefined;\n    if (b === MISSING)\n        b = undefined;\n    const u = SORT_ORDER_BY_TYPE[getType(a).toLowerCase()];\n    const v = SORT_ORDER_BY_TYPE[getType(b).toLowerCase()];\n    if (u !== v)\n        return u - v;\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n};\nconst OBJECT_PROTOTYPE = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nexport function assert(condition, message) {\n    if (!condition)\n        throw new Error(message);\n}\n/**\n * Deep clone an object\n */\nexport function cloneDeep(obj) {\n    if (obj instanceof Array)\n        return obj.map(cloneDeep);\n    if (obj instanceof Date)\n        return new Date(obj);\n    if (isObject(obj))\n        return objectMap(obj, cloneDeep);\n    return obj;\n}\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nexport function getType(v) {\n    return OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\n}\nexport function isBoolean(v) {\n    return typeof v === \"boolean\";\n}\nexport function isString(v) {\n    return typeof v === \"string\";\n}\nexport function isNumber(v) {\n    return !isNaN(v) && typeof v === \"number\";\n}\nexport const isArray = Array.isArray;\nexport function isObject(v) {\n    if (!v)\n        return false;\n    const proto = Object.getPrototypeOf(v);\n    return ((proto === OBJECT_PROTOTYPE || proto === null) &&\n        OBJECT_TAG === Object.prototype.toString.call(v));\n}\nexport function isObjectLike(v) {\n    return v === Object(v);\n} // objects, arrays, functions, date, custom object\nexport function isDate(v) {\n    return v instanceof Date;\n}\nexport function isRegExp(v) {\n    return v instanceof RegExp;\n}\nexport function isFunction(v) {\n    return typeof v === \"function\";\n}\nexport function isNil(v) {\n    return v === null || v === undefined;\n}\nexport function inArray(arr, item) {\n    return arr.includes(item);\n}\nexport function notInArray(arr, item) {\n    return !inArray(arr, item);\n}\nexport function truthy(arg) {\n    return !!arg;\n}\nexport function isEmpty(x) {\n    return (isNil(x) ||\n        (isString(x) && !x) ||\n        (x instanceof Array && x.length === 0) ||\n        (isObject(x) && Object.keys(x).length === 0));\n}\nexport function isMissing(m) {\n    return m === MISSING;\n}\n// ensure a value is an array or wrapped within one\nexport function ensureArray(x) {\n    return x instanceof Array ? x : [x];\n}\nexport function has(obj, prop) {\n    return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\n/**\n * Transform values in an object\n *\n * @param  {Object}   obj   An object whose values to transform\n * @param  {Function} fn The transform function\n * @return {Array|Object} Result object after applying the transform\n */\nexport function objectMap(obj, fn) {\n    const o = {};\n    const objKeys = Object.keys(obj);\n    for (let i = 0; i < objKeys.length; i++) {\n        const k = objKeys[i];\n        o[k] = fn(obj[k], k);\n    }\n    return o;\n}\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the source value (right hand side) is returned.\n * If inputs are arrays of same length and all elements are mergable, elements in the same position are merged together.\n * If AnyVal of the elements are unmergeable, elements in the source are appended to the target.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nexport function merge(target, obj, options) {\n    // take care of missing inputs\n    if (isMissing(target))\n        return obj;\n    if (isMissing(obj))\n        return target;\n    const inputs = [target, obj];\n    if (!(inputs.every(isObject) || inputs.every(isArray))) {\n        throw Error(\"mismatched types. must both be array or object\");\n    }\n    // default options\n    options = options || { flatten: false };\n    if (isArray(target)) {\n        const result = target;\n        const input = obj;\n        if (options.flatten) {\n            let i = 0;\n            let j = 0;\n            while (i < result.length && j < input.length) {\n                result[i] = merge(result[i++], input[j++], options);\n            }\n            while (j < input.length) {\n                result.push(obj[j++]);\n            }\n        }\n        else {\n            into(result, input);\n        }\n    }\n    else {\n        Object.keys(obj).forEach((k) => {\n            if (has(obj, k)) {\n                if (has(target, k)) {\n                    target[k] = merge(target[k], obj[k], options);\n                }\n                else {\n                    target[k] = obj[k];\n                }\n            }\n        });\n    }\n    return target;\n}\nfunction addIndex(root, key, index) {\n    if (root.key < key) {\n        if (root.right) {\n            addIndex(root.right, key, index);\n        }\n        else {\n            root.right = { key, indexes: [index] };\n        }\n    }\n    else if (root.key > key) {\n        if (root.left) {\n            addIndex(root.left, key, index);\n        }\n        else {\n            root.left = { key, indexes: [index] };\n        }\n    }\n    else {\n        root.indexes.push(index);\n    }\n}\nfunction getIndexes(root, key) {\n    if (root.key == key) {\n        return root.indexes;\n    }\n    else if (root.key < key) {\n        return root.right ? getIndexes(root.right, key) : undefined;\n    }\n    else if (root.key > key) {\n        return root.left ? getIndexes(root.left, key) : undefined;\n    }\n    return undefined;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} a The first array\n * @param  {Array} b The second array\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array}    Result array\n */\nexport function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n    // if any array is empty, there is no intersection\n    if (input.some((arr) => arr.length == 0))\n        return [];\n    // sort input arrays by size\n    const sortedIndex = input.map((a, i) => [i, a.length]);\n    sortedIndex.sort((a, b) => a[1] - b[1]);\n    // matched items index of first array for all other arrays.\n    const result = [];\n    const smallestArray = input[sortedIndex[0][0]];\n    const root = {\n        key: hashCode(smallestArray[0], hashFunction),\n        indexes: [0],\n    };\n    for (let i = 1; i < smallestArray.length; i++) {\n        const val = smallestArray[i];\n        const h = hashCode(val, hashFunction);\n        addIndex(root, h, i);\n    }\n    let maxResultSize = sortedIndex[0][1];\n    const orderedIndexes = [];\n    for (let i = 1; i < sortedIndex.length; i++) {\n        const arrayIndex = sortedIndex[i][0];\n        const data = input[arrayIndex];\n        // number of matched items\n        let size = 0;\n        for (let j = 0; j < data.length; j++) {\n            const h = hashCode(data[j], hashFunction);\n            const indexes = getIndexes(root, h);\n            // not included.\n            if (!indexes)\n                continue;\n            // check items equality to mitigate hash collisions and select the matching index.\n            const idx = indexes\n                .map((n) => smallestArray[n])\n                .findIndex((v) => isEqual(v, data[j]));\n            // not included\n            if (idx == -1)\n                continue;\n            // item matched. ensure map exist for marking index\n            if (result.length < i)\n                result.push({});\n            // map to index of the actual value and set position\n            result[result.length - 1][indexes[idx]] = true;\n            // if we have seen max result items we can stop.\n            size = Object.keys(result[result.length - 1]).length;\n            // ensure stabilty\n            if (arrayIndex == 0) {\n                if (orderedIndexes.indexOf(indexes[idx]) == -1) {\n                    orderedIndexes.push(indexes[idx]);\n                }\n            }\n        }\n        // no intersection if nothing found\n        if (size == 0)\n            return [];\n        // new max result size\n        maxResultSize = Math.min(maxResultSize, size);\n    }\n    const freq = {};\n    // count occurrences\n    result.forEach((m) => {\n        Object.keys(m).forEach((k) => {\n            const n = parseFloat(k);\n            freq[n] = freq[n] || 0;\n            freq[n]++;\n        });\n    });\n    const keys = orderedIndexes;\n    if (keys.length == 0) {\n        // note: cannot use parseInt due to second argument for radix.\n        keys.push(...Object.keys(freq).map(parseFloat));\n        keys.sort();\n    }\n    return keys\n        .filter((n) => freq[n] == input.length - 1)\n        .map((n) => smallestArray[n]);\n}\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nexport function flatten(xs, depth) {\n    const arr = [];\n    function flatten2(ys, n) {\n        for (let i = 0, len = ys.length; i < len; i++) {\n            if (isArray(ys[i]) && (n > 0 || n < 0)) {\n                flatten2(ys[i], Math.max(-1, n - 1));\n            }\n            else {\n                arr.push(ys[i]);\n            }\n        }\n    }\n    flatten2(xs, depth);\n    return arr;\n}\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nexport function isEqual(a, b) {\n    const lhs = [a];\n    const rhs = [b];\n    while (lhs.length > 0) {\n        a = lhs.pop();\n        b = rhs.pop();\n        // strictly equal must be equal.\n        if (a === b)\n            continue;\n        // unequal types and functions cannot be equal.\n        const nativeType = getType(a).toLowerCase();\n        if (nativeType !== getType(b).toLowerCase() || nativeType === \"function\") {\n            return false;\n        }\n        // leverage toString for Date and RegExp types\n        if (nativeType === \"array\") {\n            const xs = a;\n            const ys = b;\n            if (xs.length !== ys.length)\n                return false;\n            if (xs.length === ys.length && xs.length === 0)\n                continue;\n            into(lhs, xs);\n            into(rhs, ys);\n        }\n        else if (nativeType === \"object\") {\n            // deep compare objects\n            const aKeys = Object.keys(a);\n            const bKeys = Object.keys(b);\n            // check length of keys early\n            if (aKeys.length !== bKeys.length)\n                return false;\n            // compare keys\n            for (let i = 0, len = aKeys.length; i < len; i++) {\n                const k = aKeys[i];\n                // not found\n                if (!has(b, k))\n                    return false;\n                // key found\n                lhs.push(a[k]);\n                rhs.push(b[k]);\n            }\n        }\n        else {\n            // compare encoded values\n            if (stringify(a) !== stringify(b))\n                return false;\n        }\n    }\n    return lhs.length === 0;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}\n */\nexport function unique(xs, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (xs.length == 0)\n        return [];\n    const root = {\n        key: hashCode(xs[0], hashFunction),\n        indexes: [0],\n    };\n    // hash items on to tree to track collisions\n    for (let i = 1; i < xs.length; i++) {\n        addIndex(root, hashCode(xs[i], hashFunction), i);\n    }\n    const result = [];\n    // walk tree and remove duplicates\n    const stack = [root];\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (node.indexes.length == 1) {\n            result.push(node.indexes[0]);\n        }\n        else {\n            // handle collisions by matching all items\n            const arr = node.indexes;\n            // we start by search from the back so we maintain the smaller index when there is a duplicate.\n            while (arr.length > 0) {\n                for (let j = 1; j < arr.length; j++) {\n                    // if last item matches any remove the last item.\n                    if (isEqual(xs[arr[arr.length - 1]], xs[arr[arr.length - 1 - j]])) {\n                        // remove last item\n                        arr.pop();\n                        // reset position\n                        j = 0;\n                    }\n                }\n                // add the unique item\n                result.push(arr.pop());\n            }\n        }\n        // add children\n        if (node.left)\n            stack.push(node.left);\n        if (node.right)\n            stack.push(node.right);\n    }\n    // sort indexes for stability\n    result.sort();\n    // return the unique items\n    return result.map((i) => xs[i]);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n *\n * @param value\n * @returns {*}\n */\nexport function stringify(value) {\n    const type = getType(value).toLowerCase();\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"regexp\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"date\":\n            return value.toISOString();\n        case \"null\":\n        case \"undefined\":\n            return type;\n        case \"array\":\n            return \"[\" + value.map(stringify).join(\",\") + \"]\";\n        default:\n            break;\n    }\n    // default case\n    const prefix = type === \"object\" ? \"\" : `${getType(value)}`;\n    const objKeys = Object.keys(value);\n    objKeys.sort();\n    return (`${prefix}{` +\n        objKeys.map((k) => `${stringify(k)}:${stringify(value[k])}`).join(\",\") +\n        \"}\");\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nexport function hashCode(value, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (isNil(value))\n        return null;\n    return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nexport function sortBy(collection, keyFn, comparator = DEFAULT_COMPARATOR) {\n    const sorted = [];\n    const result = [];\n    if (isEmpty(collection))\n        return collection;\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        if (isNil(key)) {\n            result.push(obj);\n        }\n        else {\n            sorted.push([key, obj]);\n        }\n    }\n    // use native array sorting but enforce stableness\n    sorted.sort((a, b) => comparator(a[0], b[0]));\n    result.push(...sorted.map((o) => o[1]));\n    return result;\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {{keys: Array, groups: Array}}\n */\nexport function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    const result = {\n        keys: new Array(),\n        groups: new Array(),\n    };\n    const lookup = {};\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        const hash = hashCode(key, hashFunction);\n        let index = -1;\n        if (lookup[hash] === undefined) {\n            index = result.keys.length;\n            lookup[hash] = index;\n            result.keys.push(key);\n            result.groups.push([]);\n        }\n        index = lookup[hash];\n        result.groups[index].push(obj);\n    }\n    return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nexport function into(target, ...rest) {\n    if (target instanceof Array) {\n        return rest.reduce((acc, arr) => {\n            // push arrary in batches to handle large inputs\n            let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n            let begin = 0;\n            while (i-- > 0) {\n                Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n                begin += MAX_ARRAY_PUSH;\n            }\n            return acc;\n        }, target);\n    }\n    else {\n        // merge objects. same behaviour as Object.assign\n        return rest.filter(isObjectLike).reduce((acc, item) => {\n            Object.assign(acc, item);\n            return acc;\n        }, target);\n    }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nexport function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    return ((memo) => {\n        return (...args) => {\n            const key = hashCode(args, hashFunction);\n            if (!has(memo, key)) {\n                memo[key] = fn.apply(this, args);\n            }\n            return memo[key];\n        };\n    })({\n    /* storage */\n    });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n    return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n    if (depth < 1)\n        return arr;\n    while (depth-- && arr.length === 1)\n        arr = arr[0];\n    return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nexport function resolve(obj, selector, options) {\n    let depth = 0;\n    function resolve2(o, path) {\n        let value = o;\n        for (let i = 0; i < path.length; i++) {\n            const field = path[i];\n            const isText = /^\\d+$/.exec(field) === null;\n            // using instanceof to aid typescript compiler\n            if (isText && value instanceof Array) {\n                // On the first iteration, we check if we received a stop flag.\n                // If so, we stop to prevent iterating over a nested array value\n                // on consecutive object keys in the selector.\n                if (i === 0 && depth > 0)\n                    break;\n                depth += 1;\n                // only look at the rest of the path\n                const subpath = path.slice(i);\n                value = value.reduce((acc, item) => {\n                    const v = resolve2(item, subpath);\n                    if (v !== undefined)\n                        acc.push(v);\n                    return acc;\n                }, []);\n                break;\n            }\n            else {\n                value = getValue(value, field);\n            }\n            if (value === undefined)\n                break;\n        }\n        return value;\n    }\n    const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase())\n        ? obj\n        : resolve2(obj, selector.split(\".\"));\n    return result instanceof Array && options?.unwrapArray\n        ? unwrap(result, depth)\n        : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nexport function resolveGraph(obj, selector, options) {\n    const names = selector.split(\".\");\n    const key = names[0];\n    // get the next part of the selector\n    const next = names.slice(1).join(\".\");\n    const isIndex = /^\\d+$/.exec(key) !== null;\n    const hasNext = names.length > 1;\n    let result;\n    let value;\n    if (obj instanceof Array) {\n        if (isIndex) {\n            result = getValue(obj, Number(key));\n            if (hasNext) {\n                result = resolveGraph(result, next, options);\n            }\n            result = [result];\n        }\n        else {\n            result = [];\n            for (const item of obj) {\n                value = resolveGraph(item, selector, options);\n                if (options?.preserveMissing) {\n                    if (value === undefined) {\n                        value = MISSING;\n                    }\n                    result.push(value);\n                }\n                else if (value !== undefined) {\n                    result.push(value);\n                }\n            }\n        }\n    }\n    else {\n        value = getValue(obj, key);\n        if (hasNext) {\n            value = resolveGraph(value, next, options);\n        }\n        if (value === undefined)\n            return undefined;\n        result = options?.preserveKeys ? { ...obj } : {};\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nexport function filterMissing(obj) {\n    if (obj instanceof Array) {\n        for (let i = obj.length - 1; i >= 0; i--) {\n            if (obj[i] === MISSING) {\n                obj.splice(i, 1);\n            }\n            else {\n                filterMissing(obj[i]);\n            }\n        }\n    }\n    else if (isObject(obj)) {\n        for (const k in obj) {\n            if (has(obj, k)) {\n                filterMissing(obj[k]);\n            }\n        }\n    }\n}\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} fn Function to execute for value at the end the traversal\n * @return {*}\n */\nfunction walk(obj, selector, fn, options) {\n    if (isNil(obj))\n        return;\n    const names = selector.split(\".\");\n    const key = names[0];\n    const next = names.slice(1).join(\".\");\n    if (names.length === 1) {\n        fn(obj, key);\n    }\n    else {\n        // force the rest of the graph while traversing\n        if (options?.buildGraph && isNil(obj[key])) {\n            obj[key] = {};\n        }\n        // get the next item\n        const item = obj[key];\n        // we peek to see if next key is an array index.\n        const isNextArrayIndex = !!(names.length > 1 && names[1].match(/^\\d+$/));\n        // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n        // we walk each item in the array separately. This allows for handling traversing keys for objects\n        // nested within an array.\n        //\n        // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n        //  - individual objecs can be traversed with \"array.k\"\n        //  - a specific object can be traversed with \"array.1\"\n        if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {\n            item.forEach((e) => walk(e, next, fn, options));\n        }\n        else {\n            walk(item, next, fn, options);\n        }\n    }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nexport function setValue(obj, selector, value) {\n    walk(obj, selector, (item, key) => {\n        item[key] = value;\n    }, { buildGraph: true });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nexport function removeValue(obj, selector, options) {\n    walk(obj, selector, (item, key) => {\n        if (item instanceof Array) {\n            if (/^\\d+$/.test(key)) {\n                item.splice(parseInt(key), 1);\n            }\n            else if (options && options.descendArray) {\n                for (const elem of item) {\n                    if (isObject(elem)) {\n                        delete elem[key];\n                    }\n                }\n            }\n        }\n        else if (isObject(item)) {\n            delete item[key];\n        }\n    }, options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nexport function isOperator(name) {\n    return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nexport function normalize(expr) {\n    // normalized primitives\n    if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n        return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n    }\n    // normalize object expression. using ObjectLike handles custom types\n    if (isObjectLike(expr)) {\n        // no valid query operator found, so we do simple comparison\n        if (!Object.keys(expr).some(isOperator)) {\n            return { $eq: expr };\n        }\n        // ensure valid regex\n        if (has(expr, \"$regex\")) {\n            return {\n                $regex: new RegExp(expr[\"$regex\"], expr[\"$options\"]),\n            };\n        }\n    }\n    return expr;\n}\n","import { assert, has, into, isNil, isObject, isObjectLike, isOperator, isString, resolve, } from \"./util\";\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nexport var ProcessingMode;\n(function (ProcessingMode) {\n    /**\n     * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n     * Use this option to keep input collection immutable and to get distinct output objects.\n     *\n     * Note: This option is expensive and reduces performance.\n     */\n    ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n    /**\n     * Clones inputs prior to processing.\n     * This option will return output objects with shared graphs in their path if specific operators are used.\n     * Use this option to keep the input collection immutable.\n     *\n     */\n    ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n    /**\n     * Clones the output to return distinct objects with no shared paths.\n     * This option modifies the input collection and during processing.\n     */\n    ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n    /**\n     * Turn off cloning and modifies the input collection as needed.\n     * This option will also return output objects with shared paths in their graph when specific operators are used.\n     *\n     * This option provides the greatest speedup for the biggest tradeoff. When using the aggregation pipeline, you can use\n     * the \"$out\" operator to collect immutable intermediate results.\n     *\n     * @default\n     */\n    ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nexport class ComputeOptions {\n    options;\n    _root;\n    _local;\n    timestamp;\n    constructor(options, \n    /** Reference to the root object when processing subgraphs of the object. */\n    _root, _local, \n    /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n    timestamp = Date.now()) {\n        this.options = options;\n        this._root = _root;\n        this._local = _local;\n        this.timestamp = timestamp;\n        this.options = options;\n        this.update(_root, _local);\n    }\n    /**\n     * Initialize new ComputeOptions. Returns the same object modified when the 'options' argument is a ComputeOptions.\n     * @param options\n     * @param root\n     * @param local\n     * @returns\n     */\n    static init(options, root, local) {\n        return options instanceof ComputeOptions\n            ? options.update(\n            // value can be '0' or 'false'\n            isNil(options.root) ? root : options.root, options.local || local)\n            : new ComputeOptions(options || initOptions(), root, local);\n    }\n    /** Updates the internal mutable state. */\n    update(root, local) {\n        // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n        this._root = root;\n        this._local = local;\n        return this;\n    }\n    get root() {\n        return this._root;\n    }\n    get local() {\n        return this._local;\n    }\n    get idKey() {\n        return this.options?.idKey;\n    }\n    get collation() {\n        return this.options?.collation;\n    }\n    get processingMode() {\n        return this.options?.processingMode || ProcessingMode.CLONE_OFF;\n    }\n    get useStrictMode() {\n        return this.options?.useStrictMode;\n    }\n    get scriptEnabled() {\n        return this.options?.scriptEnabled;\n    }\n    get hashFunction() {\n        return this.options?.hashFunction;\n    }\n    get collectionResolver() {\n        return this.options?.collectionResolver;\n    }\n    get jsonSchemaValidator() {\n        return this.options?.jsonSchemaValidator;\n    }\n    get variables() {\n        return this.options?.variables;\n    }\n}\n/**\n * Creates an Option from another required keys are initialized\n * @param options Options\n */\nexport function initOptions(options) {\n    return Object.freeze({\n        idKey: \"_id\",\n        scriptEnabled: true,\n        useStrictMode: true,\n        processingMode: ProcessingMode.CLONE_OFF,\n        ...options,\n    });\n}\n/**\n * The different groups of operators\n */\nexport var OperatorType;\n(function (OperatorType) {\n    OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n    OperatorType[\"EXPRESSION\"] = \"expression\";\n    OperatorType[\"PIPELINE\"] = \"pipeline\";\n    OperatorType[\"PROJECTION\"] = \"projection\";\n    OperatorType[\"QUERY\"] = \"query\";\n    OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\n// operator definitions\nconst OPERATORS = {\n    [OperatorType.ACCUMULATOR]: {},\n    [OperatorType.EXPRESSION]: {},\n    [OperatorType.PIPELINE]: {},\n    [OperatorType.PROJECTION]: {},\n    [OperatorType.QUERY]: {},\n    [OperatorType.WINDOW]: {},\n};\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nexport function useOperators(type, operators) {\n    for (const [name, fn] of Object.entries(operators)) {\n        assert(fn instanceof Function && isOperator(name), `'${name}' is not a valid operator`);\n        const currentFn = getOperator(type, name);\n        assert(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n    }\n    // toss the operator salad :)\n    into(OPERATORS[type], operators);\n}\n/**\n * Returns the operator function or null if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nexport function getOperator(type, operator) {\n    return OPERATORS[type][operator];\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n    $$ROOT(obj, expr, options) {\n        return options.root;\n    },\n    $$CURRENT(obj, expr, options) {\n        return obj;\n    },\n    $$REMOVE(obj, expr, options) {\n        return undefined;\n    },\n    $$NOW(obj, expr, options) {\n        return new Date(options.timestamp);\n    },\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n    $$KEEP(obj, expr, options) {\n        return obj;\n    },\n    $$PRUNE(obj, expr, options) {\n        return undefined;\n    },\n    $$DESCEND(obj, expr, options) {\n        // traverse nested documents iff there is a $cond\n        if (!has(expr, \"$cond\"))\n            return obj;\n        let result;\n        for (const [key, current] of Object.entries(obj)) {\n            if (isObjectLike(current)) {\n                if (current instanceof Array) {\n                    const array = [];\n                    for (let elem of current) {\n                        if (isObject(elem)) {\n                            elem = redact(elem, expr, options.update(elem));\n                        }\n                        if (!isNil(elem)) {\n                            array.push(elem);\n                        }\n                    }\n                    result = array;\n                }\n                else {\n                    result = redact(current, expr, options.update(current));\n                }\n                if (isNil(result)) {\n                    delete obj[key]; // pruned result\n                }\n                else {\n                    obj[key] = result;\n                }\n            }\n        }\n        return obj;\n    },\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nexport function computeValue(obj, expr, operator, options) {\n    // ensure valid options exist on first invocation\n    const copts = ComputeOptions.init(options, obj);\n    if (isOperator(operator)) {\n        // if the field of the object is a valid operator\n        const callExpression = getOperator(OperatorType.EXPRESSION, operator);\n        if (callExpression)\n            return callExpression(obj, expr, copts);\n        // we also handle $group accumulator operators\n        const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator);\n        if (callAccumulator) {\n            // if object is not an array, first try to compute using the expression\n            if (!(obj instanceof Array)) {\n                obj = computeValue(obj, expr, null, copts);\n                expr = null;\n            }\n            // validate that we have an array\n            assert(obj instanceof Array, `'${operator}' target must be an array.`);\n            // for accumulators, we use the global options since the root is specific to each element within array.\n            return callAccumulator(obj, expr, \n            // reset the root object for accumulators.\n            copts.update(null, copts.local));\n        }\n        // operator was not found\n        throw new Error(`operator '${operator}' is not registered`);\n    }\n    // if expr is a string and begins with \"$$\", then we have a variable.\n    //  this can be one of; redact variable, system variable, user-defined variable.\n    //  we check and process them in that order.\n    //\n    // if expr begins only a single \"$\", then it is a path to a field on the object.\n    if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n        // we return redact variables as literals\n        if (has(redactVariables, expr)) {\n            return expr;\n        }\n        // default to root for resolving path.\n        let context = copts.root;\n        // handle selectors with explicit prefix\n        const arr = expr.split(\".\");\n        if (has(systemVariables, arr[0])) {\n            // set 'root' only the first time it is required to be used for all subsequent calls\n            // if it already available on the options, it will be used\n            context = systemVariables[arr[0]](obj, null, copts);\n            expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n        }\n        else if (arr[0].slice(0, 2) === \"$$\") {\n            // handle user-defined variables\n            context = Object.assign({}, copts.variables, // global vars\n            // current item is added before local variables because the binding may be changed.\n            { this: obj }, copts.local?.variables // local vars\n            );\n            const prefix = arr[0].slice(2);\n            assert(has(context, prefix), `Use of undefined variable: ${prefix}`);\n            expr = expr.slice(2);\n        }\n        else {\n            // 'expr' is a path to a field on the object.\n            expr = expr.slice(1);\n        }\n        if (expr === \"\")\n            return context;\n        return resolve(context, expr);\n    }\n    // check and return value if already in a resolved state\n    if (expr instanceof Array) {\n        return expr.map((item) => computeValue(obj, item, null, copts));\n    }\n    else if (isObject(expr)) {\n        const result = {};\n        for (const [key, val] of Object.entries(expr)) {\n            result[key] = computeValue(obj, val, key, copts);\n            // must run ONLY one aggregate operator per expression\n            // if so, return result of the computed value\n            if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((c) => has(OPERATORS[c], key))) {\n                // there should be only one operator\n                assert(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n                return result[key];\n            }\n        }\n        return result;\n    }\n    return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nexport function redact(obj, expr, options) {\n    const result = computeValue(obj, expr, null, options);\n    return has(redactVariables, result)\n        ? redactVariables[result](obj, expr, options)\n        : result;\n}\n","/**\n * Returns an iterator\n * @param {*} source An iterable source (Array, Function, Generator, or Iterator)\n */\nexport function Lazy(source) {\n    return source instanceof Iterator ? source : new Iterator(source);\n}\nexport function compose(...iterators) {\n    let index = 0;\n    return Lazy(() => {\n        while (index < iterators.length) {\n            const o = iterators[index].next();\n            if (!o.done)\n                return o;\n            index++;\n        }\n        return { done: true };\n    });\n}\n/**\n * Checks whether the given object is compatible with a generator i.e Object{next:Function}\n * @param {*} o An object\n */\nfunction isGenerator(o) {\n    return (!!o && typeof o === \"object\" && o?.next instanceof Function);\n}\nfunction dropItem(array, i) {\n    const rest = array.slice(i + 1);\n    array.splice(i);\n    Array.prototype.push.apply(array, rest);\n}\n// stop iteration error\nconst DONE = new Error();\n// Lazy function actions\nvar Action;\n(function (Action) {\n    Action[Action[\"MAP\"] = 0] = \"MAP\";\n    Action[Action[\"FILTER\"] = 1] = \"FILTER\";\n    Action[Action[\"TAKE\"] = 2] = \"TAKE\";\n    Action[Action[\"DROP\"] = 3] = \"DROP\";\n})(Action || (Action = {}));\nfunction createCallback(nextFn, iteratees, buffer) {\n    let done = false;\n    let index = -1;\n    let bufferIndex = 0; // index for the buffer\n    return function (storeResult) {\n        // special hack to collect all values into buffer\n        try {\n            outer: while (!done) {\n                let o = nextFn();\n                index++;\n                let i = -1;\n                const size = iteratees.length;\n                let innerDone = false;\n                while (++i < size) {\n                    const r = iteratees[i];\n                    switch (r.action) {\n                        case Action.MAP:\n                            o = r.func(o, index);\n                            break;\n                        case Action.FILTER:\n                            if (!r.func(o, index))\n                                continue outer;\n                            break;\n                        case Action.TAKE:\n                            --r.count;\n                            if (!r.count)\n                                innerDone = true;\n                            break;\n                        case Action.DROP:\n                            --r.count;\n                            if (!r.count)\n                                dropItem(iteratees, i);\n                            continue outer;\n                        default:\n                            break outer;\n                    }\n                }\n                done = innerDone;\n                if (storeResult) {\n                    buffer[bufferIndex++] = o;\n                }\n                else {\n                    return { value: o, done: false };\n                }\n            }\n        }\n        catch (e) {\n            if (e !== DONE)\n                throw e;\n        }\n        done = true;\n        return { done };\n    };\n}\n/**\n * A lazy collection iterator yields a single value at time upon request\n */\nexport class Iterator {\n    iteratees = [];\n    yieldedValues = [];\n    getNext;\n    isDone = false;\n    /**\n     * @param {*} source An iterable object or function.\n     *    Array - return one element per cycle\n     *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n     *    Function - call to return the next value\n     * @param {Function} fn An optional transformation function\n     */\n    constructor(source) {\n        let nextVal;\n        if (source instanceof Function) {\n            // make iterable\n            source = { next: source };\n        }\n        if (isGenerator(source)) {\n            const src = source;\n            nextVal = () => {\n                const o = src.next();\n                if (o.done)\n                    throw DONE;\n                return o.value;\n            };\n        }\n        else if (source instanceof Array) {\n            const data = source;\n            const size = data.length;\n            let index = 0;\n            nextVal = () => {\n                if (index < size)\n                    return data[index++];\n                throw DONE;\n            };\n        }\n        else if (!(source instanceof Function)) {\n            throw new Error(`Source is of type '${typeof source}'. Must be Array, Function, or Generator`);\n        }\n        // create next function\n        this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);\n    }\n    /**\n     * Add an iteratee to this lazy sequence\n     */\n    push(action, value) {\n        if (typeof value === \"function\") {\n            this.iteratees.push({ action, func: value });\n        }\n        else if (typeof value === \"number\") {\n            this.iteratees.push({ action, count: value });\n        }\n        return this;\n    }\n    next() {\n        return this.getNext();\n    }\n    // Iteratees methods\n    /**\n     * Transform each item in the sequence to a new value\n     * @param {Function} f\n     */\n    map(f) {\n        return this.push(Action.MAP, f);\n    }\n    /**\n     * Select only items matching the given predicate\n     * @param {Function} pred\n     */\n    filter(predicate) {\n        return this.push(Action.FILTER, predicate);\n    }\n    /**\n     * Take given numbe for values from sequence\n     * @param {Number} n A number greater than 0\n     */\n    take(n) {\n        return n > 0 ? this.push(Action.TAKE, n) : this;\n    }\n    /**\n     * Drop a number of values from the sequence\n     * @param {Number} n Number of items to drop greater than 0\n     */\n    drop(n) {\n        return n > 0 ? this.push(Action.DROP, n) : this;\n    }\n    // Transformations\n    /**\n     * Returns a new lazy object with results of the transformation\n     * The entire sequence is realized.\n     *\n     * @param {Function} fn Tranform function of type (Array) => (Any)\n     */\n    transform(fn) {\n        const self = this;\n        let iter;\n        return Lazy(() => {\n            if (!iter) {\n                iter = Lazy(fn(self.value()));\n            }\n            return iter.next();\n        });\n    }\n    // Terminal methods\n    /**\n     * Returns the fully realized values of the iterators.\n     * The return value will be an array unless `lazy.first()` was used.\n     * The realized values are cached for subsequent calls\n     */\n    value() {\n        if (!this.isDone) {\n            this.isDone = this.getNext(true).done;\n        }\n        return this.yieldedValues;\n    }\n    /**\n     * Execute the funcion for each value. Will stop when an execution returns false.\n     * @param {Function} f\n     * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n     */\n    each(f) {\n        for (;;) {\n            const o = this.next();\n            if (o.done)\n                break;\n            if (f(o.value) === false)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the reduction of sequence according the reducing function\n     *\n     * @param {*} f a reducing function\n     * @param {*} init\n     */\n    reduce(f, initialValue) {\n        let o = this.next();\n        let i = 0;\n        if (initialValue === undefined && !o.done) {\n            initialValue = o.value;\n            o = this.next();\n            i++;\n        }\n        while (!o.done) {\n            initialValue = f(initialValue, o.value);\n            o = this.next();\n        }\n        return initialValue;\n    }\n    /**\n     * Returns the number of matched items in the sequence\n     */\n    size() {\n        return this.reduce((acc, _) => ++acc, 0);\n    }\n    [Symbol.iterator]() {\n        /* eslint-disable @typescript-eslint/no-unsafe-return */\n        return this;\n    }\n}\n","import { getOperator, initOptions, OperatorType, ProcessingMode, } from \"./core\";\nimport { Lazy } from \"./lazy\";\nimport { assert, cloneDeep, intersection, isEmpty } from \"./util\";\n/**\n * Provides functionality for the mongoDB aggregation pipeline\n *\n * @param pipeline an Array of pipeline operators\n * @param options An optional Options to pass the aggregator\n * @constructor\n */\nexport class Aggregator {\n    pipeline;\n    options;\n    constructor(pipeline, options) {\n        this.pipeline = pipeline;\n        this.options = options;\n        this.options = initOptions(options);\n    }\n    /**\n     * Returns an `Lazy` iterator for processing results of pipeline\n     *\n     * @param {*} collection An array or iterator object\n     * @param {Query} query the `Query` object to use as context\n     * @returns {Iterator} an iterator object\n     */\n    stream(collection) {\n        let iterator = Lazy(collection);\n        const mode = this.options.processingMode;\n        if (mode == ProcessingMode.CLONE_ALL ||\n            mode == ProcessingMode.CLONE_INPUT) {\n            iterator.map(cloneDeep);\n        }\n        const pipelineOperators = [];\n        if (!isEmpty(this.pipeline)) {\n            // run aggregation pipeline\n            for (const operator of this.pipeline) {\n                const operatorKeys = Object.keys(operator);\n                const op = operatorKeys[0];\n                const call = getOperator(OperatorType.PIPELINE, op);\n                assert(operatorKeys.length === 1 && !!call, `invalid aggregation operator ${op}`);\n                pipelineOperators.push(op);\n                iterator = call(iterator, operator[op], this.options);\n            }\n        }\n        // operators that may share object graphs of inputs.\n        // we only need to clone the output for these since the objects will already be distinct for other operators.\n        if (mode == ProcessingMode.CLONE_OUTPUT ||\n            (mode == ProcessingMode.CLONE_ALL &&\n                !!intersection([[\"$group\", \"$unwind\"], pipelineOperators]).length)) {\n            iterator.map(cloneDeep);\n        }\n        return iterator;\n    }\n    /**\n     * Return the results of the aggregation as an array.\n     *\n     * @param {*} collection\n     * @param {*} query\n     */\n    run(collection) {\n        return this.stream(collection).value();\n    }\n}\n","import { Aggregator } from \"./aggregator\";\nimport { compose, Lazy } from \"./lazy\";\nimport { isObject } from \"./util\";\n/**\n * Cursor to iterate and perform filtering on matched objects.\n * This object must not be used directly. A cursor may be obtaine from calling `find()` on an instance of `Query`.\n *\n * @param collection The input source of the collection\n * @param predicate A predicate function to test documents\n * @param projection A projection criteria\n * @param options Options\n * @constructor\n */\nexport class Cursor {\n    source;\n    predicate;\n    projection;\n    options;\n    operators = [];\n    result = null;\n    buffer = [];\n    constructor(source, predicate, projection, options) {\n        this.source = source;\n        this.predicate = predicate;\n        this.projection = projection;\n        this.options = options;\n    }\n    /** Returns the iterator from running the query */\n    fetch() {\n        if (this.result)\n            return this.result;\n        // add projection operator\n        if (isObject(this.projection)) {\n            this.operators.push({ $project: this.projection });\n        }\n        // filter collection\n        this.result = Lazy(this.source).filter(this.predicate);\n        if (this.operators.length > 0) {\n            this.result = new Aggregator(this.operators, this.options).stream(this.result);\n        }\n        return this.result;\n    }\n    /** Returns an iterator with the buffered data included */\n    fetchAll() {\n        const buffered = Lazy([...this.buffer]);\n        this.buffer = [];\n        return compose(buffered, this.fetch());\n    }\n    /**\n     * Return remaining objects in the cursor as an array. This method exhausts the cursor\n     * @returns {Array}\n     */\n    all() {\n        return this.fetchAll().value();\n    }\n    /**\n     * Returns the number of objects return in the cursor. This method exhausts the cursor\n     * @returns {Number}\n     */\n    count() {\n        return this.all().length;\n    }\n    /**\n     * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n     * @param {Number} n the number of results to skip.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    skip(n) {\n        this.operators.push({ $skip: n });\n        return this;\n    }\n    /**\n     * Constrains the size of a cursor's result set.\n     * @param {Number} n the number of results to limit to.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    limit(n) {\n        this.operators.push({ $limit: n });\n        return this;\n    }\n    /**\n     * Returns results ordered according to a sort specification.\n     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    sort(modifier) {\n        this.operators.push({ $sort: modifier });\n        return this;\n    }\n    /**\n     * Specifies the collation for the cursor returned by the `mingo.Query.find`\n     * @param {*} spec\n     */\n    collation(spec) {\n        this.options = { ...this.options, collation: spec };\n        return this;\n    }\n    /**\n     * Returns the next document in a cursor.\n     * @returns {Object | Boolean}\n     */\n    next() {\n        // yield value obtains in hasNext()\n        if (this.buffer.length > 0) {\n            return this.buffer.pop();\n        }\n        const o = this.fetch().next();\n        if (o.done)\n            return;\n        return o.value;\n    }\n    /**\n     * Returns true if the cursor has documents and can be iterated.\n     * @returns {boolean}\n     */\n    hasNext() {\n        // there is a value in the buffer\n        if (this.buffer.length > 0)\n            return true;\n        const o = this.fetch().next();\n        if (o.done)\n            return false;\n        this.buffer.push(o.value);\n        return true;\n    }\n    /**\n     * Applies a function to each document in a cursor and collects the return values in an array.\n     * @param callback\n     * @returns {Array}\n     */\n    map(callback) {\n        return this.all().map(callback);\n    }\n    /**\n     * Applies a JavaScript function for every document in a cursor.\n     * @param callback\n     */\n    forEach(callback) {\n        this.all().forEach(callback);\n    }\n    [Symbol.iterator]() {\n        return this.fetchAll();\n    }\n}\n","import { getOperator, initOptions, OperatorType } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { assert, inArray, isObject, isOperator, normalize } from \"./util\";\n/**\n * An object used to filter input documents\n *\n * @param {Object} criteria The criteria for constructing predicates\n * @param {Options} options Options for use by operators\n * @constructor\n */\nexport class Query {\n    criteria;\n    options;\n    compiled;\n    constructor(criteria, options) {\n        this.criteria = criteria;\n        this.options = options;\n        this.options = initOptions(options);\n        this.compiled = [];\n        this.compile();\n    }\n    compile() {\n        assert(isObject(this.criteria), \"query criteria must be an object\");\n        let whereOperator;\n        for (const [field, expr] of Object.entries(this.criteria)) {\n            if (\"$where\" === field) {\n                whereOperator = { field: field, expr: expr };\n            }\n            else if (inArray([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"], field)) {\n                this.processOperator(field, field, expr);\n            }\n            else {\n                // normalize expression\n                assert(!isOperator(field), `unknown top level operator: ${field}`);\n                for (const [operator, val] of Object.entries(normalize(expr))) {\n                    this.processOperator(field, operator, val);\n                }\n            }\n            if (isObject(whereOperator)) {\n                this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);\n            }\n        }\n    }\n    processOperator(field, operator, value) {\n        const call = getOperator(OperatorType.QUERY, operator);\n        assert(!!call, `unknown operator ${operator}`);\n        const fn = call(field, value, this.options);\n        this.compiled.push(fn);\n    }\n    /**\n     * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n     *\n     * @param obj The object to test\n     * @returns {boolean} True or false\n     */\n    test(obj) {\n        for (let i = 0, len = this.compiled.length; i < len; i++) {\n            if (!this.compiled[i](obj)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a cursor to select matching documents from the input source.\n     *\n     * @param source A source providing a sequence of documents\n     * @param projection An optional projection criteria\n     * @returns {Cursor} A Cursor for iterating over the results\n     */\n    find(collection, projection) {\n        return new Cursor(collection, (x) => this.test(x), projection || {}, this.options);\n    }\n    /**\n     * Remove matched documents from the collection returning the remainder\n     *\n     * @param collection An array of documents\n     * @returns {Array} A new array with matching elements removed\n     */\n    remove(collection) {\n        return collection.reduce((acc, obj) => {\n            if (!this.test(obj))\n                acc.push(obj);\n            return acc;\n        }, []);\n    }\n}\n","import { ComputeOptions, computeValue, getOperator, OperatorType, } from \"../../core\";\nimport { assert, ensureArray, filterMissing, has, inArray, into, isEmpty, isNil, isNumber, isObject, isOperator, isString, merge, notInArray, removeValue, resolveGraph, setValue, } from \"../../util\";\n/**\n * Reshapes a document stream.\n * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n *\n * @param collection\n * @param expr\n * @param opt\n * @returns {Array}\n */\nexport function $project(collection, expr, options) {\n    if (isEmpty(expr))\n        return collection;\n    // result collection\n    let expressionKeys = Object.keys(expr);\n    let idOnlyExcluded = false;\n    // validate inclusion and exclusion\n    validateExpression(expr, options);\n    const ID_KEY = options.idKey;\n    if (inArray(expressionKeys, ID_KEY)) {\n        const id = expr[ID_KEY];\n        if (id === 0 || id === false) {\n            expressionKeys = expressionKeys.filter(notInArray.bind(null, [ID_KEY]));\n            idOnlyExcluded = expressionKeys.length == 0;\n        }\n    }\n    else {\n        // if not specified the add the ID field\n        expressionKeys.push(ID_KEY);\n    }\n    const copts = ComputeOptions.init(options);\n    return collection.map((obj) => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));\n}\n/**\n * Process the expression value for $project operators\n *\n * @param {Object} obj The object to use as options\n * @param {Object} expr The experssion object of $project operator\n * @param {Array} expressionKeys The key in the 'expr' object\n * @param {Boolean} idOnlyExcluded Boolean value indicating whether only the ID key is excluded\n */\nfunction processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {\n    let newObj = {};\n    let foundSlice = false;\n    let foundExclusion = false;\n    const dropKeys = [];\n    if (idOnlyExcluded) {\n        dropKeys.push(options.idKey);\n    }\n    for (const key of expressionKeys) {\n        // final computed value of the key\n        let value = undefined;\n        // expression to associate with key\n        const subExpr = expr[key];\n        if (key !== options.idKey && inArray([0, false], subExpr)) {\n            foundExclusion = true;\n        }\n        if (key === options.idKey && isEmpty(subExpr)) {\n            // tiny optimization here to skip over id\n            value = obj[key];\n        }\n        else if (isString(subExpr)) {\n            value = computeValue(obj, subExpr, key, options);\n        }\n        else if (inArray([1, true], subExpr)) {\n            // For direct projections, we use the resolved object value\n        }\n        else if (subExpr instanceof Array) {\n            value = subExpr.map((v) => {\n                const r = computeValue(obj, v, null, options);\n                if (isNil(r))\n                    return null;\n                return r;\n            });\n        }\n        else if (isObject(subExpr)) {\n            const subExprObj = subExpr;\n            const subExprKeys = Object.keys(subExpr);\n            const operator = subExprKeys.length == 1 ? subExprKeys[0] : null;\n            // first try a projection operator\n            const call = getOperator(OperatorType.PROJECTION, operator);\n            if (call) {\n                // apply the projection operator on the operator expression for the key\n                if (operator === \"$slice\") {\n                    // $slice is handled differently for aggregation and projection operations\n                    if (ensureArray(subExprObj[operator]).every(isNumber)) {\n                        // $slice for projection operation\n                        value = call(obj, subExprObj[operator], key);\n                        foundSlice = true;\n                    }\n                    else {\n                        // $slice for aggregation operation\n                        value = computeValue(obj, subExprObj, key, options);\n                    }\n                }\n                else {\n                    value = call(obj, subExprObj[operator], key, options);\n                }\n            }\n            else if (isOperator(operator)) {\n                // compute if operator key\n                value = computeValue(obj, subExprObj[operator], operator, options);\n            }\n            else if (has(obj, key)) {\n                // compute the value for the sub expression for the key\n                validateExpression(subExprObj, options);\n                let target = obj[key];\n                if (target instanceof Array) {\n                    value = target.map((o) => processObject(o, subExprObj, options, subExprKeys, false));\n                }\n                else {\n                    target = isObject(target) ? target : obj;\n                    value = processObject(target, subExprObj, options, subExprKeys, false);\n                }\n            }\n            else {\n                // compute the value for the sub expression for the key\n                value = computeValue(obj, subExpr, null, options);\n            }\n        }\n        else {\n            dropKeys.push(key);\n            continue;\n        }\n        // get value with object graph\n        const objPathGraph = resolveGraph(obj, key, {\n            preserveMissing: true,\n        });\n        // add the value at the path\n        if (objPathGraph !== undefined) {\n            merge(newObj, objPathGraph, {\n                flatten: true,\n            });\n        }\n        // if computed add/or remove accordingly\n        if (notInArray([0, 1, false, true], subExpr)) {\n            if (value === undefined) {\n                removeValue(newObj, key, { descendArray: true });\n            }\n            else {\n                setValue(newObj, key, value);\n            }\n        }\n    }\n    // filter out all missing values preserved to support correct merging\n    filterMissing(newObj);\n    // For the following cases we include all keys on the object that were not explicitly excluded.\n    //\n    // 1. projection included $slice operator\n    // 2. some fields were explicitly excluded\n    // 3. only the id field was excluded\n    if (foundSlice || foundExclusion || idOnlyExcluded) {\n        newObj = into({}, obj, newObj);\n        if (dropKeys.length > 0) {\n            for (const k of dropKeys) {\n                removeValue(newObj, k, { descendArray: true });\n            }\n        }\n    }\n    return newObj;\n}\n/**\n * Validate inclusion and exclusion values in expression\n *\n * @param {Object} expr The expression given for the projection\n */\nfunction validateExpression(expr, options) {\n    const check = [false, false];\n    for (const [k, v] of Object.entries(expr)) {\n        if (k === options.idKey)\n            return;\n        if (v === 0 || v === false) {\n            check[0] = true;\n        }\n        else if (v === 1 || v === true) {\n            check[1] = true;\n        }\n        assert(!(check[0] && check[1]), \"Projection cannot have a mix of inclusion and exclusion.\");\n    }\n}\n","import { DEFAULT_COMPARATOR, groupBy, into, isEmpty, isObject, isString, resolve, sortBy, } from \"../../util\";\n/**\n * Takes all input documents and returns them in a stream of sorted documents.\n *\n * @param collection\n * @param sortKeys\n * @param  {Object} options\n * @returns {*}\n */\nexport function $sort(collection, sortKeys, options) {\n    if (isEmpty(sortKeys) || !isObject(sortKeys))\n        return collection;\n    let cmp = DEFAULT_COMPARATOR;\n    // check for collation spec on the options\n    const collationSpec = options.collation;\n    // use collation comparator if provided\n    if (isObject(collationSpec) && isString(collationSpec.locale)) {\n        cmp = collationComparator(collationSpec);\n    }\n    return collection.transform((coll) => {\n        const modifiers = Object.keys(sortKeys);\n        for (const key of modifiers.reverse()) {\n            const grouped = groupBy(coll, (obj) => resolve(obj, key), options?.hashFunction);\n            const sortedIndex = {};\n            const indexKeys = sortBy(grouped.keys, (k, i) => {\n                sortedIndex[k] = i;\n                return k;\n            }, cmp);\n            if (sortKeys[key] === -1)\n                indexKeys.reverse();\n            coll = [];\n            for (const k of indexKeys) {\n                into(coll, grouped.groups[sortedIndex[k]]);\n            }\n        }\n        return coll;\n    });\n}\n// MongoDB collation strength to JS localeCompare sensitivity mapping.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\nconst COLLATION_STRENGTH = {\n    // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.\n    1: \"base\",\n    //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n    // Examples: a  b, a  , a = A.\n    2: \"accent\",\n    // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n    // Other differences may also be taken into consideration. Examples: a  b, a  , a  A\n    3: \"variant\",\n    // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.\n};\n/**\n * Creates a comparator function for the given collation spec. See https://docs.mongodb.com/manual/reference/collation/\n *\n * @param spec {Object} The MongoDB collation spec.\n * {\n *   locale: string,\n *   caseLevel: boolean,\n *   caseFirst: string,\n *   strength: int,\n *   numericOrdering: boolean,\n *   alternate: string,\n *   maxVariable: string, // unsupported\n *   backwards: boolean // unsupported\n * }\n */\nfunction collationComparator(spec) {\n    const localeOpt = {\n        sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n        caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n        numeric: spec.numericOrdering || false,\n        ignorePunctuation: spec.alternate === \"shifted\",\n    };\n    // when caseLevel is true for strength  1:base and 2:accent, bump sensitivity to the nearest that supports case comparison\n    if ((spec.caseLevel || false) === true) {\n        if (localeOpt.sensitivity === \"base\")\n            localeOpt.sensitivity = \"case\";\n        if (localeOpt.sensitivity === \"accent\")\n            localeOpt.sensitivity = \"variant\";\n    }\n    const collator = new Intl.Collator(spec.locale, localeOpt);\n    return (a, b) => {\n        // non strings\n        if (!isString(a) || !isString(b))\n            return DEFAULT_COMPARATOR(a, b);\n        // only for strings\n        const i = collator.compare(a, b);\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            return 1;\n        return 0;\n    };\n}\n","/**\n * Predicates used for Query and Expression operators.\n */\nimport { computeValue, } from \"../core\";\nimport { Query } from \"../query\";\nimport { ensureArray, flatten, getType, inArray, intersection, isArray, isBoolean, isDate, isEmpty, isEqual, isNil, isNumber, isObject, isOperator, isRegExp, isString, MAX_INT, MAX_LONG, MIN_INT, MIN_LONG, resolve, } from \"../util\";\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createQueryOperator(predicate) {\n    return (selector, value, options) => {\n        const opts = { unwrapArray: true };\n        const depth = Math.max(1, selector.split(\".\").length - 1);\n        return (obj) => {\n            // value of field must be fully resolved.\n            const lhs = resolve(obj, selector, opts);\n            return predicate(lhs, value, { ...options, depth });\n        };\n    };\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createExpressionOperator(predicate) {\n    return (obj, expr, options) => {\n        const args = computeValue(obj, expr, null, options);\n        return predicate(...args);\n    };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nexport function $eq(a, b, options) {\n    // start with simple equality check\n    if (isEqual(a, b))\n        return true;\n    // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n    if (isNil(a) && isNil(b))\n        return true;\n    // check\n    if (a instanceof Array) {\n        const eq = isEqual.bind(null, b);\n        return a.some(eq) || flatten(a, options?.depth).some(eq);\n    }\n    return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $ne(a, b, options) {\n    return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nexport function $in(a, b, options) {\n    // queries for null should be able to find undefined fields\n    if (isNil(a))\n        return b.some((v) => v === null);\n    return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $nin(a, b, options) {\n    return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lt(a, b, options) {\n    return compare(a, b, (x, y) => x < y);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lte(a, b, options) {\n    return compare(a, b, (x, y) => x <= y);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gt(a, b, options) {\n    return compare(a, b, (x, y) => x > y);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gte(a, b, options) {\n    return compare(a, b, (x, y) => x >= y);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $mod(a, b, options) {\n    return ensureArray(a).some((x) => b.length === 2 && x % b[0] === b[1]);\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $regex(a, b, options) {\n    const lhs = ensureArray(a);\n    const match = (x) => isString(x) && !!b.exec(x);\n    return lhs.some(match) || flatten(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $exists(a, b, options) {\n    return (((b === false || b === 0) && a === undefined) ||\n        ((b === true || b === 1) && a !== undefined));\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nexport function $all(values, queries, options) {\n    if (!isArray(values) ||\n        !isArray(queries) ||\n        !values.length ||\n        !queries.length) {\n        return false;\n    }\n    let matched = true;\n    for (const query of queries) {\n        // no need to check all the queries.\n        if (!matched)\n            break;\n        if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n            matched = $elemMatch(values, query[\"$elemMatch\"], options);\n        }\n        else if (query instanceof RegExp) {\n            matched = values.some((s) => typeof s === \"string\" && query.test(s));\n        }\n        else {\n            matched = values.some((v) => isEqual(query, v));\n        }\n    }\n    return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $size(a, b, options) {\n    return a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n    return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nexport function $elemMatch(a, b, options) {\n    // should return false for non-matching input\n    if (isArray(a) && !isEmpty(a)) {\n        let format = (x) => x;\n        let criteria = b;\n        // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n        // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n        // like $and/$or/$nor; as otherwise, this faking will break our query.\n        if (Object.keys(b).every(isNonBooleanOperator)) {\n            criteria = { temp: b };\n            format = (x) => ({ temp: x });\n        }\n        const query = new Query(criteria, options);\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (query.test(format(a[i]))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// helper functions\nconst isNull = (a) => a === null;\nconst isInt = (a) => isNumber(a) &&\n    a >= MIN_INT &&\n    a <= MAX_INT &&\n    a.toString().indexOf(\".\") === -1;\nconst isLong = (a) => isNumber(a) &&\n    a >= MIN_LONG &&\n    a <= MAX_LONG &&\n    a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n    array: isArray,\n    bool: isBoolean,\n    boolean: isBoolean,\n    date: isDate,\n    decimal: isNumber,\n    double: isNumber,\n    int: isInt,\n    long: isLong,\n    number: isNumber,\n    null: isNull,\n    object: isObject,\n    regex: isRegExp,\n    regexp: isRegExp,\n    string: isString,\n    // added for completeness\n    undefined: isNil,\n    function: (_) => {\n        throw new Error(\"unsupported type key `function`.\");\n    },\n    // Mongo identifiers\n    1: isNumber,\n    2: isString,\n    3: isObject,\n    4: isArray,\n    6: isNil,\n    8: isBoolean,\n    9: isDate,\n    10: isNull,\n    11: isRegExp,\n    16: isInt,\n    18: isLong,\n    19: isNumber, //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n    const f = compareFuncs[b];\n    return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $type(a, b, options) {\n    return Array.isArray(b)\n        ? b.findIndex((t) => compareType(a, t, options)) >= 0\n        : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n    return ensureArray(a).some((x) => getType(x) === getType(b) && f(x, b));\n}\n","// Query Array Operators: https://docs.mongodb.com/manual/reference/operator/query-array/\nimport { $all as __all, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches arrays that contain all elements specified in the query.\n */\nexport const $all = createQueryOperator(__all);\n","// Query Array Operators: https://docs.mongodb.com/manual/reference/operator/query-array/\nimport { $elemMatch as __elemMatch, createQueryOperator, } from \"../../_predicates\";\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch conditions.\n */\nexport const $elemMatch = createQueryOperator(__elemMatch);\n","// Query Array Operators: https://docs.mongodb.com/manual/reference/operator/query-array/\nimport { $size as __size, createQueryOperator } from \"../../_predicates\";\n/**\n * Selects documents if the array field is a specified size.\n */\nexport const $size = createQueryOperator(__size);\n","import { createQueryOperator } from \"../../_predicates\";\nexport const createBitwiseOperator = (predicate) => {\n    return createQueryOperator((value, mask, options) => {\n        let b = 0;\n        if (mask instanceof Array) {\n            for (const n of mask)\n                b = b | (1 << n);\n        }\n        else {\n            b = mask;\n        }\n        return predicate(value & b, b);\n    });\n};\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $eq as __eq, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches values that are equal to a specified value.\n */\nexport const $eq = createQueryOperator(__eq);\n","// Query Bitwise Operators: https://docs.mongodb.com/manual/reference/operator/query-bitwise/\nimport { createBitwiseOperator } from \"./_internal\";\n/**\n * Matches numeric or binary values in which a set of bit positions all have a value of 0.\n */\nexport const $bitsAllClear = createBitwiseOperator((result, _) => result == 0);\n","// Query Bitwise Operators: https://docs.mongodb.com/manual/reference/operator/query-bitwise/\nimport { createBitwiseOperator } from \"./_internal\";\n/**\n * Matches numeric or binary values in which a set of bit positions all have a value of 1.\n */\nexport const $bitsAllSet = createBitwiseOperator((result, mask) => result == mask);\n","// Query Bitwise Operators: https://docs.mongodb.com/manual/reference/operator/query-bitwise/\nimport { createBitwiseOperator } from \"./_internal\";\n/**\n * Matches numeric or binary values in which any bit from a set of bit positions has a value of 0.\n */\nexport const $bitsAnyClear = createBitwiseOperator((result, mask) => result < mask);\n","// Query Bitwise Operators: https://docs.mongodb.com/manual/reference/operator/query-bitwise/\nimport { createBitwiseOperator } from \"./_internal\";\n/**\n * Matches numeric or binary values in which any bit from a set of bit positions has a value of 1.\n */\nexport const $bitsAnySet = createBitwiseOperator((result, _) => result > 0);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $gt as __gt, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches values that are greater than a specified value.\n */\nexport const $gt = createQueryOperator(__gt);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $gte as __gte, createQueryOperator } from \"../../_predicates\";\n/**\n * \tMatches values that are greater than or equal to a specified value.\n */\nexport const $gte = createQueryOperator(__gte);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $in as __in, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches any of the values that exist in an array specified in the query.\n */\nexport const $in = createQueryOperator(__in);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $lt as __lt, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches values that are less than the value specified in the query.\n */\nexport const $lt = createQueryOperator(__lt);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $lte as __lte, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches values that are less than or equal to the value specified in the query.\n */\nexport const $lte = createQueryOperator(__lte);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $ne as __ne, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches all values that are not equal to the value specified in the query.\n */\nexport const $ne = createQueryOperator(__ne);\n","// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\nimport { $nin as __nin, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches values that do not exist in an array specified to the query.\n */\nexport const $nin = createQueryOperator(__nin);\n","// Query Element Operators: https://docs.mongodb.com/manual/reference/operator/query-element/\nimport { $exists as __exists, createQueryOperator } from \"../../_predicates\";\n/**\n * Matches documents that have the specified field.\n */\nexport const $exists = createQueryOperator(__exists);\n","// Query Element Operators: https://docs.mongodb.com/manual/reference/operator/query-element/\nimport { $type as __type, createQueryOperator } from \"../../_predicates\";\n/**\n * Selects documents if a field is of the specified type.\n */\nexport const $type = createQueryOperator(__type);\n","// Query Evaluation Operators: https://docs.mongodb.com/manual/reference/operator/query-evaluation/\nimport { $mod as __mod, createQueryOperator } from \"../../_predicates\";\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n */\nexport const $mod = createQueryOperator(__mod);\n","// Query Evaluation Operators: https://docs.mongodb.com/manual/reference/operator/query-evaluation/\nimport { $regex as __regex, createQueryOperator } from \"../../_predicates\";\n/**\n * Selects documents where values match a specified regular expression.\n */\nexport const $regex = createQueryOperator(__regex);\n","// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\nimport { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\n/**\n * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nexport function $and(selector, value, options) {\n    assert(isArray(value), \"Invalid expression: $and expects value to be an Array\");\n    const queries = new Array();\n    value.forEach((expr) => queries.push(new Query(expr, options)));\n    return (obj) => {\n        for (let i = 0; i < queries.length; i++) {\n            if (!queries[i].test(obj)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n","// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\nimport { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\n/**\n * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nexport function $or(selector, value, options) {\n    assert(isArray(value), \"Invalid expression. $or expects value to be an Array\");\n    const queries = value.map((expr) => new Query(expr, options));\n    return (obj) => {\n        for (let i = 0; i < queries.length; i++) {\n            if (queries[i].test(obj)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n","// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\nimport { assert, isArray } from \"../../../util\";\nimport { $or } from \"./or\";\n/**\n * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nexport function $nor(selector, value, options) {\n    assert(isArray(value), \"Invalid expression. $nor expects value to be an Array\");\n    const f = $or(\"$or\", value, options);\n    return (obj) => !f(obj);\n}\n","// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\nimport { Query } from \"../../../query\";\nimport { normalize } from \"../../../util\";\n/**\n * Inverts the effect of a query expression and returns documents that do not match the query expression.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nexport function $not(selector, value, options) {\n    const criteria = {};\n    criteria[selector] = normalize(value);\n    const query = new Query(criteria, options);\n    return (obj) => !query.test(obj);\n}\n","import { useOperators, OperatorType } from 'mingo/core';\nimport { Query } from 'mingo/query';\nimport type { MangoQuerySelector } from './types';\nimport { $sort, $project } from 'mingo/operators/pipeline';\nimport {\n    $and,\n    $eq,\n    $elemMatch,\n    $exists,\n    $gt,\n    $gte,\n    $in,\n    $lt,\n    $lte,\n    $ne,\n    $nin,\n    $mod,\n    $nor,\n    $not,\n    $or,\n    $regex,\n    $size,\n    $type,\n} from 'mingo/operators/query';\n\nlet mingoInitDone = false;\n\n\n/**\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nexport function getMingoQuery<RxDocType>(\n    selector?: MangoQuerySelector<RxDocType>\n) {\n    if (!mingoInitDone) {\n\n        useOperators(OperatorType.PIPELINE, {\n            $sort,\n            $project\n        } as any);\n        useOperators(OperatorType.QUERY, {\n            $and,\n            $eq,\n            $elemMatch,\n            $exists,\n            $gt,\n            $gte,\n            $in,\n            $lt,\n            $lte,\n            $ne,\n            $nin,\n            $mod,\n            $nor,\n            $not,\n            $or,\n            $regex,\n            $size,\n            $type,\n        } as any);\n        mingoInitDone = true;\n    }\n    return new Query(selector as any);\n}\n","import type {\n    DeterministicSortComparator,\n    QueryMatcher\n} from 'event-reduce-js';\nimport type {\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageStatics,\n    FilledMangoQuery,\n    MangoQuery,\n    DefaultPreparedQuery\n} from './types';\nimport { newRxError } from './rx-error';\nimport { getQueryPlan } from './query-planner';\nimport { DEFAULT_CHECKPOINT_SCHEMA } from './rx-schema-helper';\nimport { getMingoQuery } from './rx-query-mingo';\n\n\n/**\n * Most RxStorage implementations use these static functions.\n * But you can use anything that implements the interface,\n * for example if your underlying database already has a query engine.\n */\nexport const RxStorageDefaultStatics: RxStorageStatics = {\n    prepareQuery<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        mutateableQuery: FilledMangoQuery<RxDocType>\n    ): DefaultPreparedQuery<RxDocType> {\n\n        if (!mutateableQuery.sort) {\n            throw newRxError('SNH', {\n                query: mutateableQuery\n            });\n        }\n\n        /**\n         * Store the query plan together with the\n         * prepared query to save performance.\n         */\n        const queryPlan = getQueryPlan(\n            schema,\n            mutateableQuery\n        );\n\n        return {\n            query: mutateableQuery,\n            queryPlan\n        };\n    },\n\n    getSortComparator<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        preparedQuery: DefaultPreparedQuery<RxDocType>\n    ): DeterministicSortComparator<RxDocType> {\n        return getDefaultSortComparator(schema, preparedQuery.query);\n    },\n\n    getQueryMatcher<RxDocType>(\n        _schema: RxJsonSchema<RxDocType>,\n        preparedQuery: DefaultPreparedQuery<RxDocType>\n    ): QueryMatcher<RxDocumentData<RxDocType>> {\n        const query = preparedQuery.query;\n        const mingoQuery = getMingoQuery(query.selector);\n        const fun: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType>) => {\n            if (doc._deleted) {\n                return false;\n            }\n            const cursor = mingoQuery.find([doc]);\n            const next = cursor.next();\n            if (next) {\n                return true;\n            } else {\n                return false;\n            }\n        };\n        return fun;\n    },\n\n    checkpointSchema: DEFAULT_CHECKPOINT_SCHEMA\n\n};\n\nfunction sortDirectionToMingo(direction: 'asc' | 'desc'): 1 | -1 {\n    if (direction === 'asc') {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\n/**\n * This function is at dexie-helper\n * because we need it in multiple places.\n */\nexport function getDefaultSortComparator<RxDocType>(\n    _schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: MangoQuery<RxDocType>\n): DeterministicSortComparator<RxDocType> {\n    const mingoSortObject: {\n        [fieldName: string]: 1 | -1;\n    } = {};\n\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n\n    query.sort.forEach(sortBlock => {\n        const key = Object.keys(sortBlock)[0];\n        const direction = Object.values(sortBlock)[0];\n        mingoSortObject[key] = sortDirectionToMingo(direction);\n    });\n\n    const fun: DeterministicSortComparator<RxDocType> = (a: RxDocType, b: RxDocType) => {\n        const sorted = getMingoQuery({}).find([a, b], {}).sort(mingoSortObject);\n        const first = sorted.next();\n        if (first === a) {\n            return -1;\n        } else {\n            return 1;\n        }\n    };\n\n    return fun;\n}\n","import { QueryMatcher } from 'event-reduce-js';\nimport {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport {\n    categorizeBulkWriteRows,\n    getNewestOfDocumentStates\n} from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types';\nimport {\n    getFromMapOrThrow,\n    lastOfArray,\n    now,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM\n} from '../../plugins/utils';\nimport {\n    boundGE,\n    boundGT,\n    boundLE\n} from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes';\nimport type {\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\nimport { RxStorageDefaultStatics } from '../../rx-storage-statics';\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            this.primaryPath as any,\n            this.internals.documents,\n            documentWrites,\n            context\n        );\n        ret.error = categorized.errors;\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        categorized.bulkInsertDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        categorized.bulkUpdateDocs.forEach(writeRow => {\n            const docId = writeRow.document[this.primaryPath];\n            putWriteRowToState(\n                docId as any,\n                this.internals,\n                stateByIndex,\n                writeRow,\n                this.internals.documents.get(docId as any)\n            );\n            ret.success[docId as any] = writeRow.document;\n        });\n\n        /**\n         * Handle attachments\n         */\n        const attachmentsMap = this.internals.attachments;\n        categorized.attachmentsAdd.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsUpdate.forEach(attachment => {\n            attachmentsMap.set(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                attachment.attachmentData\n            );\n        });\n        categorized.attachmentsRemove.forEach(attachment => {\n            attachmentsMap.delete(\n                attachmentMapKey(attachment.documentId, attachment.attachmentId)\n            );\n        });\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            categorized.eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            this.internals.changes$.next(categorized.eventBulk);\n        }\n        return Promise.resolve(ret);\n    }\n\n    findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        const ret: RxDocumentDataById<RxDocType> = {};\n        docIds.forEach(docId => {\n            const docInDb = this.internals.documents.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        });\n        return Promise.resolve(ret);\n    }\n\n    query(preparedQuery: MemoryPreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n        if (!queryPlan.selectorSatisfiedByIndex) {\n            queryMatcher = RxStorageDefaultStatics.getQueryMatcher(\n                this.schema,\n                preparedQuery\n            );\n        }\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortFieldsSameAsIndexFields;\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound: any[] = queryPlan.startKeys;\n        lowerBound = [false].concat(lowerBound);\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound,\n            queryPlan.inclusiveStart\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound,\n            queryPlan.inclusiveEnd\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGE(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n        const indexOfUpper = boundLE(\n            docsWithIndex,\n            {\n                indexString: upperBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n\n\n            if (\n                !currentDoc ||\n                indexOfLower > indexOfUpper\n            ) {\n                break;\n            }\n\n            if (!queryMatcher || queryMatcher(currentDoc.doc)) {\n                rows.push(currentDoc.doc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            const sortComparator = RxStorageDefaultStatics.getSortComparator(this.schema, preparedQuery);\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n        return Promise.resolve({\n            documents: rows\n        });\n    }\n\n    async count(\n        preparedQuery: MemoryPreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const result = await this.query(preparedQuery);\n        return {\n            count: result.documents.length,\n            mode: 'fast'\n        };\n    }\n\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ],\n            false\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        const lastDoc = lastOfArray(rows);\n        return Promise.resolve({\n            documents: rows,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        });\n    }\n\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ],\n            false\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    getAttachmentData(documentId: string, attachmentId: string): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        return Promise.resolve(data.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.internals.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(this.databaseName, this.collectionName)\n        );\n        await this.close();\n    }\n\n    close(): Promise<void> {\n        if (this.closed) {\n            return Promise.reject(new Error('already closed'));\n        }\n        this.closed = true;\n\n        this.internals.refCount = this.internals.refCount - 1;\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(params.databaseName, params.collectionName);\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject(),\n            changes$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n","import type {\n    RxDocumentData,\n    RxDocumentMeta,\n    StringKeys\n} from '../../types';\n/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nexport const RX_META_LWT_MINIMUM = 1;\n\nexport function getDefaultRxDocumentMeta(): RxDocumentMeta {\n    return {\n        /**\n         * Set this to 1 to not waste performance\n         * while calling new Date()..\n         * The storage wrappers will anyway update\n         * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n         */\n        lwt: RX_META_LWT_MINIMUM\n    };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nexport function getDefaultRevision(): string {\n    /**\n     * Use a non-valid revision format,\n     * to ensure that the RxStorage will throw\n     * when the revision is not replaced downstream.\n     */\n    return '';\n}\n\n\nexport function stripMetaDataFromDocument<RxDocType>(docData: RxDocumentData<RxDocType>): RxDocType {\n    return Object.assign({}, docData, {\n        _meta: undefined,\n        _deleted: undefined,\n        _rev: undefined\n    });\n}\n\n\n/**\n * Faster way to check the equalness of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nexport function areRxDocumentArraysEqual<RxDocType>(\n    primaryPath: StringKeys<RxDocumentData<RxDocType>>,\n    ar1: RxDocumentData<RxDocType>[],\n    ar2: RxDocumentData<RxDocType>[]\n): boolean {\n    if (ar1.length !== ar2.length) {\n        return false;\n    }\n    let i = 0;\n    const len = ar1.length;\n    while (i < len) {\n        const row1 = ar1[i];\n        const row2 = ar2[i];\n        i++;\n\n        if (\n            row1._rev !== row2._rev ||\n            row1[primaryPath] !== row2[primaryPath]\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\nexport function getSortDocumentsByLastWriteTimeComparator<RxDocType>(primaryPath: string) {\n    return (a: RxDocumentData<RxDocType>, b: RxDocumentData<RxDocType>) => {\n        if (a._meta.lwt === b._meta.lwt) {\n            if ((b as any)[primaryPath] < (a as any)[primaryPath]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        } else {\n            return a._meta.lwt - b._meta.lwt;\n        }\n    };\n}\nexport function sortDocumentsByLastWriteTime<RxDocType>(\n    primaryPath: string,\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType>[] {\n    return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}\n","import { ensureRxStorageInstanceParamsAreCorrect } from '../../rx-storage-helper';\nimport type { RxStorageInstanceCreationParams } from '../../types';\nimport { flatClone } from '../../plugins/utils';\nimport type {\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\nimport {\n    createMemoryStorageInstance,\n    RxStorageInstanceMemory\n} from './rx-storage-instance-memory';\nimport { RxStorageDefaultStatics } from '../../rx-storage-statics';\n\n/**\n * Keep the state even when the storage instance is closed.\n * This makes it easier to use the memory storage\n * to test filesystem-like and multiInstance behaviors.\n */\nconst COLLECTION_STATES = new Map();\n\nexport function getRxStorageMemory(\n    settings: RxStorageMemorySettings = {}\n): RxStorageMemory {\n\n    const storage: RxStorageMemory = {\n        name: 'memory',\n        statics: RxStorageDefaultStatics,\n        collectionStates: COLLECTION_STATES,\n        createStorageInstance<RxDocType>(\n            params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>\n        ): Promise<RxStorageInstanceMemory<RxDocType>> {\n            ensureRxStorageInstanceParamsAreCorrect(params);\n\n            // TODO we should not need to append the schema version here.\n            params = flatClone(params);\n            params.collectionName = params.collectionName + '-' + params.schema.version;\n\n            const useSettings = Object.assign(\n                {},\n                settings,\n                params.options\n            );\n\n\n            return createMemoryStorageInstance(this, params, useSettings);\n        }\n    };\n\n    return storage;\n}\n\n\nexport * from './memory-helper';\nexport * from './binary-search-bounds';\nexport * from './memory-types';\nexport * from './memory-indexes';\nexport * from './rx-storage-instance-memory';\n","import WorkerContext from \"./dist/worker/index.js\"\n\nexport const expose = WorkerContext.expose\nexport const registerSerializer = WorkerContext.registerSerializer\nexport const Transfer = WorkerContext.Transfer\n","import { getRxStorageMemory } from '../../storage-memory';\nimport { wrappedWorkerRxStorage } from '../../storage-worker';\n\n\nconst storage = getRxStorageMemory({});\nwrappedWorkerRxStorage({\n    storage\n});\n","/**\n * This file contains everything\n * that is supposed to run inside of the worker.\n */\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxStorage,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult\n} from '../../types';\nimport { expose } from 'threads/worker';\nimport { getFromMapOrThrow } from '../utils';\nimport { Observable } from 'rxjs';\n\n\nexport type InWorkerStorage<RxDocType, CheckpointType> = {\n    createStorageInstance(\n        params: RxStorageInstanceCreationParams<RxDocType, any>\n    ): Promise<number>;\n    bulkWrite(\n        instanceId: number,\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>>;\n    findDocumentsById(\n        instanceId: number,\n        ids: string[], deleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>>;\n    query(\n        instanceId: number,\n        preparedQuery: any\n    ): Promise<RxStorageQueryResult<RxDocType>>;\n    count(\n        instanceId: number,\n        preparedQuery: any\n    ): Promise<RxStorageCountResult>;\n    getAttachmentData(\n        instanceId: number,\n        documentId: string,\n        attachmentId: string\n    ): Promise<string>;\n    getChangedDocumentsSince(\n        instanceId: number,\n        limit: number,\n        checkpoint?: CheckpointType\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: any;\n    }>;\n    changeStream(\n        instanceById: number\n    ): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, CheckpointType>>;\n    cleanup(instanceId: number, minDeletedTime: number): Promise<boolean>;\n    close(instanceId: number): Promise<void>;\n    remove(instanceId: number): Promise<void>;\n\n    conflictResultionTasks(\n        instanceById: number\n    ): Observable<RxConflictResultionTask<RxDocType>>;\n    resolveConflictResultionTask(\n        instanceById: number,\n        taskSolution: RxConflictResultionTaskSolution<RxDocType>\n    ): Promise<void>;\n};\n\nexport function wrappedWorkerRxStorage<T, D, CheckpointType = any>(\n    args: {\n        storage: RxStorage<T, D>;\n    }\n) {\n    let nextId = 0;\n    const instanceById: Map<number, any> = new Map();\n\n    const exposeMe: InWorkerStorage<any, CheckpointType> = {\n        /**\n         * RxStorageInstance\n         */\n        async createStorageInstance(params) {\n            const instanceId = nextId++;\n            const instance = await args.storage.createStorageInstance(params);\n            instanceById.set(instanceId, instance);\n            return instanceId;\n        },\n        bulkWrite<DocumentData>(\n            instanceId: number,\n            documentWrites: BulkWriteRow<DocumentData>[],\n            context: string\n        ) {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.bulkWrite(documentWrites, context);\n        },\n        findDocumentsById<DocumentData>(\n            instanceId: number,\n            ids: string[],\n            deleted: boolean\n        ): Promise<RxDocumentDataById<DocumentData>> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.findDocumentsById(ids, deleted);\n        },\n        query<DocumentData>(\n            instanceId: number,\n            preparedQuery: any\n        ): Promise<RxStorageQueryResult<DocumentData>> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.query(preparedQuery);\n        },\n        count(\n            instanceId: number,\n            preparedQuery: any\n        ): Promise<RxStorageCountResult> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.count(preparedQuery);\n        },\n        getAttachmentData(\n            instanceId: number,\n            documentId: string,\n            attachmentId: string\n        ): Promise<string> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.getAttachmentData(\n                documentId,\n                attachmentId\n            );\n        },\n        getChangedDocumentsSince<RxDocType>(\n            instanceId: number,\n            limit: number,\n            checkpoint: any\n        ): Promise<{\n                documents: RxDocumentData<RxDocType>[];\n                checkpoint: any;\n            }> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.getChangedDocumentsSince(\n                limit,\n                checkpoint\n            );\n        },\n        changeStream<DocumentData>(\n            instanceId: number\n        ): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<DocumentData>>, CheckpointType>> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.changeStream();\n        },\n        cleanup(\n            instanceId: number,\n            minDeletedTime: number\n        ) {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.cleanup(minDeletedTime);\n        },\n        close(instanceId: number) {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.close();\n        },\n        remove(instanceId: number) {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.remove();\n        },\n\n        conflictResultionTasks<RxDocType>(\n            instanceId: number\n        ): Observable<RxConflictResultionTask<RxDocType>> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.conflictResultionTasks();\n        },\n        resolveConflictResultionTask<RxDocType>(\n            instanceId: number,\n            taskSolution: RxConflictResultionTaskSolution<RxDocType>\n        ): Promise<void> {\n            const instance = getFromMapOrThrow(instanceById, instanceId);\n            return instance.resolveConflictResultionTask(taskSolution);\n        }\n    };\n    expose(exposeMe);\n}\n"],"names":["module","exports","value","Symbol","observable","Object","defineProperty","serialize","deserialize","registerSerializer","serializers_1","registeredSerializer","DefaultSerializer","serializer","extendSerializer","message","input","extend","implementation","fallbackDeserializer","bind","fallbackSerializer","DefaultErrorSerializer","assign","Error","name","stack","error","__error_marker","thing","$worker","$transferable","$terminate","$events","$errors","Transfer","isTransferDescriptor","symbols_1","payload","transferables","send","WorkerMessageType","MasterMessageType","isWorkerRuntime","isWindowContext","self","Window","postMessage","postMessageToMaster","data","transferList","subscribeToMasterMessages","onMessage","messageHandler","messageEvent","addEventListener","removeEventListener","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","expose","is_observable_1","common_1","transferable_1","messages_1","implementation_1","common_2","enumerable","get","transferable_2","default","exposeCalled","activeSubscriptions","Map","isMasterJobRunMessage","type","run","isObservable","subscribe","isZenObservable","deconstructTransfer","undefined","postJobErrorMessage","uid","rawError","errorMessage","postJobResultMessage","completed","resultValue","resultMessage","complete","postUncaughtErrorMessage","uncaughtError","subError","console","runFunction","jobUID","fn","args","syncResult","resultType","startMessage","running","postJobStartMessage","subscription","delete","set","exposed","messageData","method","map","initMessage","init","postFunctionInitMessage","methodNames","methods","postModuleInitMessage","keys","filter","key","cancel","unsubscribe","event","setTimeout","reason","process","on","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","_typeof","obj","iterator","constructor","prototype","_toPropertyKey","arg","hint","prim","toPrimitive","res","TypeError","String","Number","_defineProperties","target","props","i","length","descriptor","configurable","writable","_createClass","Constructor","protoProps","staticProps","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","create","_getPrototypeOf","getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_construct","Parent","Class","a","push","instance","Function","arguments","_wrapNativeSuper","_cache","toString","indexOf","has","Wrapper","overwritable","isDevMode","deepFreezeWhenDevMode","tunnelErrorMessage","messageForError","code","parameters","ret","k","paramStr","JSON","stringify","_k","v","join","parametersToString","RxError","mes","rxdb","newRxError","ensureNotFalsy","getFromMapOrThrow","val","randomCouchString","text","possible","charAt","Math","floor","random","_lastNow","now","Date","getTime","twoDecimals","parseFloat","toFixed","defaultHashFunction","inputString","doNotUseTextEncoder","len","encoded","hashValue","TextEncoder","j","charCodeAt","encode","fastUnsecureHash","flatClone","stripAttachmentsDataFromRow","writeRow","previous","document","stripAttachmentsDataFromDocument","doc","useDoc","_attachments","entries","forEach","attachmentId","attachmentData","writeData","attachmentBase64String","digest","atob","getUniqueDeterministicEventKey","storageInstance","primaryPath","docId","binary","_deleted","databaseName","collectionName","_rev","extendStatics","d","b","Array","hasOwnProperty","__extends","__","__values","s","m","__read","n","r","ar","__spreadArray","to","from","pack","l","slice","concat","createErrorClass","createImpl","ctorFunc","UnsubscriptionError","_super","errors","err","arrRemove","arr","item","index","splice","Subscription","initialTeardown","closed","_parentage","_finalizers","empty","e_1","_a","e_2","_b","isArray","_parentage_1","_parentage_1_1","remove","e_1_1","return","initialFinalizer","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","e_2_1","add","teardown","_hasParent","_addParent","parent","includes","_removeParent","EMPTY","EMPTY_SUBSCRIPTION","isSubscription","config","onUnhandledError","onStoppedNotification","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","handler","timeout","_i","delegate","clearTimeout","handle","noop","COMPLETE_NOTIFICATION","createNotification","kind","context","errorContext","cb","isRoot","errorThrown","Subscriber","destination","_this","isStopped","EMPTY_OBSERVER","SafeSubscriber","handleStoppedNotification","nextNotification","_next","_error","_complete","_bind","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","reportUnhandledError","notification","subscriber","identity","x","pipeFromArray","fns","reduce","prev","Observable","_subscribe","lift","operator","source","isObserver","_trySubscribe","sink","promiseCtor","getPromiseCtor","pipe","operations","toPromise","ObjectUnsubscribedError","Subject","currentObservers","observers","hasError","thrownError","subject","AnonymousSubject","_throwIfClosed","_c","shift","_checkFinalizedStatuses","_innerSubscribe","asObservable","isObject","disallowedKeys","Set","digits","getPathSegments","path","parts","currentSegment","currentPart","isIgnoring","character","parseInt","isStringIndex","object","isInteger","getSchemaByObjectPath","rxJsonSchema","usePath","pathArray","getProperty","str","substr","trimDots","replace","getPrimaryFieldOfPrimaryKey","primaryKey","INDEX_MAX","fromCharCode","INDEX_MIN","Infinity","getQueryPlan","schema","query","selector","indexes","currentBestQueryPlan","optimalSortIndexCompareString","sort","sortField","hasDescSorting","find","values","currentBestQuality","inclusiveEnd","inclusiveStart","opts","indexField","matcher","operators","matcherOpts","LOGICAL_OPERATORS","partialOpts","operatorValue","startKey","endKey","getMatcherQueryOpts","queryPlan","startKeys","opt","endKeys","sortFieldsSameAsIndexFields","selectorSatisfiedByIndex","isSelectorSatisfiedByIndex","quality","pointsPerMatchingKey","idxOfFirstMinStartKey","findIndex","keyValue","idxOfFirstMaxEndKey","pointsIfNoReSortMustBeDone","rateQueryPlan","LOWER_BOUND_LOGICAL_OPERATORS","UPPER_BOUND_LOGICAL_OPERATORS","prevLowerBoundaryField","prevUpperBoundaryField","fieldName","operation","op","_value","hasLowerLogicOp","hasUpperLogicOp","getIndexableStringMonad","fieldNameProperties","schemaPart","parsedLengths","objectPath","split","getStringLengthOfIndexNumber","hasComplexPath","getValueFn","currentVal","t","docData","fieldValue","padEnd","maxLength","getNumberIndexString","minimum","maximum","ceil","multipleOf","nonDecimals","multipleOfParts","decimals","roundedMinimum","padStart","splitByDecimalPoint","getStartIndexStringFromLowerBound","lowerBound","idx","bound","repeat","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","ge","y","c","h","gt","le","eq","norm","f","boundGT","boundEQ","getMemoryCollectionKey","ensureNotRemoved","internals","removed","attachmentMapKey","documentId","SORT_BY_INDEX_STRING","indexString","putWriteRowToState","state","stateByIndex","row","docInState","documents","byIndex","docsWithIndex","newIndexString","getIndexableString","insertPosition","array","compareFunction","noCopy","lastMidDoc","high","low","mid","pushAtSortPosition","id","previousIndexString","indexBefore","compareDocsWithIndex","removeDocFromState","positionInIndex","addIndexesToInternalsState","useIndexes","toArray","indexAr","unshift","getMemoryIndexName","changesIndex","indexName","MAX_LONG","MAX_SAFE_INTEGER","MIN_LONG","MIN_SAFE_INTEGER","MISSING","DEFAULT_HASH_FUNCTION","hash","JS_SIMPLE_TYPES","SORT_ORDER_BY_TYPE","null","number","string","boolean","date","regexp","function","u","toLowerCase","OBJECT_PROTOTYPE","OBJECT_TYPE_RE","condition","objKeys","exec","isBoolean","isNaN","proto","isObjectLike","isRegExp","RegExp","inArray","notInArray","isMissing","prop","merge","options","inputs","every","flatten","addIndex","root","right","left","getIndexes","intersection","hashFunction","some","sortedIndex","smallestArray","maxResultSize","orderedIndexes","arrayIndex","size","isEqual","min","freq","xs","depth","flatten2","ys","max","lhs","rhs","pop","nativeType","aKeys","bKeys","toISOString","prefix","collection","keyFn","comparator","sorted","groups","lookup","MAX_ARRAY_PUSH","rest","acc","begin","getValue","resolve2","field","subpath","unwrapArray","unwrap","names","isIndex","hasNext","preserveMissing","preserveKeys","filterMissing","walk","buildGraph","isNextArrayIndex","match","descendArray","test","elem","OPERATOR_NAME_PATTERN","normalize","expr","$regex","$eq","ProcessingMode","_root","_local","timestamp","update","static","local","initOptions","idKey","collation","processingMode","CLONE_OFF","useStrictMode","scriptEnabled","collectionResolver","jsonSchemaValidator","variables","freeze","OperatorType","OPERATORS","ACCUMULATOR","EXPRESSION","PIPELINE","PROJECTION","QUERY","WINDOW","useOperators","currentFn","systemVariables","$$ROOT","$$CURRENT","$$REMOVE","$$NOW","redactVariables","$$KEEP","$$PRUNE","$$DESCEND","current","copts","callExpression","callAccumulator","dropItem","DONE","Action","iteratees","yieldedValues","getNext","isDone","nextVal","src","nextFn","buffer","bufferIndex","storeResult","outer","innerDone","action","MAP","func","FILTER","TAKE","count","DROP","createCallback","predicate","take","drop","transform","iter","each","initialValue","_","pipeline","stream","mode","pipelineOperators","operatorKeys","Cursor","projection","fetch","$project","fetchAll","buffered","iterators","all","skip","$skip","limit","$limit","modifier","$sort","spec","callback","criteria","compiled","compile","whereOperator","processOperator","expressionKeys","idOnlyExcluded","validateExpression","ID_KEY","processObject","newObj","foundSlice","foundExclusion","dropKeys","subExpr","subExprObj","subExprKeys","objPathGraph","check","sortKeys","cmp","collationSpec","locale","localeOpt","sensitivity","COLLATION_STRENGTH","strength","caseFirst","numeric","numericOrdering","ignorePunctuation","alternate","caseLevel","collator","Intl","Collator","compare","collationComparator","coll","modifiers","reverse","grouped","indexKeys","createQueryOperator","$in","isNonBooleanOperator","$elemMatch","format","temp","isNull","isInt","isLong","compareFuncs","bool","decimal","double","int","long","regex","compareType","queries","matched","createBitwiseOperator","mask","$and","$or","$nor","$not","mingoInitDone","getMingoQuery","$exists","$gt","$gte","$lt","$lte","$ne","$nin","$mod","$size","$type","Query","RxStorageDefaultStatics","prepareQuery","mutateableQuery","getSortComparator","preparedQuery","_schema","mingoSortObject","sortBlock","direction","sortDirectionToMingo","getDefaultSortComparator","getQueryMatcher","mingoQuery","checkpointSchema","properties","lwt","required","additionalProperties","RxStorageInstanceMemory","storage","settings","bulkWrite","documentWrites","success","categorized","docsInDb","bulkWriteRows","hasAttachments","attachments","bulkInsertDocs","bulkUpdateDocs","changedDocumentIds","eventBulk","events","checkpoint","attachmentsAdd","attachmentsRemove","attachmentsUpdate","startTime","docsByIdIsMap","attachmentError","documentInDb","revInDb","isError","status","updatedRow","previousAttachmentData","newDigest","writeDoc","eventDocumentData","previousEventDocumentData","eventId","documentData","previousDocumentData","endTime","insertedIsDeleted","categorizeBulkWriteRows","attachmentsMap","attachment","lastState","docs","_meta","getNewestOfDocumentStates","changes$","findDocumentsById","docIds","withDeleted","docInDb","skipPlusLimit","queryMatcher","queryPlanFields","mustManuallyResort","lowerBoundString","upperBound","upperBoundString","getStartIndexStringFromUpperBound","indexOfLower","indexOfUpper","boundLE","rows","currentDoc","sortComparator","async","getChangedDocumentsSince","sinceLwt","sinceId","lastDoc","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","changeStream","collectionStates","close","refCount","conflictResultionTasks","conflictResultionTasks$","resolveConflictResultionTask","_taskSolution","COLLECTION_STATES","nextId","instanceById","exposeMe","statics","createStorageInstance","params","keyCompression","jsonSchema","encrypted","ensureRxStorageInstanceParamsAreCorrect","version","collectionKey","createMemoryStorageInstance","getRxStorageMemory","instanceId","ids","deleted","minDeletedTime","taskSolution"],"sourceRoot":""}