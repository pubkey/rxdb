{"version":3,"file":"upstream.js","names":["pact","state","value","s","v","o","bind","then","observer","prototype","onFulfilled","onRejected","result","callback","e","_this","thenable","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","startReplicationUpstream","upstreamInitialSync","stats","up","events","canceled","getValue","checkpointQueue","getLastCheckpointDoc","lastCheckpoint","Promise","all","promises","resolvedPromises","hadConflicts","find","r","firstSyncDone","next","initialSyncStartTime","timer","input","forkInstance","getChangedDocumentsSince","pushBatchSize","upResult","documents","length","stackCheckpoints","checkpoint","push","persistToMaster","ensureNotFalsy","replicationHandler","streamQueue","processTasks","openTasks","sub","changeStream","pipe","filter","eventBulk","context","downstreamBulkWriteFlag","subscribe","forkChangeStreamEmit","task","time","waitBeforePersist","firstValueFrom","unsubscribe","active","docs","taskWithTime","shift","concat","map","documentData","promise","PROMISE_RESOLVE_FALSE","persistenceQueue","nonPersistedFromMaster","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","getAssumedMasterState","assumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","isEqual","assumedMasterDoc","undefined","newDocumentState","getMetaWriteRow","metaDocument","fullDocData","writeDocToDocState","isResolvedConflict","_rev","conflictHandler","realMasterState","writeRowsArray","values","conflictIds","Set","conflictsById","writeBatches","batchArray","writeBatch","masterWrite","masterWriteResult","conflictDoc","id","add","setCheckpoint","hadConflictWrites","size","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","writeToMasterRow","resolveConflictError","resolved","resolvedConflicts","output","previous","document","resolvedDoc","persistToMasterConflictWrites","bulkWrite","forkWriteResult","useMetaWrites","success","metaInstance","useWriteRowsToMeta","has","processed","unhandledError","error"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types';\nimport {\n    batchArray,\n    ensureNotFalsy,\n    PROMISE_RESOLVE_FALSE\n} from '../util';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint';\nimport { resolveConflictError } from './conflicts';\nimport { writeDocToDocState } from './helper';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    const sub = state.input.forkInstance.changeStream()\n        .pipe(\n            filter(eventBulk => eventBulk.context !== state.downstreamBulkWriteFlag)\n        ).subscribe(eventBulk => {\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n            const upResult = await state.input.forkInstance.getChangedDocumentsSince(\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            promises.push(\n                persistToMaster(\n                    upResult.documents,\n                    ensureNotFalsy(lastCheckpoint)\n                )\n            );\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upastream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (!state.firstSyncDone.up.getValue()) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(() => {\n            /**\n             * Merge/filter all open tasks\n             */\n            let docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType = {} as any;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                /**\n                 * If the task came in before the last time the initial sync fetching\n                 * has run, we can ignore the task because the initial sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    continue;\n                }\n\n                docs = docs.concat(\n                    taskWithTime.task.events.map(r => {\n                        return r.documentData as any;\n                    })\n                );\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n            }\n\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\n                docs,\n                checkpoint\n            );\n            return promise.then(() => {\n                if (openTasks.length === 0) {\n                    state.events.active.up.next(false);\n                } else {\n                    processTasks();\n                }\n            });\n        });\n    }\n\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistend list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n            if (docIds.length === 0) {\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        assumedMasterDoc &&\n                        // if the isResolvedConflict is correct, we do not have to compare the documents.\n                        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev &&\n                        (await state.input.conflictHandler({\n                            realMasterState: assumedMasterDoc.docData,\n                            newDocumentState: docData\n                        }, 'upstream-check-if-equal')).isEqual\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                return false;\n            }\n\n\n            const writeRowsArray = Object.values(writeRowsToMaster);\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n\n            /**\n             * To always respect the push.batchSize,\n             * we have to split the write rows into batches\n             * to ensure that replicationHandler.masterWrite() is never\n             * called with more documents than what the batchSize limits.\n             */\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n            await Promise.all(\n                writeBatches.map(async (writeBatch) => {\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n                    masterWriteResult.forEach(conflictDoc => {\n                        const id = (conflictDoc as any)[state.primaryPath];\n                        conflictIds.add(id);\n                        conflictsById[id] = conflictDoc;\n                    });\n                })\n            );\n\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    useWriteRowsToMeta,\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(resolved => {\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved.output\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved.resolvedDoc\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved.resolvedDoc._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n                    /**\n                     * Errors in the forkWriteResult must not be handled\n                     * because they have been caused by a write to the forkInstance\n                     * in between which will anyway trigger a new upstream cycle\n                     * that will then resolved the conflict again.\n                     */\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta>[] = [];\n                    Object\n                        .keys(forkWriteResult.success)\n                        .forEach((docId) => {\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            useMetaWrites,\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parallel checkpoint writes,\n             * we have to use a queue.\n             */\n            state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(\n                state,\n                'up',\n                useCheckpoint\n            ));\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n\n"],"mappings":";;;;;;AAAA;AACA;AAaA;AAKA;AAIA;AACA;AACA;AAcO,iBAAiBA,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAE;EAC3C,IAAI,CAACF,IAAI,CAACG,CAAC,EAAE;IACZ,IAAID,KAAK,iBAAiB,EAAE;MAC3B,IAAIA,KAAK,CAACC,CAAC,EAAE;QACZ,IAAIF,KAAK,GAAG,CAAC,EAAE;UACdA,KAAK,GAAGC,KAAK,CAACC,CAAC;QAChB;QACAD,KAAK,GAAGA,KAAK,CAACE,CAAC;MAChB,CAAC,MAAM;QACNF,KAAK,CAACG,CAAC,GAAG,QAAQC,IAAI,CAAC,IAAI,EAAEN,IAAI,EAAEC,KAAK,CAAC;QACzC;MACD;IACD;IACA,IAAIC,KAAK,IAAIA,KAAK,CAACK,IAAI,EAAE;MACxBL,KAAK,CAACK,IAAI,CAAC,QAAQD,IAAI,CAAC,IAAI,EAAEN,IAAI,EAAEC,KAAK,CAAC,EAAE,QAAQK,IAAI,CAAC,IAAI,EAAEN,IAAI,EAAE,CAAC,CAAC,CAAC;MACxE;IACD;IACAA,IAAI,CAACG,CAAC,GAAGF,KAAK;IACdD,IAAI,CAACI,CAAC,GAAGF,KAAK;IACd,IAAMM,QAAQ,GAAGR,IAAI,CAACK,CAAC;IACvB,IAAIG,QAAQ,EAAE;MACbA,QAAQ,CAACR,IAAI,CAAC;IACf;EACD;AACD;AA9DO,IAAM,QAAQ,aAAc,YAAW;EAC7C,iBAAiB,CAAC;EAClB,MAAMS,SAAS,CAACF,IAAI,GAAG,UAASG,WAAW,EAAEC,UAAU,EAAE;IACxD,IAAMC,MAAM,GAAG,WAAW;IAC1B,IAAMX,KAAK,GAAG,IAAI,CAACE,CAAC;IACpB,IAAIF,KAAK,EAAE;MACV,IAAMY,QAAQ,GAAGZ,KAAK,GAAG,CAAC,GAAGS,WAAW,GAAGC,UAAU;MACrD,IAAIE,QAAQ,EAAE;QACb,IAAI;UACH,QAAQD,MAAM,EAAE,CAAC,EAAEC,QAAQ,CAAC,IAAI,CAACT,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,OAAOU,CAAC,EAAE;UACX,QAAQF,MAAM,EAAE,CAAC,EAAEE,CAAC,CAAC;QACtB;QACA,OAAOF,MAAM;MACd,CAAC,MAAM;QACN,OAAO,IAAI;MACZ;IACD;IACA,IAAI,CAACP,CAAC,GAAG,UAASU,KAAK,EAAE;MACxB,IAAI;QACH,IAAMb,KAAK,GAAGa,KAAK,CAACX,CAAC;QACrB,IAAIW,KAAK,CAACZ,CAAC,GAAG,CAAC,EAAE;UAChB,QAAQS,MAAM,EAAE,CAAC,EAAEF,WAAW,GAAGA,WAAW,CAACR,KAAK,CAAC,GAAGA,KAAK,CAAC;QAC7D,CAAC,MAAM,IAAIS,UAAU,EAAE;UACtB,QAAQC,MAAM,EAAE,CAAC,EAAED,UAAU,CAACT,KAAK,CAAC,CAAC;QACtC,CAAC,MAAM;UACN,QAAQU,MAAM,EAAE,CAAC,EAAEV,KAAK,CAAC;QAC1B;MACD,CAAC,CAAC,OAAOY,CAAC,EAAE;QACX,QAAQF,MAAM,EAAE,CAAC,EAAEE,CAAC,CAAC;MACtB;IACD,CAAC;IACD,OAAOF,MAAM;EACd,CAAC;EACD;AACD,CAAC,EAAG;AA6BG,wBAAwBI,QAAQ,EAAE;EACxC,OAAOA,QAAQ,iBAAiB,IAAIA,QAAQ,CAACb,CAAC,GAAG,CAAC;AACnD;AA4LO,cAAcc,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxC,IAAIC,KAAK;EACT,SAAS;IACR,IAAIC,cAAc,GAAGJ,IAAI,EAAE;IAC3B,IAAI,eAAeI,cAAc,CAAC,EAAE;MACnCA,cAAc,GAAGA,cAAc,CAACjB,CAAC;IAClC;IACA,IAAI,CAACiB,cAAc,EAAE;MACpB,OAAOT,MAAM;IACd;IACA,IAAIS,cAAc,CAACd,IAAI,EAAE;MACxBa,KAAK,GAAG,CAAC;MACT;IACD;IACA,IAAIR,MAAM,GAAGO,IAAI,EAAE;IACnB,IAAIP,MAAM,IAAIA,MAAM,CAACL,IAAI,EAAE;MAC1B,IAAI,eAAeK,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACT,CAAC;MAClB,CAAC,MAAM;QACNiB,KAAK,GAAG,CAAC;QACT;MACD;IACD;IACA,IAAIF,MAAM,EAAE;MACX,IAAII,WAAW,GAAGJ,MAAM,EAAE;MAC1B,IAAII,WAAW,IAAIA,WAAW,CAACf,IAAI,IAAI,CAAC,eAAee,WAAW,CAAC,EAAE;QACpEF,KAAK,GAAG,CAAC;QACT;MACD;IACD;EACD;EACA,IAAIpB,IAAI,GAAG,WAAW;EACtB,IAAIuB,MAAM,GAAG,QAAQjB,IAAI,CAAC,IAAI,EAAEN,IAAI,EAAE,CAAC,CAAC;EACxC,CAACoB,KAAK,KAAK,CAAC,GAAGC,cAAc,CAACd,IAAI,CAACiB,gBAAgB,CAAC,GAAGJ,KAAK,KAAK,CAAC,GAAGR,MAAM,CAACL,IAAI,CAACkB,gBAAgB,CAAC,GAAGH,WAAW,CAACf,IAAI,CAACmB,kBAAkB,CAAC,EAAEnB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;EAC/J,OAAOvB,IAAI;EACX,SAASyB,gBAAgB,CAACvB,KAAK,EAAE;IAChCU,MAAM,GAAGV,KAAK;IACd,GAAG;MACF,IAAIgB,MAAM,EAAE;QACXI,WAAW,GAAGJ,MAAM,EAAE;QACtB,IAAII,WAAW,IAAIA,WAAW,CAACf,IAAI,IAAI,CAAC,eAAee,WAAW,CAAC,EAAE;UACpEA,WAAW,CAACf,IAAI,CAACmB,kBAAkB,CAAC,CAACnB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;UACzD;QACD;MACD;MACAF,cAAc,GAAGJ,IAAI,EAAE;MACvB,IAAI,CAACI,cAAc,IAAK,eAAeA,cAAc,CAAC,IAAI,CAACA,cAAc,CAACjB,CAAE,EAAE;QAC7E,QAAQJ,IAAI,EAAE,CAAC,EAAEY,MAAM,CAAC;QACxB;MACD;MACA,IAAIS,cAAc,CAACd,IAAI,EAAE;QACxBc,cAAc,CAACd,IAAI,CAACiB,gBAAgB,CAAC,CAACjB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;QAC1D;MACD;MACAX,MAAM,GAAGO,IAAI,EAAE;MACf,IAAI,eAAeP,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACR,CAAC;MAClB;IACD,CAAC,QAAQ,CAACQ,MAAM,IAAI,CAACA,MAAM,CAACL,IAAI;IAChCK,MAAM,CAACL,IAAI,CAACkB,gBAAgB,CAAC,CAAClB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;EACnD;EACA,SAASC,gBAAgB,CAACH,cAAc,EAAE;IACzC,IAAIA,cAAc,EAAE;MACnBT,MAAM,GAAGO,IAAI,EAAE;MACf,IAAIP,MAAM,IAAIA,MAAM,CAACL,IAAI,EAAE;QAC1BK,MAAM,CAACL,IAAI,CAACkB,gBAAgB,CAAC,CAAClB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;MACnD,CAAC,MAAM;QACNE,gBAAgB,CAACb,MAAM,CAAC;MACzB;IACD,CAAC,MAAM;MACN,QAAQZ,IAAI,EAAE,CAAC,EAAEY,MAAM,CAAC;IACzB;EACD;EACA,SAASc,kBAAkB,GAAG;IAC7B,IAAIL,cAAc,GAAGJ,IAAI,EAAE,EAAE;MAC5B,IAAII,cAAc,CAACd,IAAI,EAAE;QACxBc,cAAc,CAACd,IAAI,CAACiB,gBAAgB,CAAC,CAACjB,IAAI,CAAC,KAAK,CAAC,EAAEgB,MAAM,CAAC;MAC3D,CAAC,MAAM;QACNC,gBAAgB,CAACH,cAAc,CAAC;MACjC;IACD,CAAC,MAAM;MACN,QAAQrB,IAAI,EAAE,CAAC,EAAEY,MAAM,CAAC;IACzB;EACD;AACD;AArTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASe,wBAAwB,CACpC1B,KAAmD,EACrD;EAAA,IA2CiB2B,mBAAmB,YAAnBA,mBAAmB;IAAA,IAAG;MACjC3B,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACF,mBAAmB,GAAG3B,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACF,mBAAmB,GAAG,CAAC;MAC3E,IAAI3B,KAAK,CAAC8B,MAAM,CAACC,QAAQ,CAACC,QAAQ,EAAE,EAAE;QAClC;MACJ;MAEAhC,KAAK,CAACiC,eAAe,GAAGjC,KAAK,CAACiC,eAAe,CAAC3B,IAAI,CAAC;QAAA,OAAM,IAAA4B,gCAAoB,EAAClC,KAAK,EAAE,IAAI,CAAC;MAAA,EAAC;MAAC,uBACjDA,KAAK,CAACiC,eAAe,iBAA5DE,cAA8B;QAAA;QAAA;UAuBlC;AACR;AACA;AACA;AACA;UAJQ,uBAK+BC,OAAO,CAACC,GAAG,CAACC,QAAQ,CAAC,iBAA9CC,gBAAgB;YACtB,IAAMC,YAAY,GAAGD,gBAAgB,CAACE,IAAI,CAAC,UAAAC,CAAC;cAAA,OAAI,CAAC,CAACA,CAAC;YAAA,EAAC;YAAC;cAAA,IACjDF,YAAY;gBAAA,uBACNb,mBAAmB,EAAE;cAAA,OACxB,IAAI,CAAC3B,KAAK,CAAC2C,aAAa,CAACd,EAAE,CAACG,QAAQ,EAAE,EAAE;gBAC3ChC,KAAK,CAAC2C,aAAa,CAACd,EAAE,CAACe,IAAI,CAAC,IAAI,CAAC;cACrC;YAAC;YAAA;UAAA;QAAA;QAhCD,IAAMN,QAAwB,GAAG,EAAE;QAAC;UAAA,sBAC7B,CAACtC,KAAK,CAAC8B,MAAM,CAACC,QAAQ,CAACC,QAAQ,EAAE;QAAA,uBAAE;UACtCa,oBAAoB,GAAGC,KAAK,EAAE;UAAC,uBACR9C,KAAK,CAAC+C,KAAK,CAACC,YAAY,CAACC,wBAAwB,CACpEjD,KAAK,CAAC+C,KAAK,CAACG,aAAa,EACzBf,cAAc,CACjB,iBAHKgB,QAAQ;YAId,IAAIA,QAAQ,CAACC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;cAAA;cAAA;YAErC;YAEAlB,cAAc,GAAG,IAAAmB,iCAAgB,EAAC,CAACnB,cAAc,EAAEgB,QAAQ,CAACI,UAAU,CAAC,CAAC;YAExEjB,QAAQ,CAACkB,IAAI,CACTC,eAAe,CACXN,QAAQ,CAACC,SAAS,EAClB,IAAAM,oBAAc,EAACvB,cAAc,CAAC,CACjC,CACJ;UAAC;QACN,CAAC;QAAA;MAAA;IAcL,CAAC;MAAA;IAAA;EAAA;EAGD;AACJ;AACA;EAzFI,IAAMwB,kBAAkB,GAAG3D,KAAK,CAAC+C,KAAK,CAACY,kBAAkB;EACzD3D,KAAK,CAAC4D,WAAW,CAAC/B,EAAE,GAAG7B,KAAK,CAAC4D,WAAW,CAAC/B,EAAE,CAACvB,IAAI,CAAC,YAAM;IACnD,OAAOqB,mBAAmB,EAAE,CAACrB,IAAI,CAAC,YAAM;MACpCuD,YAAY,EAAE;IAClB,CAAC,CAAC;EACN,CAAC,CAAC;;EAEF;EACA,IAAIf,KAAK,GAAG,CAAC;EACb,IAAID,oBAAoB,GAAG,CAAC,CAAC;EAO7B,IAAMiB,SAAyB,GAAG,EAAE;EAGpC,IAAMC,GAAG,GAAG/D,KAAK,CAAC+C,KAAK,CAACC,YAAY,CAACgB,YAAY,EAAE,CAC9CC,IAAI,CACD,IAAAC,YAAM,EAAC,UAAAC,SAAS;IAAA,OAAIA,SAAS,CAACC,OAAO,KAAKpE,KAAK,CAACqE,uBAAuB;EAAA,EAAC,CAC3E,CAACC,SAAS,CAAC,UAAAH,SAAS,EAAI;IACrBnE,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAAC0C,oBAAoB,GAAGvE,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAAC0C,oBAAoB,GAAG,CAAC;IAC7ET,SAAS,CAACN,IAAI,CAAC;MACXgB,IAAI,EAAEL,SAAS;MACfM,IAAI,EAAE3B,KAAK;IACf,CAAC,CAAC;IACF,IAAI9C,KAAK,CAAC+C,KAAK,CAAC2B,iBAAiB,EAAE;MAC/B,OAAO1E,KAAK,CAAC+C,KAAK,CAAC2B,iBAAiB,EAAE,CACjCpE,IAAI,CAAC;QAAA,OAAMuD,YAAY,EAAE;MAAA,EAAC;IACnC,CAAC,MAAM;MACH,OAAOA,YAAY,EAAE;IACzB;EACJ,CAAC,CAAC;EACN,IAAAc,oBAAc,EACV3E,KAAK,CAAC8B,MAAM,CAACC,QAAQ,CAACkC,IAAI,CACtB,IAAAC,YAAM,EAAC,UAAAnC,QAAQ;IAAA,OAAI,CAAC,CAACA,QAAQ;EAAA,EAAC,CACjC,CACJ,CAACzB,IAAI,CAAC;IAAA,OAAMyD,GAAG,CAACa,WAAW,EAAE;EAAA,EAAC;EAmD/B,SAASf,YAAY,GAAG;IACpB,IACI7D,KAAK,CAAC8B,MAAM,CAACC,QAAQ,CAACC,QAAQ,EAAE,IAChC8B,SAAS,CAACT,MAAM,KAAK,CAAC,EACxB;MACErD,KAAK,CAAC8B,MAAM,CAAC+C,MAAM,CAAChD,EAAE,CAACe,IAAI,CAAC,KAAK,CAAC;MAClC;IACJ;IACA5C,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACgC,YAAY,GAAG7D,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACgC,YAAY,GAAG,CAAC;IAC7D7D,KAAK,CAAC8B,MAAM,CAAC+C,MAAM,CAAChD,EAAE,CAACe,IAAI,CAAC,IAAI,CAAC;IACjC5C,KAAK,CAAC4D,WAAW,CAAC/B,EAAE,GAAG7B,KAAK,CAAC4D,WAAW,CAAC/B,EAAE,CAACvB,IAAI,CAAC,YAAM;MACnD;AACZ;AACA;MACY,IAAIwE,IAAiC,GAAG,EAAE;MAC1C,IAAIvB,UAA0B,GAAG,CAAC,CAAQ;MAC1C,OAAOO,SAAS,CAACT,MAAM,GAAG,CAAC,EAAE;QACzB,IAAM0B,YAAY,GAAG,IAAArB,oBAAc,EAACI,SAAS,CAACkB,KAAK,EAAE,CAAC;QACtD;AAChB;AACA;AACA;AACA;QACgB,IAAID,YAAY,CAACN,IAAI,GAAG5B,oBAAoB,EAAE;UAC1C;QACJ;QAEAiC,IAAI,GAAGA,IAAI,CAACG,MAAM,CACdF,YAAY,CAACP,IAAI,CAAC1C,MAAM,CAACoD,GAAG,CAAC,UAAAxC,CAAC,EAAI;UAC9B,OAAOA,CAAC,CAACyC,YAAY;QACzB,CAAC,CAAC,CACL;QACD5B,UAAU,GAAG,IAAAD,iCAAgB,EAAC,CAACC,UAAU,EAAEwB,YAAY,CAACP,IAAI,CAACjB,UAAU,CAAC,CAAC;MAC7E;MAEA,IAAM6B,OAAO,GAAGN,IAAI,CAACzB,MAAM,KAAK,CAAC,GAAGgC,2BAAqB,GAAG5B,eAAe,CACvEqB,IAAI,EACJvB,UAAU,CACb;MACD,OAAO6B,OAAO,CAAC9E,IAAI,CAAC,YAAM;QACtB,IAAIwD,SAAS,CAACT,MAAM,KAAK,CAAC,EAAE;UACxBrD,KAAK,CAAC8B,MAAM,CAAC+C,MAAM,CAAChD,EAAE,CAACe,IAAI,CAAC,KAAK,CAAC;QACtC,CAAC,MAAM;UACHiB,YAAY,EAAE;QAClB;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA,IAAIyB,gBAAkC,GAAGD,2BAAqB;EAC9D,IAAME,sBAGL,GAAG;IACAT,IAAI,EAAE,CAAC;EACX,CAAC;;EAED;AACJ;AACA;AACA;EACI,SAASrB,eAAe,CACpBqB,IAAiC,EACjCvB,UAA0B,EACV;IAChBvD,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAAC4B,eAAe,GAAGzD,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAAC4B,eAAe,GAAG,CAAC;;IAEnE;AACR;AACA;IACQqB,IAAI,CAACU,OAAO,CAAC,UAAAC,OAAO,EAAI;MACpB,IAAMC,KAAa,GAAID,OAAO,CAASzF,KAAK,CAAC2F,WAAW,CAAC;MACzDJ,sBAAsB,CAACT,IAAI,CAACY,KAAK,CAAC,GAAGD,OAAO;IAChD,CAAC,CAAC;IACFF,sBAAsB,CAAChC,UAAU,GAAGA,UAAU;IAG9C+B,gBAAgB,GAAGA,gBAAgB,CAAChF,IAAI;MAAA,IAAa;QACjD,IAAIN,KAAK,CAAC8B,MAAM,CAACC,QAAQ,CAACC,QAAQ,EAAE,EAAE;UAClC,uBAAO,KAAK;QAChB;QAEA,IAAM4D,UAA2C,GAAGL,sBAAsB,CAACT,IAAI;QAC/ES,sBAAsB,CAACT,IAAI,GAAG,CAAC,CAAC;QAChC,IAAMe,aAAa,GAAGN,sBAAsB,CAAChC,UAAU;QACvD,IAAMuC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACJ,UAAU,CAAC;QACtC,IAAIE,MAAM,CAACzC,MAAM,KAAK,CAAC,EAAE;UACrB,uBAAO,KAAK;QAChB;QAAC,uBAEgC,IAAA4C,mCAAqB,EAClDjG,KAAK,EACL8F,MAAM,CACT,iBAHKI,kBAAkB;UAKxB,IAAMC,iBAAiE,GAAG,CAAC,CAAC;UAC5E,IAAMC,oBAA8B,GAAG,EAAE;UACzC,IAAMC,eAA2D,GAAG,CAAC,CAAC;UACtE,IAAMC,aAA8C,GAAG,CAAC,CAAC;UAAC,uBAEpDlE,OAAO,CAACC,GAAG,CACbyD,MAAM,CAACZ,GAAG,WAAQQ,KAAK;YAAA,IAAK;cAAA;gBAWxB,IACI,WAGA,sBAG+Ba,OAAO,EACxC;kBAAA;kBAAA;gBAEF;gBAEAH,oBAAoB,CAAC5C,IAAI,CAACkC,KAAK,CAAC;gBAEhCS,iBAAiB,CAACT,KAAK,CAAC,GAAG;kBACvBQ,kBAAkB,EAAEM,gBAAgB,GAAGA,gBAAgB,CAACf,OAAO,GAAGgB,SAAS;kBAC3EC,gBAAgB,EAAEjB;gBACtB,CAAC;gBACDY,eAAe,CAACX,KAAK,CAAC,GAAG,IAAAiB,6BAAe,EACpC3G,KAAK,EACLyF,OAAO,EACPe,gBAAgB,GAAGA,gBAAgB,CAACI,YAAY,GAAGH,SAAS,CAC/D;cAAC;cAAA;cAhCF,IAAMI,WAAsC,GAAGjB,UAAU,CAACF,KAAK,CAAC;cAChEY,aAAa,CAACZ,KAAK,CAAC,GAAGmB,WAAW;cAClC,IAAMpB,OAA+B,GAAG,IAAAqB,0BAAkB,EAACD,WAAW,CAAC;cACvE,IAAML,gBAAgB,GAAGN,kBAAkB,CAACR,KAAK,CAAC;;cAElD;AACpB;AACA;AACA;AACA;cAJoB,cAMIc,gBAAgB;cAChB;cACAA,gBAAgB,CAACI,YAAY,CAACG,kBAAkB,KAAKF,WAAW,CAACG,IAAI;cAAA,iDAC9DhH,KAAK,CAAC+C,KAAK,CAACkE,eAAe,CAAC;gBAC/BC,eAAe,EAAEV,gBAAgB,CAACf,OAAO;gBACzCiB,gBAAgB,EAAEjB;cACtB,CAAC,EAAE,yBAAyB,CAAC;YAgBrC,CAAC;cAAA;YAAA;UAAA,EAAC,CACL;YAED,IAAIW,oBAAoB,CAAC/C,MAAM,KAAK,CAAC,EAAE;cACnC,OAAO,KAAK;YAChB;YAGA,IAAM8D,cAAc,GAAGpB,MAAM,CAACqB,MAAM,CAACjB,iBAAiB,CAAC;YACvD,IAAMkB,WAAwB,GAAG,IAAIC,GAAG,EAAE;YAC1C,IAAMC,aAA2C,GAAG,CAAC,CAAC;;YAEtD;AACZ;AACA;AACA;AACA;AACA;YACY,IAAMC,YAAY,GAAG,IAAAC,gBAAU,EAACN,cAAc,EAAEnH,KAAK,CAAC+C,KAAK,CAACG,aAAa,CAAC;YAAC,uBACrEd,OAAO,CAACC,GAAG,CACbmF,YAAY,CAACtC,GAAG,WAAQwC,UAAU;cAAA,IAAK;gBAAA,uBACH/D,kBAAkB,CAACgE,WAAW,CAACD,UAAU,CAAC,iBAApEE,iBAAiB;kBACvBA,iBAAiB,CAACpC,OAAO,CAAC,UAAAqC,WAAW,EAAI;oBACrC,IAAMC,EAAE,GAAID,WAAW,CAAS7H,KAAK,CAAC2F,WAAW,CAAC;oBAClD0B,WAAW,CAACU,GAAG,CAACD,EAAE,CAAC;oBACnBP,aAAa,CAACO,EAAE,CAAC,GAAGD,WAAW;kBACnC,CAAC,CAAC;gBAAC;cACP,CAAC;gBAAA;cAAA;YAAA,EAAC,CACL;cAAA;gBAAA;kBAoGD;AACZ;AACA;AACA;AACA;kBACY7H,KAAK,CAACiC,eAAe,GAAGjC,KAAK,CAACiC,eAAe,CAAC3B,IAAI,CAAC;oBAAA,OAAM,IAAA0H,yBAAa,EAClEhI,KAAK,EACL,IAAI,EACJ6F,aAAa,CAChB;kBAAA,EAAC;kBAEF,OAAOoC,iBAAiB;gBAAC;gBA1FzB;AACZ;AACA;AACA;AACA;AACA;gBACY,IAAIA,iBAAiB,GAAG,KAAK;gBAAC;kBAAA,IAC1BZ,WAAW,CAACa,IAAI,GAAG,CAAC;oBACpBlI,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACsG,2BAA2B,GAAGnI,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACsG,2BAA2B,GAAG,CAAC;oBAC3F,IAAMC,iBAA4C,GAAG,EAAE;oBACvD,IAAMC,iBAA6D,GAAG,CAAC,CAAC;oBAAC,uBACnEjG,OAAO,CAACC,GAAG,CACb0D,MAAM,CACDuC,OAAO,CAACf,aAAa,CAAC,CACtBrC,GAAG,CAAC,gBAA8B;sBAAA,IAA5BQ,KAAK;wBAAEwB,eAAe;sBACzB,IAAMqB,gBAAgB,GAAGpC,iBAAiB,CAACT,KAAK,CAAC;sBACjD,IAAM3C,KAAK,GAAG;wBACV2D,gBAAgB,EAAE6B,gBAAgB,CAAC7B,gBAAgB;wBACnDR,kBAAkB,EAAEqC,gBAAgB,CAACrC,kBAAkB;wBACvDgB,eAAe,EAAfA;sBACJ,CAAC;sBACD,OAAO,IAAAsB,+BAAoB,EACvBxI,KAAK,EACL+C,KAAK,EACLuD,aAAa,CAACZ,KAAK,CAAC,CACvB,CAACpF,IAAI,CAAC,UAAAmI,QAAQ,EAAI;wBACf,IAAIA,QAAQ,EAAE;0BACVzI,KAAK,CAAC8B,MAAM,CAAC4G,iBAAiB,CAAC9F,IAAI,CAAC;4BAChCG,KAAK,EAALA,KAAK;4BACL4F,MAAM,EAAEF,QAAQ,CAACE;0BACrB,CAAC,CAAC;0BACFP,iBAAiB,CAAC5E,IAAI,CAAC;4BACnBoF,QAAQ,EAAEtC,aAAa,CAACZ,KAAK,CAAC;4BAC9BmD,QAAQ,EAAEJ,QAAQ,CAACK;0BACvB,CAAC,CAAC;0BACF,IAAMtC,gBAAgB,GAAGN,kBAAkB,CAACR,KAAK,CAAC;0BAClD2C,iBAAiB,CAAC3C,KAAK,CAAC,GAAG,IAAAiB,6BAAe,EACtC3G,KAAK,EACL,IAAA0D,oBAAc,EAACwD,eAAe,CAAC,EAC/BV,gBAAgB,GAAGA,gBAAgB,CAACI,YAAY,GAAGH,SAAS,EAC5DgC,QAAQ,CAACK,WAAW,CAAC9B,IAAI,CAC5B;wBACL;sBACJ,CAAC,CAAC;oBACN,CAAC,CAAC,CACT;sBAAA;wBAAA,IAEGoB,iBAAiB,CAAC/E,MAAM,GAAG,CAAC;0BAC5B4E,iBAAiB,GAAG,IAAI;0BAExBjI,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACkH,6BAA6B,GAAG/I,KAAK,CAAC4B,KAAK,CAACC,EAAE,CAACkH,6BAA6B,GAAG,CAAC;0BAAC,uBAClE/I,KAAK,CAAC+C,KAAK,CAACC,YAAY,CAACgG,SAAS,CAC5DZ,iBAAiB,EACjB,+BAA+B,CAClC,iBAHKa,eAAe;4BAIrB;AACpB;AACA;AACA;AACA;AACA;4BACoB,IAAMC,aAAuD,GAAG,EAAE;4BAClEnD,MAAM,CACDC,IAAI,CAACiD,eAAe,CAACE,OAAO,CAAC,CAC7B3D,OAAO,CAAC,UAACE,KAAK,EAAK;8BAChBwD,aAAa,CAAC1F,IAAI,CACd6E,iBAAiB,CAAC3C,KAAK,CAAC,CAC3B;4BACL,CAAC,CAAC;4BAAC;8BAAA,IACHwD,aAAa,CAAC7F,MAAM,GAAG,CAAC;gCAAA,uBAClBrD,KAAK,CAAC+C,KAAK,CAACqG,YAAY,CAACJ,SAAS,CACpCE,aAAa,EACb,oCAAoC,CACvC;8BAAA;4BAAA;4BAAA;0BAAA,IAEL;wBAAA;sBAAA;sBAAA;oBAAA;kBAAA;gBAAA;gBAAA;cAAA;cA7FR,IAAMG,kBAA4D,GAAG,EAAE;cAGvEjD,oBAAoB,CAACZ,OAAO,CAAC,UAAAE,KAAK,EAAI;gBAClC,IAAI,CAAC2B,WAAW,CAACiC,GAAG,CAAC5D,KAAK,CAAC,EAAE;kBACzB1F,KAAK,CAAC8B,MAAM,CAACyH,SAAS,CAAC1H,EAAE,CAACe,IAAI,CAACuD,iBAAiB,CAACT,KAAK,CAAC,CAAC;kBACxD2D,kBAAkB,CAAC7F,IAAI,CAAC6C,eAAe,CAACX,KAAK,CAAC,CAAC;gBACnD;cACJ,CAAC,CAAC;cAAC;gBAAA,IAEC2D,kBAAkB,CAAChG,MAAM,GAAG,CAAC;kBAAA,uBACvBrD,KAAK,CAAC+C,KAAK,CAACqG,YAAY,CAACJ,SAAS,CACpCK,kBAAkB,EAClB,2BAA2B,CAC9B,wBACD;gBAAA;cAAA;cAAA;YAAA;UAAA;QAAA;MA8FR,CAAC;QAAA;MAAA;IAAA,EAAC,SAAM,CAAC,UAAAG,cAAc,EAAI;MACvBxJ,KAAK,CAAC8B,MAAM,CAAC2H,KAAK,CAAC7G,IAAI,CAAC4G,cAAc,CAAC;MACvC,OAAO,KAAK;IAChB,CAAC,CAAC;IAEF,OAAOlE,gBAAgB;EAC3B;AACJ"}