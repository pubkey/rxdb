{"version":3,"file":"rx-storage.interface.d.js","names":[],"sources":["../../../src/types/rx-storage.interface.d.ts"],"sourcesContent":["import type {\n    DeterministicSortComparator,\n    QueryMatcher\n} from 'event-reduce-js';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PreparedQuery,\n    RxDocumentData,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult\n} from './rx-storage';\nimport type {\n    MangoQuery,\n    MangoQuerySortPart,\n    RxJsonSchema\n} from './';\nimport type {\n    Observable\n} from 'rxjs';\n\n/**\n * RxStorage\n * This is an interface that abstracts the storage engine.\n * This allows us to use RxDB with different engines like PouchDB or LokiJS.\n *\n * Also see\n * @link https://github.com/pubkey/rxdb/issues/1636\n *\n */\n\n\n/**\n * A RxStorage is a module that acts\n * as a factory that can create multiple RxStorageInstance\n * objects.\n * \n * All data inputs and outputs of a StorageInstance must be plain json objects.\n * Do not use Map, Set or anything else that cannot be JSON.stringify-ed.\n * This will ensure that the storage can exchange data\n * when it is a WebWorker or a WASM process or data is send via BroadcastChannel.\n */\nexport interface RxStorage<Internals, InstanceCreationOptions> {\n    /**\n     * name of the storage engine\n     * used to detect if plugins do not work so we can throw propper errors.\n     */\n    readonly name: string;\n\n    /**\n     * Static functions\n     */\n    readonly statics: RxStorageStatics;\n\n    /**\n     * creates a storage instance\n     * that can contain the internal database\n     * For example the PouchDB instance\n     */\n    createStorageInstance<RxDocType>(\n        params: RxStorageInstanceCreationParams<RxDocType, InstanceCreationOptions>\n    ): Promise<RxStorageInstance<RxDocType, Internals, InstanceCreationOptions>>;\n}\n\n\n/**\n * User provided mango queries will be filled up by RxDB via normalizeMangoQuery()\n * so we do not have to do many if-field-exist tests in the internals.\n */\nexport type FilledMangoQuery<RxDocType> = MangoQuery<RxDocType> & {\n    /**\n * In contrast to the user-provided MangoQuery,\n * the sorting is required here because\n * RxDB has to ensure that the primary key is always\n * part of the sort params.\n */\n    sort: MangoQuerySortPart<RxDocType>[];\n\n    /**\n     * Skip must be set which defaults to 0\n     */\n    skip: number;\n}\n\n/**\n * Static functions of the RxStorage.\n * Can be used without creating an instance of any kind.\n * These functions are not directy childs of RxStorage because\n * we might need them without having to import the whole storage engine.\n * For example when the Worker plugin is used, the main process only needs the\n * static functions, while the worker process needs the whole storage engine.\n */\nexport type RxStorageStatics = Readonly<{\n    /**\n     * Returns a hash of the given value.\n     * Used to check equalness of attachments data and other stuff.\n     * Pouchdb uses md5 but we can use whatever we want as long as each\n     * storage class returns the same hash each time.\n     */\n    hash(data: Buffer | Blob | string): Promise<string>;\n\n    /**\n     * Key of the used hash algorithm.\n     * Like 'md5' or 'sha1'.\n     */\n    hashKey: string;\n\n    /**\n     * A function that returns true\n     * if the RxStorage does broadcast events between\n     * multiple instances, like multiple browser tabs\n     * or node.js processes.\n     * If this returns false, RxDB will use its own BroadcastChannel\n     * to ensure all other instances know about changes.\n     * If it returns true, RxDB will not broadcast the events\n     * to save performance.\n     */\n    doesBroadcastChangestream(): boolean;\n\n    /**\n     * PouchDB and others have some bugs\n     * and behaviors that must be worked arround\n     * before querying the db.\n     * \n     * Also some storages do optimizations\n     * and other things related to query planning.\n     * \n     * For performance reason this preparation\n     * runs in a single step so it can be cached\n     * when the query is used multiple times.\n     *\n     * @returns a format of the query that can be used with the storage\n     * when calling .query()\n     */\n    prepareQuery<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        /**\n         * a query that can be mutated by the function without side effects.\n         */\n        mutateableQuery: FilledMangoQuery<RxDocType>\n    ): PreparedQuery<RxDocType>;\n\n    /**\n     * Returns the sort-comparator,\n     * which is able to sort documents in the same way\n     * a query over the db would do.\n     */\n    getSortComparator<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        preparedQuery: PreparedQuery<RxDocType>\n    ): DeterministicSortComparator<RxDocType>;\n\n    /**\n     * Returns a function\n     * that can be used to check if a document\n     * matches the query.\n     *  \n     */\n    getQueryMatcher<RxDocType>(\n        schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        preparedQuery: PreparedQuery<RxDocType>\n    ): QueryMatcher<RxDocumentData<RxDocType>>;\n}>;\n\n\n\nexport interface RxStorageInstance<\n    /**\n     * The type of the documents that can be stored in this instance.\n     * All documents in an instance must comply to the same schema.\n     * Also all documents are RxDocumentData with the meta properties like\n     * _deleted or _rev etc.\n     */\n    RxDocType,\n    Internals,\n    InstanceCreationOptions\n    > {\n\n    /**\n     * The RxStorage which was used to create the given instance.\n     * We need this here to make it easy to get access static methods and stuff\n     * when working with the RxStorageInstance.\n     */\n    readonly storage: RxStorage<Internals, InstanceCreationOptions>;\n\n    readonly databaseName: string;\n    /**\n     * Returns the internal data that is used by the storage engine.\n     * For example the pouchdb instance.\n     */\n    readonly internals: Readonly<Internals>;\n    readonly options: Readonly<InstanceCreationOptions>;\n    /**\n     * The schema that defines the documents that are stored in this instance.\n     * Notice that the schema must be enhanced with the meta properties like\n     * _meta, _rev and _deleted etc. which are added by fillWithDefaultSettings()\n     */\n    readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>;\n    readonly collectionName: string;\n\n    /**\n     * Writes multiple documents to the storage instance.\n     * The write for each single document is atomic, there\n     * is no transaction arround all documents.\n     * The written documents must be the newest revision of that documents data.\n     * If the previous document is not the current newest revision, a conflict error\n     * must be returned.\n     * It must be possible that some document writes succeed\n     * and others error. We need this to have a similar behavior as most NoSQL databases.\n     */\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[]\n    ): Promise<\n        /**\n         * returns the response, splitted into success and error lists.\n         */\n        RxStorageBulkWriteResponse<RxDocType>\n    >;\n\n    /**\n     * Get Multiple documents by their primary value.\n     * This must also return deleted documents.\n     */\n    findDocumentsById(\n        /**\n         * List of primary values\n         * of the documents to find.\n         */\n        ids: string[],\n        /**\n         * If set to true, deleted documents will also be returned.\n         */\n        withDeleted: boolean\n    ): Promise<{\n        [documentId: string]: RxDocumentData<RxDocType>\n    }>;\n\n    /**\n     * Runs a NoSQL 'mango' query over the storage\n     * and returns the found documents data.\n     * Having all storage instances behave similar\n     * is likely the most difficult thing when creating a new\n     * rx-storage implementation. Atm we use the pouchdb-find plugin\n     * as reference to how NoSQL-queries must work.\n     * But the past has shown that pouchdb find can behave wrong,\n     * which must be fixed or at least documented.\n     */\n    query(\n        /**\n         * Here we get the result of this.prepareQuery()\n         * instead of the plain mango query.\n         * This makes it easier to have good performance\n         * when transformations of the query must be done.\n         */\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>>;\n\n\n    /**\n     * Returns the plain data of a single attachment.\n     */\n    getAttachmentData(\n        documentId: string,\n        attachmentId: string\n    ): Promise<string>;\n\n\n    /**\n     * Returns the current (not the old!) data of all documents that have been changed AFTER the given checkpoint.\n     * If the returned array does not reach the limit, it can be assumed that the \"end\" is reached, when paginating over the changes.\n     * Also returns a new checkpoint for each document which can be used to continue with the pagination from that change on.\n     * Must never return the same document multiple times in the same call operation.\n     * This is used by RxDB to known what has changed since X so these docs can be handled by the backup or the replication\n     * plugin.\n     */\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: any\n    ): Promise<{\n        document: RxDocumentData<RxDocType>;\n        /**\n         * For each document, an own checkpoint is returned.\n         * This is usefull when RxDB does only need a part of the returned changes\n         * but still wants to be able to continue the pagination\n         * from the correct document on.\n         */\n        checkpoint: any;\n    }[]>;\n\n    /**\n     * Returns an ongoing stream\n     * of all changes that happen to the\n     * storage instance.\n     * Do not forget to unsubscribe.\n     */\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>>;\n\n    /**\n     * Runs a cleanup that removes all tompstones\n     * of documents that have _deleted set to true\n     * to free up disc space.\n     * \n     * Returns true if all cleanable documents have been removed.\n     * Returns false if there are more documents to be cleaned up,\n     * but not all have been purged because that would block the storage for too long.\n     */\n    cleanup(\n        /**\n         * The minimum time in milliseconds\n         * of how long a document must have been deleted\n         * until it is purged by the cleanup.\n         */\n        minimumDeletedTime: number\n    ): Promise<\n        /**\n         * True if all docs cleaned up,\n         * false if there are more docs to clean up\n         */\n        boolean\n    >;\n\n    /**\n     * Closes the storage instance so it cannot be used\n     * anymore and should clear all memory.\n     * The returned promise must resolve when everything is cleaned up.\n     */\n    close(): Promise<void>;\n\n    /**\n     * Remove the database and\n     * deletes all of its data.\n     */\n    remove(): Promise<void>;\n}\n"],"mappings":""}