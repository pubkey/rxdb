{"version":3,"file":"replication.d.js","names":[],"sources":["../../../../src/types/plugins/replication.d.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport type {\n    InternalStoreDocType,\n    MaybePromise,\n    RxCollection,\n    RxDocumentData,\n    RxReplicationPullStreamItem,\n    RxReplicationWriteToMasterRow,\n    WithDeleted\n} from '../../types';\n\n\nexport type InternalStoreReplicationPushDocType = InternalStoreDocType<{\n    checkpoint: any;\n}>;\nexport type InternalStoreReplicationPullDocType<RxDocType> = InternalStoreDocType<{\n    lastPulledDoc: RxDocumentData<RxDocType>;\n}>;\n\nexport type ReplicationPullHandlerResult<RxDocType, CheckpointType> = {\n    checkpoint: CheckpointType;\n    documents: WithDeleted<RxDocType>[];\n};\n\nexport type ReplicationPushHandlerResult<RxDocType> = RxDocType[];\n\nexport type ReplicationPullHandler<RxDocType, CheckpointType> = (\n    lastPulledCheckpoint: CheckpointType,\n    batchSize: number\n) => Promise<ReplicationPullHandlerResult<RxDocType, CheckpointType>>;\nexport type ReplicationPullOptions<RxDocType, CheckpointType> = {\n    /**\n     * A handler that pulls the new remote changes\n     * from the remote actor.\n     */\n    handler: ReplicationPullHandler<RxDocType, CheckpointType>;\n\n\n    /**\n     * An observable that streams all document changes\n     * that are happening on the backend.\n     * Emits an document bulk together with the latest checkpoint of these documents.\n     * Also can emit a 'RESYNC' event when the client was offline and is online again.\n     *\n     * Not required for non-live replication.\n     */\n    stream$?: Observable<RxReplicationPullStreamItem<RxDocType, CheckpointType>>;\n\n    /**\n     * Amount of documents that the remote will send in one request.\n     * If the response contains less then [batchSize] documents,\n     * RxDB will assume there are no more changes on the backend\n     * that are not replicated.\n     * [default=100]\n     */\n    batchSize?: number;\n\n    /**\n     * A modifier that runs on all documents that are pulled,\n     * before they are used by RxDB.\n     * - the ones from the pull handler\n     * - the ones from the pull stream\n     */\n    modifier?: (docData: any) => MaybePromise<WithDeleted<RxDocType>>;\n};\n\n/**\n * Gets the new write rows.\n * Returns the current master state of all conflicting writes,\n * so that they can be resolved on the client.\n */\nexport type ReplicationPushHandler<RxDocType> = (\n    docs: RxReplicationWriteToMasterRow<RxDocType>[]\n) => Promise<WithDeleted<RxDocType>[]>;\nexport type ReplicationPushOptions<RxDocType> = {\n    /**\n     * A handler that sends the new local changes\n     * to the remote actor.\n     * On error, all documents are send again at later time.\n     */\n    handler: ReplicationPushHandler<RxDocType>;\n\n\n    /**\n     * A modifier that runs on all pushed documents before\n     * they are send into the push handler.\n     */\n    modifier?: (docData: WithDeleted<RxDocType>) => MaybePromise<any>;\n\n    /**\n     * How many local changes to process at once.\n     */\n    batchSize?: number;\n};\n\n\nexport type ReplicationOptions<RxDocType, CheckpointType> = {\n    /**\n     * An id for the replication to identify it\n     * and so that RxDB is able to resume the replication on app reload.\n     * If you replicate with a remote server, it is recommended to put the\n     * server url into the replicationIdentifier.\n     * Like 'my-rest-replication-to-https://example.com/api/sync'\n     */\n    replicationIdentifier: string;\n    collection: RxCollection<RxDocType, any, any, any>;\n    /**\n     * Define a custom property that is used\n     * to flag a document as being deleted.\n     * @default '_deleted'\n     */\n    deletedField?: '_deleted' | string;\n    pull?: ReplicationPullOptions<RxDocType, CheckpointType>;\n    push?: ReplicationPushOptions<RxDocType>;\n    /**\n     * By default it will do an ongoing realtime replication.\n     * By settings live: false the replication will run once until the local state\n     * is in sync with the remote state, then it will cancel itself.\n     * @default true\n     */\n    live?: boolean;\n    /**\n     * Time in milliseconds after when a failed backend request\n     * has to be retried.\n     * This time will be skipped if a offline->online switch is detected\n     * via `navigator.onLine`\n     * @default 5000\n     */\n    retryTime?: number;\n    /**\n     * When multiInstance is `true`, like when you use RxDB in multiple browser tabs,\n     * the replication should always run in only one of the open browser tabs.\n     * If waitForLeadership is `true`, it will wait until the current instance is leader.\n     * If waitForLeadership is `false`, it will start replicating, even if it is not leader.\n     * @default true\n     */\n    waitForLeadership?: boolean;\n    /**\n     * If this is set to `false`,\n     * the replication will not start automatically\n     * but will wait for `replicationState.start()` being called.\n     * @default true\n     */\n    autoStart?: boolean;\n};\n"],"mappings":""}