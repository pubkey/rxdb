{"version":3,"file":"replication.d.js","names":[],"sources":["../../../../src/types/plugins/replication.d.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport type {\n    InternalStoreDocType,\n    MaybePromise,\n    RxCollection,\n    RxDocumentData,\n    RxReplicationPullStreamItem,\n    RxReplicationWriteToMasterRow,\n    WithDeleted\n} from '../../types';\n\n\nexport type InternalStoreReplicationPushDocType = InternalStoreDocType<{\n    checkpoint: any;\n}>;\nexport type InternalStoreReplicationPullDocType<RxDocType> = InternalStoreDocType<{\n    lastPulledDoc: RxDocumentData<RxDocType>;\n}>;\n\nexport type ReplicationPullHandlerResult<RxDocType> = {\n    checkpoint: any;\n    documents: WithDeleted<RxDocType>[];\n};\n\nexport type ReplicationPullHandler<RxDocType, CheckpointType> = (lastPulledCheckpoint: CheckpointType, batchSize: number) => Promise<ReplicationPullHandlerResult<RxDocType>>;\nexport type ReplicationPullOptions<RxDocType, CheckpointType> = {\n    /**\n     * A handler that pulls the new remote changes\n     * from the remote actor.\n     */\n    handler: ReplicationPullHandler<RxDocType, CheckpointType>;\n\n\n    /**\n     * An observable that streams all document changes\n     * that are happening on the backend.\n     * Emits an document bulk together with the latest checkpoint of these documents.\n     * Also can emit a 'RESYNC' event when the client was offline and is online again.\n     * \n     * Not required for non-live replication.\n     */\n    stream$?: Observable<RxReplicationPullStreamItem<RxDocType, CheckpointType>>;\n\n    /**\n     * Amount of documents that the remote will send in one request.\n     * If the response contains less then [batchSize] documents,\n     * RxDB will assume there are no more changes on the backend\n     * that are not replicated.\n     * [default=100]\n     */\n    batchSize?: number;\n\n    /**\n     * A modifier that runs on all documents that are pulled,\n     * before they are used by RxDB.\n     * - the ones from the pull handler\n     * - the ones from the pull stream\n     */\n    modifier?: (docData: any) => MaybePromise<WithDeleted<RxDocType>>;\n};\n\n/**\n * Gets the new write rows.\n * Returns the current master state of all conflicting writes,\n * so that they can be resolved on the client.\n */\nexport type ReplicationPushHandler<RxDocType> = (docs: RxReplicationWriteToMasterRow<RxDocType>[]) => Promise<WithDeleted<RxDocType>[]>;\nexport type ReplicationPushOptions<RxDocType> = {\n    /**\n     * A handler that sends the new local changes\n     * to the remote actor.\n     * On error, all documents are send again at later time.\n     */\n    handler: ReplicationPushHandler<RxDocType>;\n\n\n    /**\n     * A modifier that runs on all pushed documents before\n     * they are send into the push handler.\n     */\n    modifier?: (docData: WithDeleted<RxDocType>) => MaybePromise<any>;\n\n    /**\n     * How many local changes to process at once.\n     */\n    batchSize?: number;\n}\n\n\nexport type ReplicationOptions<RxDocType, CheckpointType> = {\n    /**\n     * An id for the replication to identify it\n     * and so that RxDB is able to resume the replication on app reload.\n     * If you replicate with a remote server, it is recommended to put the\n     * server url into the replicationIdentifier.\n     * Like 'my-rest-replication-to-https://example.com/rest'\n     */\n    replicationIdentifier: string;\n    collection: RxCollection<RxDocType>;\n    /**\n     * Define a custom property that is used\n     * to flag a document as being deleted.\n     * [default='_deleted']\n     */\n    deletedField?: '_deleted' | string;\n    pull?: ReplicationPullOptions<RxDocType, CheckpointType>;\n    push?: ReplicationPushOptions<RxDocType>;\n    /**\n     * default=false\n     */\n    live?: boolean;\n    /**\n     * Time in milliseconds\n     */\n    retryTime?: number;\n    /**\n     * If set to false,\n     * it will not wait until the current instance becomes leader.\n     * This means it can happen that multiple browser tabs\n     * run the replication at the same time which is dangerous.\n     */\n    waitForLeadership?: boolean; // default=true\n    /**\n     * Calling `replicateRxCollection()` implies to run a replication.\n     * If set to false, it will not run replication on `replicateRxCollection()`.\n     * This means you need to call replicationState.run() to trigger the first replication.\n     */\n    autoStart?: boolean; // default=true\n}\n"],"mappings":""}