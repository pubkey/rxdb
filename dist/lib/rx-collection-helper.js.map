{"version":3,"sources":["../../src/rx-collection-helper.ts"],"names":["writeToStorageInstance","collection","writeRow","overwrite","toStorageInstance","previous","_handleToStorageInstance","undefined","document","database","lockedRun","storageInstance","writeResult","ret","_handleFromStorageInstance","useErr","primary","documentId","status","singleRes","args","name","id","pouchDbError","data","col","overwritable","isDevMode","schema","fillPrimaryKey","_crypter","encrypt","hookParams","doc","noDecrypt","decrypt","fillObjectDataBeforeInsert","useJson","fillObjectWithDefaults","getCollectionLocalInstanceName","collectionName","createRxCollectionStorageInstances","rxDatabase","storageInstanceCreationParams","instanceCreationOptions","broadcastChannel","Promise","all","storage","createStorageInstance","createKeyObjectStorageInstance","databaseName","options","idleQueue","localDocumentsStore"],"mappings":";;;;;;;;;;;;;;;;;;AAUA;;AAGA;;AAGA;;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;SACsBA,sB;;;AAoDtB;AACA;AACA;AACA;;;;0GAvDO,kBACHC,UADG,EAEHC,QAFG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGHC,YAAAA,SAHG,8DAGkB,KAHlB;AAOGC,YAAAA,iBAPH,GAO0C;AACzCC,cAAAA,QAAQ,EAAEH,QAAQ,CAACG,QAAT,GAAoBC,wBAAwB,CAACL,UAAD,EAAa,qBAAUC,QAAQ,CAACG,QAAnB,CAAb,CAA5C,GAAyFE,SAD1D;AAEzCC,cAAAA,QAAQ,EAAEF,wBAAwB,CAACL,UAAD,EAAa,qBAAUC,QAAQ,CAACM,QAAnB,CAAb;AAFO,aAP1C;;AAAA;AAAA,iBAYI,IAZJ;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mBAc+BP,UAAU,CAACQ,QAAX,CAAoBC,SAApB,CACtB;AAAA,qBAAM,kCACFT,UAAU,CAACU,eADT,EAEFP,iBAFE,CAAN;AAAA,aADsB,CAd/B;;AAAA;AAcWQ,YAAAA,WAdX;AAoBK;AAEMC,YAAAA,GAtBX,GAsBiBC,0BAA0B,CAACb,UAAD,EAAaW,WAAb,CAtB3C;AAAA,8CAuBYC,GAvBZ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBWE,sBAAAA,MAzBX;AA0BWC,sBAAAA,OA1BX,GA0BqBD,MAAM,CAACE,UA1B5B;;AAAA,4BA2BSd,SAAS,IAAIY,MAAM,CAACG,MAAP,KAAkB,GA3BxC;AAAA;AAAA;AAAA;;AAAA;AAAA,6BA8BiCjB,UAAU,CAACQ,QAAX,CAAoBC,SAApB,CACpB;AAAA,+BAAM,wCAAkBT,UAAU,CAACU,eAA7B,EAA8CK,OAA9C,CAAN;AAAA,uBADoB,CA9BjC;;AAAA;AA8BeG,sBAAAA,SA9Bf;;AAAA,0BAiCcA,SAjCd;AAAA;AAAA;AAAA;;AAAA,4BAkCmB,yBAAW,KAAX,EAAkB;AAAEC,wBAAAA,IAAI,EAAE;AAAElB,0BAAAA,QAAQ,EAARA;AAAF;AAAR,uBAAlB,CAlCnB;;AAAA;AAoCSE,sBAAAA,iBAAiB,CAACC,QAAlB,GAA6Bc,SAA7B,CApCT,CAqCS;;AArCT;AAAA;;AAAA;AAAA,4BAsCgBJ,MAAM,CAACG,MAAP,KAAkB,GAtClC;AAAA;AAAA;AAAA;;AAAA,4BAuCe,yBAAW,OAAX,EAAoB;AACtBjB,wBAAAA,UAAU,EAAEA,UAAU,CAACoB,IADD;AAEtBC,wBAAAA,EAAE,EAAEN,OAFkB;AAGtBO,wBAAAA,YAAY,EAAER,MAHQ;AAItBS,wBAAAA,IAAI,EAAEtB;AAJgB,uBAApB,CAvCf;;AAAA;AAAA,4BA8Cea,MA9Cf;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAwDA,SAAST,wBAAT,CACHmB,GADG,EAEHD,IAFG,EAGL;AACE;AACA,MAAIE,2BAAaC,SAAb,EAAJ,EAA8B;AAC1BF,IAAAA,GAAG,CAACG,MAAJ,CAAWC,cAAX,CAA0BL,IAA1B;AACH;;AAEDA,EAAAA,IAAI,GAAIC,GAAG,CAACK,QAAL,CAAsBC,OAAtB,CAA8BP,IAA9B,CAAP;AAEA,MAAMQ,UAAU,GAAG;AACf/B,IAAAA,UAAU,EAAEwB,GADG;AAEfQ,IAAAA,GAAG,EAAET;AAFU,GAAnB;AAIA,6BAAe,2BAAf,EAA4CQ,UAA5C;AAEA,SAAOA,UAAU,CAACC,GAAlB;AACH;;AAEM,SAASnB,0BAAT,CACHW,GADG,EAEHD,IAFG,EAIL;AAAA,MADEU,SACF,uEADc,KACd;AAEE,MAAMF,UAAU,GAAG;AACf/B,IAAAA,UAAU,EAAEwB,GADG;AAEfQ,IAAAA,GAAG,EAAET;AAFU,GAAnB;AAIA,6BAAe,sBAAf,EAAuCQ,UAAvC;;AAEA,MAAIE,SAAJ,EAAe;AACX,WAAOF,UAAU,CAACC,GAAlB;AACH;;AAED,SAAQR,GAAG,CAACK,QAAL,CAAsBK,OAAtB,CAA8BH,UAAU,CAACC,GAAzC,CAAP;AACH;AAED;AACA;AACA;AACA;;;AACO,SAASG,0BAAT,CACHnC,UADG,EAEHuB,IAFG,EAGA;AACH,MAAIa,OAAO,GAAGpC,UAAU,CAAC2B,MAAX,CAAkBU,sBAAlB,CAAyCd,IAAzC,CAAd;AACAa,EAAAA,OAAO,GAAGpC,UAAU,CAAC2B,MAAX,CAAkBC,cAAlB,CAAiCQ,OAAjC,CAAV;AAEA,SAAOA,OAAP;AACH;;AAGM,SAASE,8BAAT,CAAwCC,cAAxC,EAAwE;AAC3E,SAAOA,cAAc,GAAG,QAAxB;AACH;AAED;AACA;AACA;;;SACsBC,kC;;;;;sHAAf,kBACHD,cADG,EAEHE,UAFG,EAGHC,6BAHG,EAIHC,uBAJG;AAAA;;AAAA;AAAA;AAAA;AAAA;AAUHD,YAAAA,6BAA6B,CAACE,gBAA9B,GAAiDH,UAAU,CAACG,gBAA5D;AAVG;AAAA,mBAeOC,OAAO,CAACC,GAAR,CAAY,CAClBL,UAAU,CAACM,OAAX,CAAmBC,qBAAnB,CACIN,6BADJ,CADkB,EAIlBD,UAAU,CAACM,OAAX,CAAmBE,8BAAnB,CAAkD;AAC9CC,cAAAA,YAAY,EAAET,UAAU,CAACrB,IADqB;;AAE9C;AACZ;AACA;AACA;AACA;AACYmB,cAAAA,cAAc,EAAED,8BAA8B,CAACC,cAAD,CAPA;AAQ9CY,cAAAA,OAAO,EAAER,uBARqC;AAS9CS,cAAAA,SAAS,EAAEX,UAAU,CAACW,SATwB;AAU9CR,cAAAA,gBAAgB,EAAEH,UAAU,CAACG;AAViB,aAAlD,CAJkB,CAAZ,CAfP;;AAAA;AAAA;AAaClC,YAAAA,eAbD;AAcC2C,YAAAA,mBAdD;AAAA,8CAiCI;AACH3C,cAAAA,eAAe,EAAfA,eADG;AAEH2C,cAAAA,mBAAmB,EAAnBA;AAFG,aAjCJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import type {\n    BulkWriteRow,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxStorageBulkWriteError,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageKeyObjectInstance\n} from './types';\nimport {\n    flatClone\n} from './util';\nimport {\n    newRxError\n} from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { getSingleDocument, writeSingle } from './rx-storage-helper';\nimport { RxCollectionBase } from './rx-collection';\nimport { overwritable } from './overwritable';\n\n\n/**\n * Every write access on the storage engine,\n * goes throught this method\n * so we can run hooks and resolve stuff etc.\n */\nexport async function writeToStorageInstance<RxDocumentType>(\n    collection: RxCollection<RxDocumentType, any> | RxCollectionBase<any, RxDocumentType, any>,\n    writeRow: BulkWriteRow<RxDocumentType>,\n    overwrite: boolean = false\n): Promise<\n    RxDocumentData<RxDocumentType>\n> {\n    const toStorageInstance: BulkWriteRow<any> = {\n        previous: writeRow.previous ? _handleToStorageInstance(collection, flatClone(writeRow.previous)) : undefined,\n        document: _handleToStorageInstance(collection, flatClone(writeRow.document))\n    };\n\n    while (true) {\n        try {\n            const writeResult = await collection.database.lockedRun(\n                () => writeSingle(\n                    collection.storageInstance,\n                    toStorageInstance\n                )\n            );\n            // on success, just return the result\n\n            const ret = _handleFromStorageInstance(collection, writeResult);\n            return ret;\n        } catch (err: any) {\n            const useErr: RxStorageBulkWriteError<RxDocumentType> = err as any;\n            const primary = useErr.documentId;\n            if (overwrite && useErr.status === 409) {\n                // we have a conflict but must overwrite\n                // so get the new revision\n                const singleRes = await collection.database.lockedRun(\n                    () => getSingleDocument(collection.storageInstance, primary)\n                );\n                if (!singleRes) {\n                    throw newRxError('SNH', { args: { writeRow } });\n                }\n                toStorageInstance.previous = singleRes;\n                // now we can retry\n            } else if (useErr.status === 409) {\n                throw newRxError('COL19', {\n                    collection: collection.name,\n                    id: primary,\n                    pouchDbError: useErr,\n                    data: writeRow\n                });\n            } else {\n                throw useErr;\n            }\n        }\n    }\n}\n\n/**\n * wrappers to process document data beofre/after it goes to the storage instnace.\n * Used to handle keycompression, encryption etc\n */\nexport function _handleToStorageInstance(\n    col: RxCollection | RxCollectionBase<any, any, any>,\n    data: any\n) {\n    // ensure primary key has not been changed\n    if (overwritable.isDevMode()) {\n        col.schema.fillPrimaryKey(data);\n    }\n\n    data = (col._crypter as any).encrypt(data);\n\n    const hookParams = {\n        collection: col,\n        doc: data\n    };\n    runPluginHooks('preWriteToStorageInstance', hookParams);\n\n    return hookParams.doc;\n}\n\nexport function _handleFromStorageInstance(\n    col: RxCollection | RxCollectionBase<any, any, any>,\n    data: any,\n    noDecrypt = false\n) {\n\n    const hookParams = {\n        collection: col,\n        doc: data\n    };\n    runPluginHooks('postReadFromInstance', hookParams);\n\n    if (noDecrypt) {\n        return hookParams.doc;\n    }\n\n    return (col._crypter as any).decrypt(hookParams.doc);\n}\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert(\n    collection: RxCollection | RxCollectionBase<any>,\n    data: any\n): any {\n    let useJson = collection.schema.fillObjectWithDefaults(data);\n    useJson = collection.schema.fillPrimaryKey(useJson);\n\n    return useJson;\n}\n\n\nexport function getCollectionLocalInstanceName(collectionName: string): string {\n    return collectionName + '-local';\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstances<RxDocumentType, Internals, InstanceCreationOptions>(\n    collectionName: string,\n    rxDatabase: RxDatabase,\n    storageInstanceCreationParams: RxStorageInstanceCreationParams<RxDocumentType, InstanceCreationOptions>,\n    instanceCreationOptions: InstanceCreationOptions\n): Promise<{\n    storageInstance: RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>,\n    localDocumentsStore: RxStorageKeyObjectInstance<any, InstanceCreationOptions>\n}> {\n\n    storageInstanceCreationParams.broadcastChannel = rxDatabase.broadcastChannel;\n\n    const [\n        storageInstance,\n        localDocumentsStore\n    ] = await Promise.all([\n        rxDatabase.storage.createStorageInstance<RxDocumentType>(\n            storageInstanceCreationParams\n        ),\n        rxDatabase.storage.createKeyObjectStorageInstance({\n            databaseName: rxDatabase.name,\n            /**\n             * Use a different collection name for the local documents instance\n             * so that the local docs can be kept while deleting the normal instance\n             * after migration.\n             */\n            collectionName: getCollectionLocalInstanceName(collectionName),\n            options: instanceCreationOptions,\n            idleQueue: rxDatabase.idleQueue,\n            broadcastChannel: rxDatabase.broadcastChannel\n        })\n    ]);\n\n    return {\n        storageInstance,\n        localDocumentsStore\n    };\n}\n"],"file":"rx-collection-helper.js"}