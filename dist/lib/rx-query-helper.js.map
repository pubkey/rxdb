{"version":3,"file":"rx-query-helper.js","names":["normalizeMangoQuery","schema","mangoQuery","primaryKey","getPrimaryFieldOfPrimaryKey","normalizedMangoQuery","flatClone","skip","selector","Object","entries","forEach","field","matcher","$eq","index","indexAr","Array","isArray","slice","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","LOGICAL_OPERATORS","has","add","currentFieldsAmount","currentBestIndexForSort","useIndex","isMaybeReadonlyArray","firstWrongIndex","findIndex","indexField","isPrimaryInSort","p","firstPropertyNameOfObject"],"sources":["../../src/rx-query-helper.ts"],"sourcesContent":["import { LOGICAL_OPERATORS } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport type {\n    FilledMangoQuery,\n    MangoQuery,\n    RxDocumentData,\n    RxJsonSchema\n} from './types';\nimport {\n    firstPropertyNameOfObject,\n    flatClone,\n    isMaybeReadonlyArray\n} from './util';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = flatClone(mangoQuery) as any;\n\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = flatClone(normalizedMangoQuery.selector);\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    normalizedMangoQuery.selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = Array.isArray(normalizedMangoQuery.index) ? normalizedMangoQuery.index.slice(0) : [normalizedMangoQuery.index];\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similar to how we add the primary key to indexes that do not have it.\n     * \n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         * \n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => ({ [field as any]: 'asc' } as any));\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => ({ [field as any]: 'asc' } as any));\n                }\n\n            }\n\n            /**\n             * Fall back to the primary key as sort order\n             * if no better one has been found\n             */\n            if (!normalizedMangoQuery.sort) {\n                normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n"],"mappings":"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"}