{"version":3,"file":"rx-query.js","names":["queryCollection","rxQuery","docs","collection","isFindOneByIdQuery","docId","storageInstance","findDocumentsById","docsMap","docData","push","preparedQuery","getPreparedQuery","query","queryResult","documents","_queryCount","newQueryID","RxQueryBase","op","mangoQuery","id","_execOverDatabaseCount","_creationTime","now","_lastEnsureEqual","other","uncached","refCount$","BehaviorSubject","_result","_latestChangeEvent","_lastExecStart","_lastExecEnd","_ensureEqualQueue","PROMISE_RESOLVE_FALSE","_getDefaultQuery","schema","primaryPath","_setResultData","newResultData","createRxDocuments","primPath","docsDataMap","Map","docsData","map","doc","_dataSync$","getValue","set","time","_execOverDatabase","docsPromise","then","exec","throwIfMissing","newRxError","name","_ensureEqual","firstValueFrom","$","result","toString","stringObj","sortObject","value","JSON","stringify","stringifyFilter","hookInput","normalizeMangoQuery","jsonSchema","clone","runPluginHooks","database","storage","statics","prepareQuery","doesDocumentDataMatch","_deleted","queryMatcher","remove","ret","Array","isArray","Promise","all","update","_updateObj","pluginMissing","where","_queryObj","sort","_params","skip","_amount","limit","_$","results$","pipe","filter","changeEvent","isLocal","startWith","mergeMap","shareReplay","RXJS_SHARE_REPLAY_DEFAULTS","distinctUntilChanged","prev","curr","ensureNotFalsy","useResult","length","slice","merge","usePreparedQuery","overwriteGetterForCaching","getQueryMatcher","selector","tunnelQueryCache","_queryCache","getByQuery","createRxQuery","queryObj","triggerCacheReplacement","_isResultsInSync","currentLatestEventNumber","asRxQuery","_changeEventBuffer","counter","destroyed","__ensureEqual","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","eventReduceResult","calculateNewResults","runFullQueryAgain","changed","newResults","latestAfter","deepEqual","resolve","Object","keys","$eq","isInstanceOf","obj"],"sources":["../../src/rx-query.ts"],"sourcesContent":["import deepEqual from 'fast-deep-equal';\nimport {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    sortObject,\n    stringifyFilter,\n    pluginMissing,\n    clone,\n    overwriteGetterForCaching,\n    now,\n    PROMISE_RESOLVE_FALSE,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    ensureNotFalsy\n} from './util';\nimport {\n    newRxError\n} from './rx-error';\nimport {\n    runPluginHooks\n} from './hooks';\nimport type {\n    RxCollection,\n    RxDocument,\n    RxQueryOP,\n    RxQuery,\n    MangoQuery,\n    MangoQuerySortPart,\n    MangoQuerySelector,\n    PreparedQuery,\n    RxChangeEvent,\n    RxDocumentWriteData,\n    RxDocumentData\n} from './types';\n\nimport {\n    createRxDocuments\n} from './rx-document-prototype-merge';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nimport type { QueryMatcher } from 'event-reduce-js';\nimport { normalizeMangoQuery } from './rx-query-helper';\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\nexport class RxQueryBase<\n    RxDocumentType = any,\n    // TODO also pass DocMethods here\n    RxQueryResult = RxDocument<RxDocumentType>[] | RxDocument<RxDocumentType>\n    > {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    // used by some plugins\n    public other: any = {};\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string;\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: {\n        docsData: RxDocumentType[];\n        // A key->document map, used in the event reduce optimization.\n        docsDataMap: Map<string, RxDocumentType>;\n        docs: RxDocument<RxDocumentType>[];\n        /**\n         * Time at which the current _result state was created.\n         * Used to determine if the result set has changed since X\n         * so that we do not emit the same result multiple times on subscription.\n         */\n        time: number;\n    } | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery>,\n        public collection: RxCollection<RxDocumentType>\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): BehaviorSubject<RxQueryResult> {\n        if (!this._$) {\n\n            const results$ = this.collection.$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(changeEvent => !changeEvent.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    const useResult = ensureNotFalsy(result);\n                    if (this.op === 'findOne') {\n                        // findOne()-queries emit RxDocument or null\n                        return useResult.docs.length === 0 ? null : useResult.docs[0];\n                    } else {\n                        // find()-queries emit RxDocument[]\n                        // Flat copy the array so it wont matter if the user modifies it.\n                        return useResult.docs.slice(0);\n                    }\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    public _lastExecStart: number = 0;\n    public _lastExecEnd: number = 0;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from pouchdb\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocumentType[]>): void {\n        const docs = createRxDocuments<RxDocumentType, {}>(\n            this.collection,\n            newResultData\n        );\n\n        /**\n         * Instead of using the newResultData in the result cache,\n         * we directly use the objects that are stored in the RxDocument\n         * to ensure we do not store the same data twice and fill up the memory.\n         */\n        const primPath = this.collection.schema.primaryPath;\n        const docsDataMap = new Map();\n        const docsData = docs.map(doc => {\n            const docData: RxDocumentData<RxDocumentType> = doc._dataSync$.getValue() as any;\n            const id: string = docData[primPath] as any;\n            docsDataMap.set(id, docData);\n            return docData;\n        });\n\n        this._result = {\n            docsData,\n            docsDataMap,\n            docs,\n            time: now()\n        }\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    _execOverDatabase(): Promise<RxDocumentData<RxDocumentType>[]> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        this._lastExecStart = now();\n\n        const docsPromise = queryCollection<RxDocumentType>(this as any);\n        return docsPromise.then(docs => {\n            this._lastExecEnd = now();\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocumentType>>;\n    public exec(): Promise<RxQueryResult>;\n    public exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        return _ensureEqual(this)\n            .then(() => firstValueFrom(this.$))\n            .then(result => {\n                if (!result && throwIfMissing) {\n                    throw newRxError('QU10', {\n                        collection: this.collection.name,\n                        query: this.mangoQuery,\n                        op: this.op\n                    });\n                } else {\n                    return result;\n                }\n            });\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocumentType>> {\n        const schema = this.collection.schema.jsonSchema;\n\n\n        /**\n         * Instead of calling this.getPreparedQuery(),\n         * we have to prepare the query for the query matcher\n         * so that it does not contain modifications from the hooks\n         * like the key compression.\n         */\n        const usePreparedQuery = this.collection.database.storage.statics.prepareQuery(\n            schema,\n            normalizeMangoQuery(\n                this.collection.schema.jsonSchema,\n                clone(this.mangoQuery)\n            )\n        );\n\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            this.collection.database.storage.statics.getQueryMatcher(\n                schema,\n                usePreparedQuery\n            )\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: this.mangoQuery,\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj, stringifyFilter);\n        this.toString = () => value;\n        return value;\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocumentType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocumentType>(\n                this.collection.schema.jsonSchema,\n                clone(this.mangoQuery)\n            )\n        };\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = this.collection.database.storage.statics.prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocumentType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    remove(): Promise<RxQueryResult> {\n        let ret: any;\n        return this\n            .exec()\n            .then(docs => {\n                ret = docs;\n                if (Array.isArray(docs)) {\n                    // TODO use a bulk operation instead of running .remove() on each document\n                    return Promise.all(docs.map(doc => doc.remove()));\n                } else {\n                    return (docs as any).remove();\n                }\n            })\n            .then(() => ret);\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocumentType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocumentType> | keyof RxDocumentType | string): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocumentType>): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocumentType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n}\n\nexport function _getDefaultQuery(): MangoQuery {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery(\n    op: RxQueryOP,\n    queryObj: MangoQuery,\n    collection: RxCollection\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection\n    });\n\n    let ret = new RxQueryBase(op, queryObj, collection);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery: RxQueryBase): Promise<boolean> {\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.destroyed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery: RxQueryBase): Promise<boolean> {\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.destroyed ||\n        // nothing happend since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n\n            const runChangeEvents: RxChangeEvent<any>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            const eventReduceResult = calculateNewResults(\n                rxQuery as any,\n                runChangeEvents\n            );\n            if (eventReduceResult.runFullQueryAgain) {\n                // could not calculate the new results, execute must be done\n                mustReExec = true;\n            } else if (eventReduceResult.changed) {\n                // we got the new results, we do not have to re-execute, mustReExec stays false\n                ret = true; // true because results changed\n                rxQuery._setResultData(eventReduceResult.newResults as any);\n            }\n        }\n    }\n\n\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        // counter can change while _execOverDatabase() is running so we save it here\n        const latestAfter: number = (rxQuery as any).collection._changeEventBuffer.counter;\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n                rxQuery._latestChangeEvent = latestAfter;\n                if (!rxQuery._result || !deepEqual(newResultData, rxQuery._result.docsData)) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            });\n    }\n    return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensuer findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType>\n): Promise<RxDocumentData<RxDocType>[]> {\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        const docId = rxQuery.isFindOneByIdQuery;\n        const docsMap = await collection.storageInstance.findDocumentsById([docId], false);\n        const docData = docsMap[docId];\n        if (docData) {\n            docs.push(docData);\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        docs = queryResult.documents;\n    }\n    return docs;\n\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string {\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        if (typeof query.selector[primaryPath] === 'string') {\n            return query.selector[primaryPath];\n        } else if (\n            Object.keys(query.selector[primaryPath]).length === 1 &&\n            typeof query.selector[primaryPath].$eq === 'string'\n        ) {\n            return query.selector[primaryPath].$eq;\n        }\n    }\n    return false;\n}\n\n\n\nexport function isInstanceOf(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n"],"mappings":"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"}