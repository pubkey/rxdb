{"version":3,"file":"key-compression.js","names":["COMPRESSION_STATE_BY_SCHEMA","WeakMap","getCompressionStateByRxJsonSchema","schema","overwritable","deepFreezeWhenDevMode","compressionState","get","compressionSchema","flatClone","primaryKey","table","createCompressionTable","DEFAULT_COMPRESSION_FLAG","getPrimaryFieldOfPrimaryKey","compressedSchema","createCompressedJsonSchema","composedPrimary","newComposedPrimary","key","compressedPath","fields","map","field","separator","indexes","newIndexes","idx","isMaybeReadonlyArray","subIdx","set","wrappedKeyCompressionStorage","args","statics","Object","assign","storage","prepareQuery","mutateableQuery","keyCompression","compressQuery","getSortComparator","preparedQuery","getQueryMatcher","createStorageInstance","params","modifyToStorage","docData","compressDocumentData","modifyFromStorage","decompressDocumentData","childSchema","instance","wrapRxStorageInstance","flatCloneDocWithMeta","attachments","_attachments","compressObject","decompressObject"],"sources":["../../../src/plugins/key-compression.ts"],"sourcesContent":["/**\n * this plugin adds the keycompression-capabilities to rxdb\n * if you dont use this, ensure that you set disableKeyComression to false in your schema\n */\n\nimport type {\n    DeterministicSortComparator,\n    QueryMatcher\n} from 'event-reduce-js';\nimport {\n    createCompressionTable,\n    CompressionTable,\n    JsonSchema as KeyCompressionJsonSchema,\n    compressObject,\n    decompressObject,\n    compressedPath,\n    DEFAULT_COMPRESSION_FLAG,\n    createCompressedJsonSchema,\n    compressQuery\n} from 'jsonschema-key-compression';\nimport {\n    overwritable\n} from '../overwritable';\nimport { wrapRxStorageInstance } from '../plugin-helpers';\nimport { getPrimaryFieldOfPrimaryKey } from '../rx-schema-helper';\nimport { flatCloneDocWithMeta } from '../rx-storage-helper';\n\nimport type {\n    RxJsonSchema,\n    CompositePrimaryKey,\n    RxStorage,\n    RxStorageInstanceCreationParams,\n    RxDocumentData,\n    RxStorageStatics,\n    FilledMangoQuery,\n    PreparedQuery\n} from '../types';\nimport {\n    flatClone,\n    isMaybeReadonlyArray\n} from '../util';\n\ndeclare type CompressionState = {\n    table: CompressionTable;\n    schema: RxJsonSchema<any>;\n    compressedSchema: RxJsonSchema<any>;\n};\n\n/**\n * Cache the compression table and the compressed schema\n * by the storage instance for better performance.\n */\nconst COMPRESSION_STATE_BY_SCHEMA: WeakMap<\n    RxJsonSchema<any>,\n    CompressionState\n> = new WeakMap();\n\n\nexport function getCompressionStateByRxJsonSchema(\n    schema: RxJsonSchema<any>\n): CompressionState {\n    /**\n     * Because we cache the state by the JsonSchema,\n     * it must be ausured that the given schema object\n     * is never mutated.\n     */\n    overwritable.deepFreezeWhenDevMode(schema);\n\n    let compressionState = COMPRESSION_STATE_BY_SCHEMA.get(schema);\n    if (!compressionState) {\n        const compressionSchema: KeyCompressionJsonSchema = flatClone(schema) as any;\n        delete (compressionSchema as any).primaryKey;\n\n        const table = createCompressionTable(\n            compressionSchema,\n            DEFAULT_COMPRESSION_FLAG,\n            [\n                /**\n                 * Do not compress the primary field\n                 * for easier debugging.\n                 */\n                getPrimaryFieldOfPrimaryKey(schema.primaryKey),\n                '_rev',\n                '_attachments',\n                '_deleted',\n                '_meta'\n            ]\n        );\n\n        delete (compressionSchema as any).primaryKey;\n        const compressedSchema: RxJsonSchema<any> = createCompressedJsonSchema(\n            table,\n            compressionSchema\n        ) as RxJsonSchema<any>;\n\n        // also compress primary key\n        if (typeof schema.primaryKey !== 'string') {\n            const composedPrimary: CompositePrimaryKey<any> = schema.primaryKey;\n            const newComposedPrimary: CompositePrimaryKey<any> = {\n                key: compressedPath(table, composedPrimary.key as string),\n                fields: composedPrimary.fields.map(field => compressedPath(table, field as string)),\n                separator: composedPrimary.separator\n            };\n            compressedSchema.primaryKey = newComposedPrimary;\n        } else {\n            compressedSchema.primaryKey = compressedPath(table, schema.primaryKey);\n        }\n\n        /**\n         * the key compression module does not know about indexes\n         * in the schema, so we have to also compress them here.\n         */\n        if (schema.indexes) {\n            const newIndexes = schema.indexes.map(idx => {\n                if (isMaybeReadonlyArray(idx)) {\n                    return idx.map(subIdx => compressedPath(table, subIdx));\n                } else {\n                    return compressedPath(table, idx);\n                }\n            });\n            compressedSchema.indexes = newIndexes;\n        }\n\n        compressionState = {\n            table,\n            schema,\n            compressedSchema\n        };\n        COMPRESSION_STATE_BY_SCHEMA.set(schema, compressionState);\n    }\n    return compressionState;\n}\n\nexport function wrappedKeyCompressionStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    const statics: RxStorageStatics = Object.assign(\n        {},\n        args.storage.statics,\n        {\n            prepareQuery<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                mutateableQuery: FilledMangoQuery<RxDocType>\n            ): PreparedQuery<RxDocType> {\n                if (schema.keyCompression) {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    mutateableQuery = compressQuery(\n                        compressionState.table,\n                        mutateableQuery as any\n                    ) as any;\n                    return args.storage.statics.prepareQuery(\n                        compressionState.compressedSchema,\n                        mutateableQuery\n                    );\n                }\n                return args.storage.statics.prepareQuery(\n                    schema,\n                    mutateableQuery\n                );\n            },\n            getSortComparator<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                preparedQuery: PreparedQuery<RxDocType>\n            ): DeterministicSortComparator<RxDocType> {\n                if (!schema.keyCompression) {\n                    return args.storage.statics.getSortComparator(schema, preparedQuery);\n                } else {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    return args.storage.statics.getSortComparator(compressionState.schema, preparedQuery);\n                }\n            },\n            getQueryMatcher<RxDocType>(\n                schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n                preparedQuery: PreparedQuery<RxDocType>\n            ): QueryMatcher<RxDocumentData<RxDocType>> {\n                if (!schema.keyCompression) {\n                    return args.storage.statics.getQueryMatcher(schema, preparedQuery);\n                } else {\n                    const compressionState = getCompressionStateByRxJsonSchema(schema);\n                    return args.storage.statics.getQueryMatcher(compressionState.schema, preparedQuery);\n                }\n            }\n        }\n    );\n\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            statics,\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (!params.schema.keyCompression) {\n                    return args.storage.createStorageInstance(params);\n                }\n\n                const compressionState = getCompressionStateByRxJsonSchema(params.schema);\n                function modifyToStorage(docData: RxDocumentData<RxDocType>) {\n                    return compressDocumentData(compressionState, docData);\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    return decompressDocumentData(compressionState, docData);\n                }\n\n                /**\n                 * Because this wrapper resolves the key-compression,\n                 * we can set the flag to false\n                 * which allows underlying storages to detect wrong conficturations\n                 * like when keyCompression is set to false but no key-compression module is used.\n                 */\n                const childSchema = flatClone(compressionState.compressedSchema);\n                childSchema.keyCompression = false;\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: childSchema\n                        }\n                    )\n                );\n\n                return wrapRxStorageInstance(\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage\n                );\n            }\n        }\n    );\n}\n\nexport function compressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    /**\n     * Do not send attachments to compressObject()\n     * because it will deep clone which does not work on Blob or Buffer.\n     */\n    docData = flatCloneDocWithMeta(docData);\n    const attachments = docData._attachments;\n    delete docData._attachments;\n\n    docData = compressObject(\n        compressionState.table,\n        docData\n    );\n    docData._attachments = attachments;\n    return docData;\n}\n\nexport function decompressDocumentData(\n    compressionState: CompressionState,\n    docData: RxDocumentData<any>\n): RxDocumentData<any> {\n    return decompressObject(\n        compressionState.table,\n        docData\n    );\n}\n"],"mappings":"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"}