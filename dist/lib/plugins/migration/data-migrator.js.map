{"version":3,"file":"data-migrator.js","names":["_rxjs","require","_utils","_rxSchema","_rxError","_hooks","_migrationState","_operators","_rxStorageHelper","_rxDatabaseInternalStore","_rxQueryHelper","_overwritable","_migrationHelpers","DataMigrator","exports","newestCollection","migrationStrategies","_migrated","nonMigratedOldCollections","allOldCollections","currentSchema","schema","database","name","_proto","prototype","migrate","batchSize","MIGRATION_DEFAULT_BATCH_SIZE","_this","newRxError","state","done","total","handled","success","deleted","percent","stateSubject","Subject","allSubject","getMigrationStateByDatabase","allList","getValue","slice","push","asObservable","next","_getOldCollections","then","ret","storage","countAllDocuments","storageInstance","getAllQueryPrepared","statics","prepareQuery","normalizeMangoQuery","queryResult","count","countAll","Promise","all","map","oldCol","jsonSchema","totalCount","reduce","cur","prev","collection","flatClone","currentCol","shift","currentPromise","PROMISE_RESOLVE_VOID","_loop","migrationState$","migrateOldCollection","res","sub","subscribe","subState","type","Math","round","error","e","unsubscribe","forEach","c","close","catch","complete","pipe","withCollection","migratePromise","_migratePromise","mustMigrate","must","PROMISE_RESOLVE_FALSE","rej","state$","err","createOldCollection","version","schemaObj","dataMigrator","storageInstanceCreationParams","databaseInstanceToken","token","databaseName","collectionName","options","instanceCreationOptions","multiInstance","devMode","overwritable","isDevMode","runPluginHooks","createStorageInstance","createRxSchema","hashFunction","getWrappedStorageInstance","getOldCollectionDocs","collectionDocKeys","getPreviousVersions","internalStore","findDocumentsById","key","getPrimaryKeyOfInternalDocument","INTERNAL_CONTEXT_COLLECTION","docsObj","Object","values","oldColDocs","colDoc","data","filter","length","runStrategyIfNotNull","oldCollection","docOrNull","PROMISE_RESOLVE_NULL","retPromise","toPromise","getBatchOfOldCollection","preparedQuery","selector","sort","primaryPath","limit","skip","query","result","documents","doc","migrateDocumentData","docData","attachmentsBefore","_attachments","mutateableDocData","clone","nextVersion","resolve","_loop2","_meta","getDefaultRxDocumentMeta","isDocumentDataWithoutRevisionEqual","doc1","doc2","doc1NoRev","assign","undefined","_rev","doc2NoRev","deepEqual","_migrateDocuments","documentsData","previousDocumentData","runAsyncPluginHooks","migratedDocuments","bulkWriteToStorageInput","actions","idx","migratedDocData","action","migrated","createRevision","saveData","lwt","now","originalStorageInstance","bulkWrite","document","bulkDeleteInputData","writeDeleted","_deleted","previous","deleteOldCollection","remove","removeCollectionDoc","_migrate","observer","allBatchesDone","handleOneBatch","batch"],"sources":["../../../../src/plugins/migration/data-migrator.ts"],"sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n/**\n * TODO this should be completely rewritten because:\n * - This could have been done in much less code which would be easier to understand\n *\n */\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport {\n    clone,\n    toPromise,\n    flatClone,\n    createRevision,\n    PROMISE_RESOLVE_VOID,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL,\n    getDefaultRxDocumentMeta,\n    now,\n    deepEqual\n} from '../../plugins/utils';\nimport {\n    createRxSchema\n} from '../../rx-schema';\nimport {\n    newRxError\n} from '../../rx-error';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from '../../hooks';\nimport type {\n    RxCollection,\n    RxDatabase,\n    MigrationState,\n    NumberFunctionMap,\n    OldRxCollection,\n    WithAttachmentsData,\n    RxJsonSchema,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    InternalStoreCollectionDocType,\n    RxStorageInstance\n} from '../../types';\nimport {\n    RxSchema,\n    getPreviousVersions\n} from '../../rx-schema';\nimport {\n    getMigrationStateByDatabase,\n    MigrationStateWithCollection\n} from './migration-state';\nimport { map } from 'rxjs/operators';\nimport {\n    getWrappedStorageInstance\n} from '../../rx-storage-helper';\nimport {\n    getPrimaryKeyOfInternalDocument,\n    INTERNAL_CONTEXT_COLLECTION\n} from '../../rx-database-internal-store';\nimport { normalizeMangoQuery } from '../../rx-query-helper';\nimport { overwritable } from '../../overwritable';\nimport { MIGRATION_DEFAULT_BATCH_SIZE } from './migration-helpers';\n\nexport class DataMigrator {\n\n    constructor(\n        public newestCollection: RxCollection,\n        public migrationStrategies: NumberFunctionMap\n    ) {\n        this.currentSchema = newestCollection.schema;\n        this.database = newestCollection.database;\n        this.name = newestCollection.name;\n    }\n\n    public currentSchema: RxSchema;\n    public database: RxDatabase;\n    public name: string;\n\n\n    private _migrated: boolean = false;\n    private _migratePromise?: Promise<any>;\n    private nonMigratedOldCollections: OldRxCollection[] = [];\n    private allOldCollections: OldRxCollection[] = [];\n    migrate(batchSize: number = MIGRATION_DEFAULT_BATCH_SIZE): Observable<MigrationState> {\n        if (this._migrated) {\n            throw newRxError('DM1');\n        }\n        this._migrated = true;\n\n        const state = {\n            done: false, // true if finished\n            total: 0, // will be the doc-count\n            handled: 0, // amount of handled docs\n            success: 0, // handled docs which succeeded\n            deleted: 0, // handled docs which got deleted\n            percent: 0 // percentage\n        };\n\n        const stateSubject: Subject<MigrationStateWithCollection> = new Subject();\n\n        /**\n         * Add to output of RxDatabase.migrationStates\n         */\n        const allSubject = getMigrationStateByDatabase(this.newestCollection.database);\n        const allList = allSubject.getValue().slice(0);\n        allList.push(stateSubject.asObservable());\n        allSubject.next(allList);\n\n        /**\n         * TODO this is a side-effect which might throw\n         * We did this because it is not possible to create new Observer(async(...))\n         * @link https://github.com/ReactiveX/rxjs/issues/4074\n         * In the future the whole migration plugin should be rewritten without rxjs\n         * so we do not have this problem.\n         */\n        (() => {\n            return _getOldCollections(this)\n                .then(ret => {\n                    this.nonMigratedOldCollections = ret;\n                    this.allOldCollections = this.nonMigratedOldCollections.slice(0);\n                    const storage = this.database.storage;\n                    async function countAllDocuments(\n                        storageInstance: RxStorageInstance<any, any, any>,\n                        schema: RxJsonSchema<any>\n                    ): Promise<number> {\n                        const getAllQueryPrepared = storage.statics.prepareQuery(\n                            storageInstance.schema,\n                            normalizeMangoQuery(\n                                schema,\n                                {}\n                            )\n                        );\n                        const queryResult = await storageInstance.count(getAllQueryPrepared);\n                        return queryResult.count;\n                    }\n                    const countAll: Promise<number[]> = Promise.all(\n                        this.nonMigratedOldCollections\n                            .map(oldCol => countAllDocuments(\n                                oldCol.storageInstance,\n                                oldCol.schema.jsonSchema\n                            ))\n                    );\n                    return countAll;\n                })\n                .then(countAll => {\n                    const totalCount: number = countAll\n                        .reduce((cur, prev) => prev = cur + prev, 0);\n                    state.total = totalCount;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    let currentCol = this.nonMigratedOldCollections.shift();\n                    let currentPromise = PROMISE_RESOLVE_VOID;\n                    while (currentCol) {\n                        const migrationState$ = migrateOldCollection(\n                            currentCol,\n                            batchSize\n                        );\n                        currentPromise = currentPromise.then(() => {\n                            return new Promise(res => {\n                                const sub = migrationState$.subscribe({\n                                    next: (subState: any) => {\n                                        state.handled++;\n                                        (state as any)[subState.type] = (state as any)[subState.type] + 1;\n                                        state.percent = Math.round(state.handled / state.total * 100);\n                                        stateSubject.next({\n                                            collection: this.newestCollection,\n                                            state: flatClone(state)\n                                        });\n                                    },\n                                    error: (e: any) => {\n                                        sub.unsubscribe();\n                                        // TODO we should not have to catch here.\n                                        this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                        stateSubject.error(e);\n                                    },\n                                    complete: () => {\n                                        if (currentCol) {\n                                            // TODO we should not have to catch here.\n                                            currentCol.storageInstance.close().catch(() => { });\n                                        }\n                                        sub.unsubscribe();\n                                        res();\n                                    }\n                                });\n                            });\n                        });\n                        currentCol = this.nonMigratedOldCollections.shift();\n                    }\n                    return currentPromise;\n                })\n                .then(() => {\n                    state.done = true;\n                    state.percent = 100;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    stateSubject.complete();\n                });\n        })();\n\n\n        return stateSubject.pipe(\n            map(withCollection => withCollection.state)\n        );\n    }\n\n    migratePromise(batchSize: number): Promise<any> {\n        if (!this._migratePromise) {\n            this._migratePromise = mustMigrate(this)\n                .then(must => {\n                    if (!must) {\n                        return PROMISE_RESOLVE_FALSE;\n                    } else {\n                        return new Promise((res, rej) => {\n                            const state$ = this.migrate(batchSize);\n                            (state$ as any).subscribe(null, rej, res);\n                            this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                        })\n                            .catch(err => {\n                                this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                throw err;\n                            });\n                    }\n                });\n        }\n        return this._migratePromise;\n    }\n}\n\nexport async function createOldCollection(\n    version: number,\n    schemaObj: RxJsonSchema<any>,\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection> {\n    const database = dataMigrator.newestCollection.database;\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: dataMigrator.newestCollection.name,\n        schema: schemaObj,\n        options: dataMigrator.newestCollection.instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        devMode: overwritable.isDevMode()\n    };\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await database.storage.createStorageInstance(\n        storageInstanceCreationParams\n    );\n    const ret: OldRxCollection = {\n        version,\n        dataMigrator,\n        newestCollection: dataMigrator.newestCollection,\n        database,\n        schema: createRxSchema(schemaObj, database.hashFunction, false),\n        storageInstance\n    };\n\n    ret.storageInstance = getWrappedStorageInstance(\n        ret.database,\n        storageInstance,\n        schemaObj\n    );\n\n    return ret;\n}\n\n\nexport function getOldCollectionDocs(\n    dataMigrator: DataMigrator\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n\n    const collectionDocKeys = getPreviousVersions(dataMigrator.currentSchema.jsonSchema)\n        .map(version => dataMigrator.name + '-' + version);\n\n    return dataMigrator.database.internalStore.findDocumentsById(\n        collectionDocKeys.map(key => getPrimaryKeyOfInternalDocument(\n            key,\n            INTERNAL_CONTEXT_COLLECTION\n        )),\n        false\n    ).then(docsObj => Object.values(docsObj));\n}\n\n/**\n * get an array with OldCollection-instances from all existing old storage-instances\n */\nexport async function _getOldCollections(\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection[]> {\n    const oldColDocs = await getOldCollectionDocs(dataMigrator);\n\n    return Promise.all(\n        oldColDocs\n            .map(colDoc => {\n                if (!colDoc) {\n                    return null as any;\n                }\n                return createOldCollection(\n                    colDoc.data.schema.version,\n                    colDoc.data.schema,\n                    dataMigrator\n                );\n            })\n            .filter(colDoc => colDoc !== null)\n    );\n}\n\n\n/**\n * returns true if a migration is needed\n */\nexport function mustMigrate(dataMigrator: DataMigrator): Promise<boolean> {\n    if (dataMigrator.currentSchema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    return getOldCollectionDocs(dataMigrator)\n        .then(oldColDocs => {\n            if (oldColDocs.length === 0) {\n                return false;\n            } else {\n                return true;\n            }\n        });\n}\n\nexport function runStrategyIfNotNull(\n    oldCollection: OldRxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull, oldCollection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\nexport function getBatchOfOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize: number\n): Promise<any[]> {\n    const storage = oldCollection.database.storage;\n    const storageInstance = oldCollection.storageInstance;\n    const preparedQuery = storage.statics.prepareQuery(\n        storageInstance.schema,\n        {\n            selector: {},\n            sort: [{ [oldCollection.schema.primaryPath]: 'asc' } as any],\n            limit: batchSize,\n            skip: 0\n        }\n    );\n\n    return storageInstance\n        .query(preparedQuery)\n        .then(result => result.documents\n            .map(doc => {\n                doc = flatClone(doc);\n                return doc;\n            })\n        );\n}\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    oldCollection: OldRxCollection,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = oldCollection.version + 1;\n\n    // run the document through migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= oldCollection.newestCollection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            oldCollection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        /**\n         * Add _meta field if missing.\n         * We need this to migration documents from pre-12.0.0 state\n         * to version 12.0.0. Therefore we need to add the _meta field if it is missing.\n         * TODO remove this in the major version 13.0.0\n         */\n        if (!doc._meta) {\n            doc._meta = getDefaultRxDocumentMeta();\n        }\n        return doc;\n    });\n}\n\n\nexport function isDocumentDataWithoutRevisionEqual<T>(doc1: T, doc2: T): boolean {\n    const doc1NoRev = Object.assign({}, doc1, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    const doc2NoRev = Object.assign({}, doc2, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    return deepEqual(doc1NoRev, doc2NoRev);\n}\n\n/**\n * transform documents data and save them to the new collection\n * @return status-action with status and migrated document\n */\nexport async function _migrateDocuments<RxDocType>(\n    oldCollection: OldRxCollection,\n    documentsData: RxDocumentData<RxDocType>[]\n): Promise<{ type: string; doc: any; }[]> {\n\n\n    /**\n     * Required in case the hooks mutate the document\n     * data which would then wrongly cause conflicts\n     * because we would send the mutated document\n     * as writeRow.previous.\n     */\n    const previousDocumentData = clone(documentsData);\n\n    // run hooks that might mutate documentsData\n    await Promise.all(\n        documentsData.map(docData => runAsyncPluginHooks(\n            'preMigrateDocument',\n            {\n                docData,\n                oldCollection\n            }\n        ))\n    );\n    // run the migration strategies on each document\n    const migratedDocuments: (any | null)[] = await Promise.all(\n        documentsData.map(docData => migrateDocumentData(oldCollection, docData))\n    );\n\n\n    const bulkWriteToStorageInput: RxDocumentData<any>[] = [];\n    const actions: any[] = [];\n\n    documentsData.forEach((docData, idx) => {\n        const migratedDocData: any | null = migratedDocuments[idx];\n        const action = {\n            res: null as any,\n            type: '',\n            migrated: migratedDocData,\n            doc: docData,\n            oldCollection,\n            newestCollection: oldCollection.newestCollection\n        };\n        actions.push(action);\n\n        /**\n         * Deterministically handle the revision\n         * so migrating the same data on multiple instances\n         * will result in the same output.\n         */\n        if (isDocumentDataWithoutRevisionEqual(docData, migratedDocData)) {\n            /**\n             * Data not changed by migration strategies, keep the same revision.\n             * This ensures that other replicated instances that did not migrate already\n             * will still have the same document.\n             */\n            migratedDocData._rev = docData._rev;\n        } else if (migratedDocData !== null) {\n            /**\n             * data changed, increase revision height\n             * so replicating instances use our new document data\n             */\n            migratedDocData._rev = createRevision(\n                oldCollection.newestCollection.database.token,\n                docData\n            );\n        }\n\n\n        if (migratedDocData) {\n            /**\n             * save to newest collection\n             * notice that this data also contains the attachments data\n             */\n            const attachmentsBefore = migratedDocData._attachments;\n            const saveData: WithAttachmentsData<any> = migratedDocData;\n            saveData._attachments = attachmentsBefore;\n            saveData._meta.lwt = now();\n            bulkWriteToStorageInput.push(saveData);\n            action.res = saveData;\n            action.type = 'success';\n        } else {\n            /**\n             * Migration strategy returned null\n             * which means we should not migrate this document,\n             * just drop it.\n             */\n            action.type = 'deleted';\n        }\n    });\n\n    /**\n     * Write the documents to the newest collection.\n     * We need to add as revision\n     * because we provide the _rev by our own\n     * to have deterministic revisions in case the migration\n     * runs on multiple nodes which must lead to the equal storage state.\n     */\n    if (bulkWriteToStorageInput.length) {\n        /**\n         * To ensure that we really keep that revision, we\n         * hackly insert this document via the RxStorageInstance.originalStorageInstance\n         * so that getWrappedStorageInstance() does not overwrite its own revision.\n         */\n        const originalStorageInstance = oldCollection.newestCollection.storageInstance.originalStorageInstance;\n        await originalStorageInstance.bulkWrite(\n            bulkWriteToStorageInput.map(document => ({ document })),\n            'data-migrator-import'\n        );\n    }\n\n    // run hooks\n    await Promise.all(\n        actions.map(action => runAsyncPluginHooks(\n            'postMigrateDocument',\n            action\n        ))\n    );\n\n    // remove the documents from the old collection storage instance\n    const bulkDeleteInputData = documentsData.map((docData, idx) => {\n        const writeDeleted = flatClone(docData);\n        writeDeleted._deleted = true;\n        writeDeleted._attachments = {};\n        return {\n            previous: previousDocumentData[idx],\n            document: writeDeleted\n        };\n    });\n\n    if (bulkDeleteInputData.length) {\n        await oldCollection.storageInstance.bulkWrite(\n            bulkDeleteInputData,\n            'data-migrator-delete'\n        );\n    }\n\n    return actions;\n}\n\n\n/**\n * deletes this.storageInstance and removes it from the database.collectionsCollection\n */\nexport function deleteOldCollection(\n    oldCollection: OldRxCollection\n): Promise<void> {\n    return oldCollection.storageInstance.remove()\n        .then(\n            () => oldCollection.database.removeCollectionDoc(\n                oldCollection.dataMigrator.name,\n                oldCollection.schema\n            )\n        );\n}\n\n/**\n * runs the migration on all documents and deletes the storage instance afterwards\n */\nexport function migrateOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize = MIGRATION_DEFAULT_BATCH_SIZE\n): Observable<any> {\n    if (oldCollection._migrate) {\n        // already running\n        throw newRxError('DM3');\n    }\n    oldCollection._migrate = true;\n\n    const observer = new Subject();\n\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n    (() => {\n        let error: any;\n        const allBatchesDone = () => {\n            // remove this oldCollection\n            return deleteOldCollection(oldCollection)\n                .then(() => observer.complete());\n        };\n        const handleOneBatch = () => {\n            return getBatchOfOldCollection(oldCollection, batchSize)\n                .then(batch => {\n                    if (batch.length === 0) {\n                        allBatchesDone();\n                        return false;\n                    } else {\n                        return _migrateDocuments(oldCollection, batch)\n                            .then((actions: any[]) => actions.forEach(action => observer.next(action)))\n                            .catch(e => error = e)\n                            .then(() => true);\n                    }\n                })\n                .then(next => {\n                    if (!next) {\n                        return;\n                    }\n                    if (error) {\n                        observer.error(error);\n                    } else {\n                        handleOneBatch();\n                    }\n                });\n        };\n        handleOneBatch();\n    })();\n\n    return observer.asObservable();\n}\n\nexport function migratePromise(\n    oldCollection: OldRxCollection,\n    batchSize?: number\n): Promise<any> {\n    if (!oldCollection._migratePromise) {\n        oldCollection._migratePromise = new Promise((res, rej) => {\n            const state$ = migrateOldCollection(oldCollection, batchSize);\n            (state$ as any).subscribe(null, rej, res);\n        });\n    }\n    return oldCollection._migratePromise;\n}\n"],"mappings":"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"}