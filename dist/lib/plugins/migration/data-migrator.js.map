{"version":3,"file":"data-migrator.js","names":["_migrateDocuments","oldCollection","documentsData","Promise","all","map","docData","runAsyncPluginHooks","migrateDocumentData","migratedDocuments","actions","action","bulkDeleteInputData","writeDeleted","flatClone","_deleted","_attachments","previous","document","length","storageInstance","bulkWrite","bulkWriteToStorageInput","forEach","idx","migratedDocData","res","type","migrated","doc","newestCollection","push","isDocumentDataWithoutRevisionEqual","_rev","newHeight","getHeightOfRevision","newRevision","createRevision","database","hashFunction","attachmentsBefore","saveData","_meta","lwt","now","originalStorageInstance","_getOldCollections","dataMigrator","getOldCollectionDocs","oldColDocs","colDoc","createOldCollection","data","schema","version","filter","schemaObj","storageInstanceCreationParams","databaseInstanceToken","token","databaseName","name","collectionName","options","instanceCreationOptions","multiInstance","runPluginHooks","storage","createStorageInstance","ret","createRxSchema","getWrappedStorageInstance","DataMigrator","migrationStrategies","_migrated","nonMigratedOldCollections","allOldCollections","currentSchema","migrate","batchSize","newRxError","state","done","total","handled","success","deleted","percent","stateSubject","Subject","allSubject","getMigrationStateByDatabase","allList","getValue","slice","asObservable","next","then","getAllDocuments","getAllQueryPrepared","statics","prepareQuery","normalizeMangoQuery","query","queryResult","allDocs","documents","countAll","oldCol","jsonSchema","totalCount","reduce","cur","prev","collection","currentCol","shift","currentPromise","PROMISE_RESOLVE_VOID","migrationState$","migrateOldCollection","sub","subscribe","subState","Math","round","error","e","unsubscribe","c","close","complete","pipe","withCollection","migratePromise","_migratePromise","mustMigrate","must","PROMISE_RESOLVE_FALSE","rej","state$","err","collectionDocKeys","getPreviousVersions","internalStore","findDocumentsById","key","getPrimaryKeyOfInternalDocument","INTERNAL_CONTEXT_COLLECTION","docsObj","Object","values","runStrategyIfNotNull","docOrNull","PROMISE_RESOLVE_NULL","retPromise","toPromise","getBatchOfOldCollection","preparedQuery","selector","sort","primaryPath","limit","skip","result","mutateableDocData","clone","nextVersion","resolve","getDefaultRxDocumentMeta","doc1","doc2","doc1NoRev","assign","undefined","doc2NoRev","deepEqual","deleteOldCollection","remove","removeCollectionDoc","_migrate","observer","allBatchesDone","handleOneBatch","batch"],"sources":["../../../../src/plugins/migration/data-migrator.ts"],"sourcesContent":["/**\n * The DataMigrator handles the documents from collections with older schemas\n * and transforms/saves them into the newest collection\n */\n/**\n * TODO this should be completely rewritten because:\n * - This could have been done in much less code which would be easier to uderstand\n *\n */\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport deepEqual from 'fast-deep-equal';\nimport {\n    clone,\n    toPromise,\n    flatClone,\n    getHeightOfRevision,\n    createRevision,\n    PROMISE_RESOLVE_VOID,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL,\n    getDefaultRxDocumentMeta,\n    now\n} from '../../util';\nimport {\n    createRxSchema\n} from '../../rx-schema';\nimport {\n    newRxError\n} from '../../rx-error';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from '../../hooks';\nimport type {\n    RxCollection,\n    RxDatabase,\n    MigrationState,\n    NumberFunctionMap,\n    OldRxCollection,\n    WithAttachmentsData,\n    RxJsonSchema,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    InternalStoreCollectionDocType,\n    RxStorageInstance\n} from '../../types';\nimport {\n    RxSchema,\n    getPreviousVersions\n} from '../../rx-schema';\nimport {\n    getMigrationStateByDatabase,\n    MigrationStateWithCollection\n} from './migration-state';\nimport { map } from 'rxjs/operators';\nimport {\n    getWrappedStorageInstance\n} from '../../rx-storage-helper';\nimport {\n    getPrimaryKeyOfInternalDocument,\n    INTERNAL_CONTEXT_COLLECTION\n} from '../../rx-database-internal-store';\nimport { normalizeMangoQuery } from '../../rx-query-helper';\n\nexport class DataMigrator {\n\n    constructor(\n        public newestCollection: RxCollection,\n        public migrationStrategies: NumberFunctionMap\n    ) {\n        this.currentSchema = newestCollection.schema;\n        this.database = newestCollection.database;\n        this.name = newestCollection.name;\n    }\n\n    public currentSchema: RxSchema;\n    public database: RxDatabase;\n    public name: string;\n\n\n    private _migrated: boolean = false;\n    private _migratePromise?: Promise<any>;\n    private nonMigratedOldCollections: OldRxCollection[] = [];\n    private allOldCollections: OldRxCollection[] = [];\n    migrate(batchSize: number = 10): Observable<MigrationState> {\n        if (this._migrated) {\n            throw newRxError('DM1');\n        }\n        this._migrated = true;\n\n        const state = {\n            done: false, // true if finished\n            total: 0, // will be the doc-count\n            handled: 0, // amount of handled docs\n            success: 0, // handled docs which succeeded\n            deleted: 0, // handled docs which got deleted\n            percent: 0 // percentage\n        };\n\n        const stateSubject: Subject<MigrationStateWithCollection> = new Subject();\n\n        /**\n         * Add to output of RxDatabase.migrationStates\n         */\n        const allSubject = getMigrationStateByDatabase(this.newestCollection.database);\n        const allList = allSubject.getValue().slice(0);\n        allList.push(stateSubject.asObservable());\n        allSubject.next(allList);\n\n        /**\n         * TODO this is a side-effect which might throw\n         * We did this because it is not possible to create new Observer(async(...))\n         * @link https://github.com/ReactiveX/rxjs/issues/4074\n         * In the future the whole migration plugin should be rewritten without rxjs\n         * so we do not have this problem.\n         */\n        (() => {\n            return _getOldCollections(this)\n                .then(ret => {\n                    this.nonMigratedOldCollections = ret;\n                    this.allOldCollections = this.nonMigratedOldCollections.slice(0);\n\n                    const getAllDocuments = async (\n                        storageInstance: RxStorageInstance<any, any, any>,\n                        schema: RxJsonSchema<any>\n                    ): Promise<RxDocumentData<any>[]> => {\n                        const storage = this.database.storage;\n                        const getAllQueryPrepared = storage.statics.prepareQuery(\n                            storageInstance.schema,\n                            normalizeMangoQuery(\n                                schema,\n                                {}\n                            )\n                        );\n                        const queryResult = await storageInstance.query(getAllQueryPrepared);\n                        const allDocs = queryResult.documents;\n                        return allDocs;\n                    }\n\n                    const countAll: Promise<number[]> = Promise.all(\n                        this.nonMigratedOldCollections\n                            .map(oldCol => getAllDocuments(\n                                oldCol.storageInstance,\n                                oldCol.schema.jsonSchema\n                            ).then(allDocs => allDocs.length))\n                    );\n                    return countAll;\n                })\n                .then(countAll => {\n                    const totalCount: number = countAll\n                        .reduce((cur, prev) => prev = cur + prev, 0);\n                    state.total = totalCount;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    let currentCol = this.nonMigratedOldCollections.shift();\n                    let currentPromise = PROMISE_RESOLVE_VOID;\n                    while (currentCol) {\n                        const migrationState$ = migrateOldCollection(\n                            currentCol,\n                            batchSize\n                        );\n                        currentPromise = currentPromise.then(() => {\n                            return new Promise(res => {\n                                const sub = migrationState$.subscribe({\n                                    next: (subState: any) => {\n                                        state.handled++;\n                                        (state as any)[subState.type] = (state as any)[subState.type] + 1;\n                                        state.percent = Math.round(state.handled / state.total * 100);\n                                        stateSubject.next({\n                                            collection: this.newestCollection,\n                                            state: flatClone(state)\n                                        });\n                                    },\n                                    error: (e: any) => {\n                                        sub.unsubscribe();\n                                        // TODO we should not have to catch here.\n                                        this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                        stateSubject.error(e);\n                                    },\n                                    complete: () => {\n                                        if (currentCol) {\n                                            // TODO we should not have to catch here.\n                                            currentCol.storageInstance.close().catch(() => { });\n                                        }\n                                        sub.unsubscribe();\n                                        res();\n                                    }\n                                });\n                            });\n                        });\n                        currentCol = this.nonMigratedOldCollections.shift();\n                    }\n                    return currentPromise;\n                })\n                .then(() => {\n                    state.done = true;\n                    state.percent = 100;\n                    stateSubject.next({\n                        collection: this.newestCollection,\n                        state: flatClone(state)\n                    });\n                    stateSubject.complete();\n                });\n        })();\n\n\n        return stateSubject.pipe(\n            map(withCollection => withCollection.state)\n        );\n    }\n\n    migratePromise(batchSize: number): Promise<any> {\n        if (!this._migratePromise) {\n            this._migratePromise = mustMigrate(this)\n                .then(must => {\n                    if (!must) {\n                        return PROMISE_RESOLVE_FALSE;\n                    } else {\n                        return new Promise((res, rej) => {\n                            const state$ = this.migrate(batchSize);\n                            (state$ as any).subscribe(null, rej, res);\n                            this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                        })\n                            .catch(err => {\n                                this.allOldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                                throw err;\n                            });\n                    }\n                });\n        }\n        return this._migratePromise;\n    }\n}\n\nexport async function createOldCollection(\n    version: number,\n    schemaObj: RxJsonSchema<any>,\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection> {\n    const database = dataMigrator.newestCollection.database;\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: dataMigrator.newestCollection.name,\n        schema: schemaObj,\n        options: dataMigrator.newestCollection.instanceCreationOptions,\n        multiInstance: database.multiInstance\n    };\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await database.storage.createStorageInstance(\n        storageInstanceCreationParams\n    );\n    const ret: OldRxCollection = {\n        version,\n        dataMigrator,\n        newestCollection: dataMigrator.newestCollection,\n        database,\n        schema: createRxSchema(schemaObj, false),\n        storageInstance\n    };\n\n    ret.storageInstance = getWrappedStorageInstance(\n        ret.database,\n        storageInstance,\n        schemaObj\n    );\n\n    return ret;\n}\n\n\nexport function getOldCollectionDocs(\n    dataMigrator: DataMigrator\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n\n    const collectionDocKeys = getPreviousVersions(dataMigrator.currentSchema.jsonSchema)\n        .map(version => dataMigrator.name + '-' + version);\n\n    return dataMigrator.database.internalStore.findDocumentsById(\n        collectionDocKeys.map(key => getPrimaryKeyOfInternalDocument(\n            key,\n            INTERNAL_CONTEXT_COLLECTION\n        )),\n        false\n    ).then(docsObj => Object.values(docsObj));\n}\n\n/**\n * get an array with OldCollection-instances from all existing old storage-instances\n */\nexport async function _getOldCollections(\n    dataMigrator: DataMigrator\n): Promise<OldRxCollection[]> {\n    const oldColDocs = await getOldCollectionDocs(dataMigrator);\n\n    return Promise.all(\n        oldColDocs\n            .map(colDoc => {\n                if (!colDoc) {\n                    return null as any;\n                }\n                return createOldCollection(\n                    colDoc.data.schema.version,\n                    colDoc.data.schema,\n                    dataMigrator\n                );\n            })\n            .filter(colDoc => colDoc !== null)\n    );\n}\n\n\n/**\n * returns true if a migration is needed\n */\nexport function mustMigrate(dataMigrator: DataMigrator): Promise<boolean> {\n    if (dataMigrator.currentSchema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    return getOldCollectionDocs(dataMigrator)\n        .then(oldColDocs => {\n            if (oldColDocs.length === 0) {\n                return false;\n            } else {\n                return true;\n            }\n        });\n}\n\nexport function runStrategyIfNotNull(\n    oldCollection: OldRxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = oldCollection.dataMigrator.migrationStrategies[version](docOrNull, oldCollection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\nexport function getBatchOfOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize: number\n): Promise<any[]> {\n    const storage = oldCollection.database.storage;\n    const storageInstance = oldCollection.storageInstance;\n    const preparedQuery = storage.statics.prepareQuery(\n        storageInstance.schema,\n        {\n            selector: {},\n            sort: [{ [oldCollection.schema.primaryPath]: 'asc' } as any],\n            limit: batchSize,\n            skip: 0\n        }\n    );\n\n    return storageInstance\n        .query(preparedQuery)\n        .then(result => result.documents\n            .map(doc => {\n                doc = flatClone(doc);\n                return doc;\n            })\n        );\n}\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    oldCollection: OldRxCollection,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = oldCollection.version + 1;\n\n    // run the document through migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= oldCollection.newestCollection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            oldCollection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        /**\n         * Add _meta field if missing.\n         * We need this to migration documents from pre-12.0.0 state\n         * to version 12.0.0. Therefore we need to add the _meta field if it is missing.\n         * TODO remove this in the major version 13.0.0 \n         */\n        if (!doc._meta) {\n            doc._meta = getDefaultRxDocumentMeta();\n        }\n        return doc;\n    });\n}\n\n\nexport function isDocumentDataWithoutRevisionEqual<T>(doc1: T, doc2: T): boolean {\n    const doc1NoRev = Object.assign({}, doc1, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    const doc2NoRev = Object.assign({}, doc2, {\n        _attachments: undefined,\n        _rev: undefined\n    });\n    return deepEqual(doc1NoRev, doc2NoRev);\n}\n\n/**\n * transform documents data and save them to the new collection\n * @return status-action with status and migrated document\n */\nexport async function _migrateDocuments(\n    oldCollection: OldRxCollection,\n    documentsData: any[]\n): Promise<{ type: string, doc: any }[]> {\n\n    // run hooks that might mutate documentsData\n    await Promise.all(\n        documentsData.map(docData => runAsyncPluginHooks(\n            'preMigrateDocument',\n            {\n                docData,\n                oldCollection\n            }\n        ))\n    );\n    // run the migration strategies on each document\n    const migratedDocuments: (any | null)[] = await Promise.all(\n        documentsData.map(docData => migrateDocumentData(oldCollection, docData))\n    );\n\n\n    const bulkWriteToStorageInput: RxDocumentData<any>[] = [];\n    const actions: any[] = [];\n\n    documentsData.forEach((docData, idx) => {\n        const migratedDocData: any | null = migratedDocuments[idx];\n        const action = {\n            res: null as any,\n            type: '',\n            migrated: migratedDocData,\n            doc: docData,\n            oldCollection,\n            newestCollection: oldCollection.newestCollection\n        };\n        actions.push(action);\n\n        /**\n         * Determiniticly handle the revision\n         * so migrating the same data on multiple instances\n         * will result in the same output.\n         */\n        if (isDocumentDataWithoutRevisionEqual(docData, migratedDocData)) {\n            /**\n             * Data not changed by migration strategies, keep the same revision.\n             * This ensures that other replicated instances that did not migrate already\n             * will still have the same document.\n             */\n            migratedDocData._rev = docData._rev;\n        } else if (migratedDocData !== null) {\n            /**\n             * data changed, increase revision height\n             * so replicating instances use our new document data\n             */\n            const newHeight = getHeightOfRevision(docData._rev) + 1;\n            const newRevision = newHeight + '-' + createRevision(\n                oldCollection.newestCollection.database.hashFunction,\n                migratedDocData\n            );\n            migratedDocData._rev = newRevision;\n        }\n\n\n        if (migratedDocData) {\n            /**\n             * save to newest collection\n             * notice that this data also contains the attachments data\n             */\n            const attachmentsBefore = migratedDocData._attachments;\n            const saveData: WithAttachmentsData<any> = migratedDocData;\n            saveData._attachments = attachmentsBefore;\n            saveData._meta.lwt = now();\n            bulkWriteToStorageInput.push(saveData);\n            action.res = saveData;\n            action.type = 'success';\n        } else {\n            /**\n             * Migration strategy returned null\n             * which means we should not migrate this document,\n             * just drop it.\n             */\n            action.type = 'deleted';\n        }\n    });\n\n    /**\n     * Write the documents to the newest collection.\n     * We need to add as revision\n     * because we provide the _rev by our own\n     * to have deterministic revisions in case the migration\n     * runs on multiple nodes which must lead to the equal storage state.\n     */\n    if (bulkWriteToStorageInput.length) {\n        /**\n         * To ensure that we really keep that revision, we\n         * hackly insert this document via the RxStorageInstance.originalStorageInstance\n         * so that getWrappedStorageInstance() does not overwrite its own revision.\n         */\n        const originalStorageInstance: RxStorageInstance<any, any, any> = (oldCollection.newestCollection.storageInstance as any).originalStorageInstance;\n        await originalStorageInstance.bulkWrite(\n            bulkWriteToStorageInput.map(document => ({ document })),\n            'data-migrator-import'\n        );\n    }\n\n    // run hooks\n    await Promise.all(\n        actions.map(action => runAsyncPluginHooks(\n            'postMigrateDocument',\n            action\n        ))\n    );\n\n    // remove the documents from the old collection storage instance\n    const bulkDeleteInputData = documentsData.map(docData => {\n        const writeDeleted = flatClone(docData);\n        writeDeleted._deleted = true;\n        writeDeleted._attachments = {};\n        return {\n            previous: docData,\n            document: writeDeleted\n        };\n    });\n\n    if (bulkDeleteInputData.length) {\n        await oldCollection.storageInstance.bulkWrite(\n            bulkDeleteInputData,\n            'data-migrator-delete'\n        );\n    }\n\n    return actions;\n}\n\n\n/**\n * deletes this.storageInstance and removes it from the database.collectionsCollection\n */\nexport function deleteOldCollection(\n    oldCollection: OldRxCollection\n): Promise<void> {\n    return oldCollection.storageInstance.remove()\n        .then(\n            () => oldCollection.database.removeCollectionDoc(\n                oldCollection.dataMigrator.name,\n                oldCollection.schema\n            )\n        );\n}\n\n/**\n * runs the migration on all documents and deletes the storage instance afterwards\n */\nexport function migrateOldCollection(\n    oldCollection: OldRxCollection,\n    batchSize = 10\n): Observable<any> {\n    if (oldCollection._migrate) {\n        // already running\n        throw newRxError('DM3');\n    }\n    oldCollection._migrate = true;\n\n    const observer = new Subject();\n\n    /**\n     * TODO this is a side-effect which might throw\n     * @see DataMigrator.migrate()\n     */\n    (() => {\n        let error: any;\n        const allBatchesDone = () => {\n            // remove this oldCollection\n            return deleteOldCollection(oldCollection)\n                .then(() => observer.complete());\n        };\n        const handleOneBatch = () => {\n            return getBatchOfOldCollection(oldCollection, batchSize)\n                .then(batch => {\n                    if (batch.length === 0) {\n                        allBatchesDone();\n                        return false;\n                    } else {\n                        return _migrateDocuments(oldCollection, batch)\n                            .then((actions: any[]) => actions.forEach(action => observer.next(action)))\n                            .catch(e => error = e)\n                            .then(() => true);\n                    }\n                })\n                .then(next => {\n                    if (!next) {\n                        return;\n                    }\n                    if (error) {\n                        observer.error(error);\n                    } else {\n                        handleOneBatch();\n                    }\n                });\n        };\n        handleOneBatch();\n    })();\n\n    return observer.asObservable();\n}\n\nexport function migratePromise(\n    oldCollection: OldRxCollection,\n    batchSize?: number\n): Promise<any> {\n    if (!oldCollection._migratePromise) {\n        oldCollection._migratePromise = new Promise((res, rej) => {\n            const state$ = migrateOldCollection(oldCollection, batchSize);\n            (state$ as any).subscribe(null, rej, res);\n        });\n    }\n    return oldCollection._migratePromise;\n}\n"],"mappings":"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"}