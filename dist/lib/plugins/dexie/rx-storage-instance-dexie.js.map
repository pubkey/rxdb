{"version":3,"sources":["../../../../src/plugins/dexie/rx-storage-instance-dexie.ts"],"names":["createDexieStorageInstance","storage","params","settings","internals","databaseName","collectionName","schema","instance","RxStorageInstanceDexie","options","instanceId","changes$","Subject","closed","primaryPath","primaryKey","bulkWrite","documentWrites","state","ret","success","error","eventBulk","id","events","documentKeys","map","writeRow","document","dexieDb","transaction","dexieTable","dexieDeletedTable","docsInDb","bulkPutDocs","bulkRemoveDocs","bulkPutDeletedDocs","bulkRemoveDeletedDocs","changesIds","forEach","docIndex","startTime","documentInDb","insertedIsDeleted","_deleted","writeDoc","Object","assign","_attachments","push","eventId","documentId","change","doc","operation","previous","endTime","revInDb","_rev","err","isError","status","isDeleted","args","Promise","all","length","bulkPut","PROMISE_RESOLVE_VOID","bulkDelete","event","next","findDocumentsById","ids","deleted","idx","bulkGet","query","preparedQuery","getChangedDocumentsSince","limit","checkpoint","sinceLwt","lwt","RX_META_LWT_MINIMUM","sinceId","table","where","above","toArray","changedDocsNormal","changedDocsDeleted","changedDocs","concat","documents","slice","useForCheckpoint","_meta","remove","clear","close","changeStream","asObservable","cleanup","minimumDeletedTime","maxDeletionTime","below","toRemove","removeIds","getAttachmentData","_documentId","_attachmentId","Error","database","collection","complete"],"mappings":"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","sourcesContent":["import type {\n    ChangeEvent\n} from 'event-reduce-js';\nimport {\n    Subject,\n    Observable\n} from 'rxjs';\nimport {\n    lastOfArray,\n    now,\n    randomCouchString,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM,\n    sortDocumentsByLastWriteTime\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport type {\n    RxStorageInstance,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageBulkWriteError,\n    RxStorageQueryResult,\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    EventBulk,\n    PreparedQuery,\n    DexieChangesCheckpoint\n} from '../../types';\nimport { DexieSettings, DexieStorageInternals } from '../../types/plugins/dexie';\nimport { RxStorageDexie } from './rx-storage-dexie';\nimport {\n    closeDexieDb,\n    getDexieDbWithTables,\n    getDocsInDb\n} from './dexie-helper';\nimport { dexieQuery } from './query/dexie-query';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { getUniqueDeterministicEventKey } from '../../rx-storage-helper';\n\nlet instanceId = now();\n\nexport class RxStorageInstanceDexie<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    DexieStorageInternals,\n    DexieSettings\n> {\n    public readonly primaryPath: keyof RxDocType;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageDexie,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: DexieStorageInternals,\n        public readonly options: Readonly<DexieSettings>,\n        public readonly settings: DexieSettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey) as any;\n    }\n\n    async bulkWrite(documentWrites: BulkWriteRow<RxDocType>[]): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        const state = await this.internals;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n        const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>> = {\n            id: randomCouchString(10),\n            events: []\n        };\n\n        const documentKeys: string[] = documentWrites.map(writeRow => writeRow.document[this.primaryPath] as any);\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                const docsInDb = await getDocsInDb<RxDocType>(this.internals, documentKeys);\n\n                /**\n                 * Batch up the database operations\n                 * so we can later run them in bulk.\n                 */\n                const bulkPutDocs: any[] = [];\n                const bulkRemoveDocs: string[] = [];\n                const bulkPutDeletedDocs: any[] = [];\n                const bulkRemoveDeletedDocs: string[] = [];\n                const changesIds: string[] = [];\n\n                documentWrites.forEach((writeRow, docIndex) => {\n                    const id: string = writeRow.document[this.primaryPath] as any;\n                    const startTime = now();\n                    const documentInDb = docsInDb[docIndex];\n                    if (!documentInDb) {\n                        /**\n                         * It is possible to insert already deleted documents,\n                         * this can happen on replication.\n                         */\n                        const insertedIsDeleted = writeRow.document._deleted ? true : false;\n                        const writeDoc = Object.assign(\n                            {},\n                            writeRow.document,\n                            {\n                                _deleted: insertedIsDeleted,\n                                // TODO attachments are currently not working with dexie.js\n                                _attachments: {} as any\n                            }\n                        );\n                        changesIds.push(id);\n                        if (insertedIsDeleted) {\n                            bulkPutDeletedDocs.push(writeDoc);\n                        } else {\n                            bulkPutDocs.push(writeDoc);\n                            eventBulk.events.push({\n                                eventId: getUniqueDeterministicEventKey(this, this.primaryPath as any, writeRow),\n                                documentId: id,\n                                change: {\n                                    doc: writeDoc,\n                                    id,\n                                    operation: 'INSERT',\n                                    previous: null\n                                },\n                                startTime,\n                                // will be filled up before the event is pushed into the changestream\n                                endTime: startTime\n                            });\n                        }\n\n                        ret.success[id] = writeDoc;\n                    } else {\n                        // update existing document\n                        const revInDb: string = documentInDb._rev;\n\n                        // inserting a deleted document is possible\n                        // without sending the previous data.\n                        if (!writeRow.previous && documentInDb._deleted) {\n                            writeRow.previous = documentInDb;\n                        }\n\n                        if (\n                            (\n                                !writeRow.previous &&\n                                !documentInDb._deleted\n                            ) ||\n                            (\n                                !!writeRow.previous &&\n                                revInDb !== writeRow.previous._rev\n                            )\n                        ) {\n                            // conflict error\n                            const err: RxStorageBulkWriteError<RxDocType> = {\n                                isError: true,\n                                status: 409,\n                                documentId: id,\n                                writeRow: writeRow,\n                                documentInDb\n                            };\n                            ret.error[id] = err;\n                        } else {\n                            const isDeleted = !!writeRow.document._deleted;\n                            const writeDoc: any = Object.assign(\n                                {},\n                                writeRow.document,\n                                {\n                                    _deleted: isDeleted,\n                                    // TODO attachments are currently not working with lokijs\n                                    _attachments: {}\n                                }\n                            );\n                            changesIds.push(id);\n                            let change: ChangeEvent<RxDocumentData<RxDocType>> | null = null;\n                            if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {\n                                /**\n                                 * Insert document that was deleted before.\n                                 */\n                                bulkPutDocs.push(writeDoc);\n                                bulkRemoveDeletedDocs.push(id);\n                                change = {\n                                    id,\n                                    operation: 'INSERT',\n                                    previous: null,\n                                    doc: writeDoc\n                                };\n                            } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {\n                                /**\n                                 * Update existing non-deleted document\n                                 */\n                                bulkPutDocs.push(writeDoc);\n                                change = {\n                                    id,\n                                    operation: 'UPDATE',\n                                    previous: writeRow.previous,\n                                    doc: writeDoc\n                                };\n                            } else if (writeRow.previous && !writeRow.previous._deleted && writeDoc._deleted) {\n                                /**\n                                 * Set non-deleted document to deleted.\n                                 */\n                                bulkPutDeletedDocs.push(writeDoc);\n                                bulkRemoveDocs.push(id);\n\n                                change = {\n                                    id,\n                                    operation: 'DELETE',\n                                    previous: writeRow.previous,\n                                    doc: null\n                                };\n                            } else if (\n                                writeRow.previous && writeRow.previous._deleted &&\n                                writeRow.document._deleted\n                            ) {\n                                // deleted doc was overwritten with other deleted doc\n                                bulkPutDeletedDocs.push(writeDoc);\n                            }\n                            if (!change) {\n                                if (\n                                    writeRow.previous && writeRow.previous._deleted &&\n                                    writeRow.document._deleted\n                                ) {\n                                    // deleted doc got overwritten with other deleted doc -> do not send an event\n                                } else {\n                                    throw newRxError('SNH', { args: { writeRow } });\n                                }\n                            } else {\n                                eventBulk.events.push({\n                                    eventId: getUniqueDeterministicEventKey(this, this.primaryPath as any, writeRow),\n                                    documentId: id,\n                                    change,\n                                    startTime,\n                                    // will be filled up before the event is pushed into the changestream\n                                    endTime: startTime\n                                });\n                            }\n                            ret.success[id] = writeDoc;\n                        }\n                    }\n                });\n\n                await Promise.all([\n                    bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID,\n                    bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID\n                ]);\n            });\n\n        const endTime = now();\n        eventBulk.events.forEach(event => event.endTime = endTime);\n        this.changes$.next(eventBulk);\n\n        return ret;\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        deleted: boolean\n    ): Promise<{ [documentId: string]: RxDocumentData<RxDocType> }> {\n        const state = await this.internals;\n        const ret: { [documentId: string]: RxDocumentData<RxDocType> } = {};\n\n        await state.dexieDb.transaction(\n            'r',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                let docsInDb: RxDocumentData<RxDocType>[];\n                if (deleted) {\n                    docsInDb = await getDocsInDb<RxDocType>(this.internals, ids);\n                } else {\n                    docsInDb = await state.dexieTable.bulkGet(ids)\n                }\n                ids.forEach((id, idx) => {\n                    const documentInDb = docsInDb[idx];\n                    if (\n                        documentInDb &&\n                        (!documentInDb._deleted || deleted)\n                    ) {\n                        ret[id] = documentInDb;\n                    }\n                });\n            });\n        return ret;\n    }\n\n    query(preparedQuery: PreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        return dexieQuery(\n            this,\n            preparedQuery\n        );\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: DexieChangesCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint?: DexieChangesCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n        const state = await this.internals;\n\n\n        const [changedDocsNormal, changedDocsDeleted] = await Promise.all(\n            [\n                state.dexieTable,\n                state.dexieDeletedTable\n            ].map(async (table) => {\n                const query = table\n                    .where('[_meta.lwt+' + this.primaryPath + ']')\n                    .above([sinceLwt, sinceId])\n                    .limit(limit);\n                const changedDocuments: RxDocumentData<RxDocType>[] = await query.toArray();\n                return changedDocuments;\n            })\n        );\n        let changedDocs = changedDocsNormal.concat(changedDocsDeleted);\n        // optimization shortcut\n        if (changedDocs.length === 0) {\n            return {\n                documents: [],\n                checkpoint\n            }\n        }\n\n        changedDocs = sortDocumentsByLastWriteTime(this.primaryPath as any, changedDocs);\n        changedDocs = changedDocs.slice(0, limit);\n\n        const useForCheckpoint = lastOfArray(changedDocs);\n\n        return {\n            documents: changedDocs,\n            checkpoint: {\n                id: useForCheckpoint[this.primaryPath] as any,\n                lwt: useForCheckpoint._meta.lwt\n            }\n        };\n    }\n\n    async remove(): Promise<void> {\n        const state = await this.internals;\n        await Promise.all([\n            state.dexieDeletedTable.clear(),\n            state.dexieTable.clear()\n        ]);\n        return this.close();\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>>> {\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const state = await this.internals;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieDeletedTable,\n            async () => {\n                const maxDeletionTime = now() - minimumDeletedTime;\n                const toRemove = await state.dexieDeletedTable\n                    .where('_meta.lwt')\n                    .below(maxDeletionTime)\n                    .toArray();\n                const removeIds: string[] = toRemove.map(doc => doc[this.primaryPath]);\n                await state.dexieDeletedTable.bulkDelete(removeIds);\n            }\n        );\n\n        /**\n         * TODO instead of deleting all deleted docs at once,\n         * only clean up some of them and return true.\n         * This ensures that when many documents have to be purged,\n         * we do not block the more important tasks too long.\n         */\n        return false;\n    }\n\n    getAttachmentData(_documentId: string, _attachmentId: string): Promise<string> {\n        throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n    }\n\n    async close(): Promise<void> {\n        if (this.closed) {\n            throw newRxError('SNH', {\n                database: this.databaseName,\n                collection: this.collectionName\n            });\n        }\n        this.closed = true;\n        this.changes$.complete();\n        closeDexieDb(this.internals);\n    }\n}\n\n\nexport async function createDexieStorageInstance<RxDocType>(\n    storage: RxStorageDexie,\n    params: RxStorageInstanceCreationParams<RxDocType, DexieSettings>,\n    settings: DexieSettings\n): Promise<RxStorageInstanceDexie<RxDocType>> {\n    const internals = getDexieDbWithTables(\n        params.databaseName,\n        params.collectionName,\n        settings,\n        params.schema\n    );\n\n    const instance = new RxStorageInstanceDexie(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n\n    return instance;\n}\n"],"file":"rx-storage-instance-dexie.js"}