{"version":3,"file":"rx-storage-instance-dexie.js","names":["instanceId","now","RxStorageInstanceDexie","storage","databaseName","collectionName","schema","internals","options","settings","changes$","Subject","closed","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","bulkWrite","documentWrites","context","ensureNotClosed","state","ret","success","error","documentKeys","map","writeRow","document","categorized","dexieDb","transaction","dexieTable","dexieDeletedTable","docsInDbMap","Map","getDocsInDb","docsInDbWithInternals","forEach","docWithDexieInternals","doc","fromDexieToStorage","set","categorizeBulkWriteRows","errors","bulkPutDocs","bulkRemoveDocs","bulkPutDeletedDocs","bulkRemoveDeletedDocs","bulkInsertDocs","row","docId","push","bulkUpdateDocs","_deleted","previous","newRxError","args","Promise","all","length","bulkPut","d","fromStorageToDexie","PROMISE_RESOLVE_VOID","bulkDelete","ensureNotFalsy","eventBulk","events","lastState","getNewestOfDocumentStates","Object","values","checkpoint","id","lwt","_meta","endTime","event","next","findDocumentsById","ids","deleted","idx","documentInDb","docsInDb","bulkGet","query","preparedQuery","dexieQuery","count","dexieCount","result","mode","getChangedDocumentsSince","limit","sinceLwt","RX_META_LWT_MINIMUM","sinceId","table","where","above","toArray","changedDocuments","changedDocsNormal","changedDocsDeleted","changedDocs","concat","sortDocumentsByLastWriteTime","slice","lastDoc","lastOfArray","documents","remove","clear","close","changeStream","asObservable","cleanup","minimumDeletedTime","maxDeletionTime","below","toRemove","removeIds","getAttachmentData","_documentId","_attachmentId","Error","complete","closeDexieDb","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","createDexieStorageInstance","params","getDexieDbWithTables","instance","addRxStorageMultiInstanceSupport","RX_STORAGE_NAME_DEXIE","resolve"],"sources":["../../../../src/plugins/dexie/rx-storage-instance-dexie.ts"],"sourcesContent":["import {\n    Subject,\n    Observable\n} from 'rxjs';\nimport {\n    now,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM,\n    sortDocumentsByLastWriteTime,\n    lastOfArray,\n    ensureNotFalsy\n} from '../../util';\nimport type {\n    RxStorageInstance,\n    RxStorageChangeEvent,\n    RxDocumentData,\n    BulkWriteRow,\n    RxStorageBulkWriteResponse,\n    RxStorageQueryResult,\n    RxJsonSchema,\n    RxStorageInstanceCreationParams,\n    EventBulk,\n    StringKeys,\n    RxDocumentDataById,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxStorageDefaultCheckpoint,\n    CategorizeBulkWriteRowsOutput,\n    RxStorageCountResult\n} from '../../types';\nimport {\n    DexiePreparedQuery,\n    DexieSettings,\n    DexieStorageInternals\n} from '../../types/plugins/dexie';\nimport { RxStorageDexie } from './rx-storage-dexie';\nimport {\n    closeDexieDb,\n    fromDexieToStorage,\n    fromStorageToDexie,\n    getDexieDbWithTables,\n    getDocsInDb,\n    RX_STORAGE_NAME_DEXIE\n} from './dexie-helper';\nimport { dexieCount, dexieQuery } from './dexie-query';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows, getNewestOfDocumentStates } from '../../rx-storage-helper';\nimport { addRxStorageMultiInstanceSupport } from '../../rx-storage-multiinstance';\nimport { newRxError } from '../../rx-error';\n\nlet instanceId = now();\n\nexport class RxStorageInstanceDexie<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    DexieStorageInternals,\n    DexieSettings,\n    RxStorageDefaultCheckpoint\n> {\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    private changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\n    public readonly instanceId = instanceId++;\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageDexie,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: DexieStorageInternals,\n        public readonly options: Readonly<DexieSettings>,\n        public readonly settings: DexieSettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    async bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const ret: RxStorageBulkWriteResponse<RxDocType> = {\n            success: {},\n            error: {}\n        };\n\n        const documentKeys: string[] = documentWrites.map(writeRow => writeRow.document[this.primaryPath] as any);\n        let categorized: CategorizeBulkWriteRowsOutput<RxDocType> | undefined = null as any;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                const docsInDbMap = new Map<string, RxDocumentData<RxDocType>>();\n                const docsInDbWithInternals = await getDocsInDb<RxDocType>(this.internals, documentKeys);\n                docsInDbWithInternals.forEach(docWithDexieInternals => {\n                    const doc = docWithDexieInternals ? fromDexieToStorage(docWithDexieInternals) : docWithDexieInternals;\n                    if (doc) {\n                        docsInDbMap.set(doc[this.primaryPath], doc);\n                    }\n                    return doc;\n                });\n\n                categorized = categorizeBulkWriteRows<RxDocType>(\n                    this,\n                    this.primaryPath as any,\n                    docsInDbMap,\n                    documentWrites,\n                    context\n                );\n                ret.error = categorized.errors;\n\n                /**\n                 * Batch up the database operations\n                 * so we can later run them in bulk.\n                 */\n                const bulkPutDocs: any[] = [];\n                const bulkRemoveDocs: string[] = [];\n                const bulkPutDeletedDocs: any[] = [];\n                const bulkRemoveDeletedDocs: string[] = [];\n\n                categorized.bulkInsertDocs.forEach(row => {\n                    const docId: string = (row.document as any)[this.primaryPath];\n                    ret.success[docId] = row.document as any;\n                    bulkPutDocs.push(row.document);\n                });\n                categorized.bulkUpdateDocs.forEach(row => {\n                    const docId: string = (row.document as any)[this.primaryPath];\n                    ret.success[docId] = row.document as any;\n                    if (\n                        row.document._deleted &&\n                        (row.previous && !row.previous._deleted)\n                    ) {\n                        // newly deleted\n                        bulkRemoveDocs.push(docId);\n                        bulkPutDeletedDocs.push(row.document);\n                    } else if (\n                        row.document._deleted &&\n                        row.previous && row.previous._deleted\n                    ) {\n                        // deleted was modified but is still deleted\n                        bulkPutDeletedDocs.push(row.document);\n                    } else if (!row.document._deleted) {\n                        // non-deleted was changed\n                        bulkPutDocs.push(row.document);\n                    } else {\n                        throw newRxError('SNH', { args: { row } });\n                    }\n                });\n\n                await Promise.all([\n                    bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID,\n                    bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID,\n                    bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID\n                ]);\n            });\n\n        if (ensureNotFalsy(categorized).eventBulk.events.length > 0) {\n            const lastState = getNewestOfDocumentStates(\n                this.primaryPath as any,\n                Object.values(ret.success)\n            );\n            ensureNotFalsy(categorized).eventBulk.checkpoint = {\n                id: lastState[this.primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            const endTime = now();\n            ensureNotFalsy(categorized).eventBulk.events.forEach(event => (event as any).endTime = endTime);\n            this.changes$.next(ensureNotFalsy(categorized).eventBulk);\n        }\n\n        return ret;\n    }\n\n    async findDocumentsById(\n        ids: string[],\n        deleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        const ret: RxDocumentDataById<RxDocType> = {};\n\n        await state.dexieDb.transaction(\n            'r',\n            state.dexieTable,\n            state.dexieDeletedTable,\n            async () => {\n                let docsInDb: RxDocumentData<RxDocType>[];\n                if (deleted) {\n                    docsInDb = await getDocsInDb<RxDocType>(this.internals, ids);\n                } else {\n                    docsInDb = await state.dexieTable.bulkGet(ids)\n                }\n                ids.forEach((id, idx) => {\n                    const documentInDb = docsInDb[idx];\n                    if (\n                        documentInDb &&\n                        (!documentInDb._deleted || deleted)\n                    ) {\n                        ret[id] = fromDexieToStorage(documentInDb);\n                    }\n                });\n            });\n        return ret;\n    }\n\n    query(preparedQuery: DexiePreparedQuery<RxDocType>): Promise<RxStorageQueryResult<RxDocType>> {\n        ensureNotClosed(this);\n        return dexieQuery(\n            this,\n            preparedQuery\n        );\n    }\n    async count(\n        preparedQuery: DexiePreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const result = await dexieCount(this, preparedQuery);\n        return {\n            count: result,\n            mode: 'fast'\n        };\n    }\n\n    async getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        ensureNotClosed(this);\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n        const state = await this.internals;\n\n\n        const [changedDocsNormal, changedDocsDeleted] = await Promise.all(\n            [\n                state.dexieTable,\n                state.dexieDeletedTable\n            ].map(async (table) => {\n                const query = table\n                    .where('[_meta.lwt+' + this.primaryPath + ']')\n                    .above([sinceLwt, sinceId])\n                    .limit(limit);\n                const changedDocuments: RxDocumentData<RxDocType>[] = await query.toArray();\n                return changedDocuments.map(d => fromDexieToStorage(d));\n            })\n        );\n        let changedDocs = changedDocsNormal.concat(changedDocsDeleted);\n\n        changedDocs = sortDocumentsByLastWriteTime(this.primaryPath as any, changedDocs);\n        changedDocs = changedDocs.slice(0, limit);\n\n        const lastDoc = lastOfArray(changedDocs);\n        return {\n            documents: changedDocs,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        };\n    }\n\n    async remove(): Promise<void> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await Promise.all([\n            state.dexieDeletedTable.clear(),\n            state.dexieTable.clear()\n        ]);\n        return this.close();\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotClosed(this);\n        return this.changes$.asObservable();\n    }\n\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\n        ensureNotClosed(this);\n        const state = await this.internals;\n        await state.dexieDb.transaction(\n            'rw',\n            state.dexieDeletedTable,\n            async () => {\n                const maxDeletionTime = now() - minimumDeletedTime;\n                const toRemove = await state.dexieDeletedTable\n                    .where('_meta.lwt')\n                    .below(maxDeletionTime)\n                    .toArray();\n                const removeIds: string[] = toRemove.map(doc => doc[this.primaryPath]);\n                await state.dexieDeletedTable.bulkDelete(removeIds);\n            }\n        );\n\n        /**\n         * TODO instead of deleting all deleted docs at once,\n         * only clean up some of them and return false if there are more documents to clean up.\n         * This ensures that when many documents have to be purged,\n         * we do not block the more important tasks too long.\n         */\n        return true;\n    }\n\n    getAttachmentData(_documentId: string, _attachmentId: string): Promise<string> {\n        ensureNotClosed(this);\n        throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n    }\n\n    close(): Promise<void> {\n        ensureNotClosed(this);\n        this.closed = true;\n        this.changes$.complete();\n        closeDexieDb(this.internals);\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return new Subject();\n    }\n    async resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> { }\n\n}\n\n\nexport function createDexieStorageInstance<RxDocType>(\n    storage: RxStorageDexie,\n    params: RxStorageInstanceCreationParams<RxDocType, DexieSettings>,\n    settings: DexieSettings\n): Promise<RxStorageInstanceDexie<RxDocType>> {\n    const internals = getDexieDbWithTables(\n        params.databaseName,\n        params.collectionName,\n        settings,\n        params.schema\n    );\n\n    const instance = new RxStorageInstanceDexie(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n\n    addRxStorageMultiInstanceSupport(\n        RX_STORAGE_NAME_DEXIE,\n        params,\n        instance\n    );\n\n    return Promise.resolve(instance);\n}\n\n\n\nfunction ensureNotClosed(\n    instance: RxStorageInstanceDexie<any>\n) {\n    if (instance.closed) {\n        throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n    }\n}\n"],"mappings":"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"}