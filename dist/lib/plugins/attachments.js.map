{"version":3,"file":"attachments.js","names":["preMigrateDocument","data","attachments","docData","_attachments","newAttachments","Promise","all","Object","keys","map","attachmentId","attachment","docPrimary","oldCollection","schema","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","digest","length","type","putAttachment","attachmentData","skipIfSame","ensureSchemaSupportsAttachments","dataSize","blobBufferUtil","size","toBase64String","dataString","id","hashAttachmentData","then","hash","newDigest","_atomicQueue","_data","currentMeta","getAttachment","docWriteData","flatCloneDocWithMeta","flatClone","writeRow","previous","document","writeSingle","collection","writeResult","fromStorageInstanceResult","newData","_rev","_dataSync$","next","attachmentBase64String","binary","b64DecodeUnicode","err","console","log","pouchHash","getAttachmentSize","atob","doc","schemaJson","jsonSchema","newRxError","link","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainDataBase64","createBlobBufferFromBase64","getStringData","toString","rxDocument","getValue","allAttachments","postMigrateDocument","_action","PROMISE_RESOLVE_VOID","RxDBAttachmentsPlugin","name","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","after"],"sources":["../../../src/plugins/attachments.ts"],"sourcesContent":["import {\n    map\n} from 'rxjs/operators';\n\nimport {\n    b64DecodeUnicode,\n    blobBufferUtil,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../types';\nimport { flatCloneDocWithMeta, writeSingle } from '../rx-storage-helper';\nimport { pouchHash } from './pouchdb';\n\n\n/**\n * To be able to support PouchDB with attachments,\n * we have to use the md5 hashing here, even if the RxDatabase itself\n * has a different hashing function.\n */\nexport function hashAttachmentData(\n    attachmentBase64String: string\n): Promise<string> {\n    let binary;\n    try {\n        binary = b64DecodeUnicode(attachmentBase64String);\n    } catch (err) {\n        console.log('could not run b64DecodeUnicode() on ' + attachmentBase64String);\n        throw err;\n    }\n    return pouchHash(binary);\n}\n\nexport function getAttachmentSize(\n    attachmentBase64String: string\n): number {\n    return atob(attachmentBase64String).length;\n}\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: flatClone(this.doc._data), // TODO do we need a flatClone here?\n                        document: docWriteData\n                    },\n                    'attachment-remove'\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        const ret = await blobBufferUtil.createBlobBufferFromBase64(\n            plainDataBase64,\n            this.type as any\n        );\n        return ret;\n    }\n\n    async getStringData(): Promise<string> {\n        const data = await this.getData();\n        const asString = await blobBufferUtil.toString(data);\n        return asString;\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    attachmentData: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    const dataSize = blobBufferUtil.size(attachmentData.data);\n    const dataString = await blobBufferUtil.toBase64String(attachmentData.data);\n\n    const id = attachmentData.id;\n    const type = attachmentData.type;\n    const data = dataString;\n\n    const newDigest = await hashAttachmentData(\n        dataString\n    ).then(hash => 'md5-' + hash);\n\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatCloneDocWithMeta(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            docWriteData._attachments[id] = {\n                digest: newDigest,\n                length: dataSize,\n                type,\n                data\n            };\n            const writeRow = {\n                previous: flatClone(this._data),\n                document: flatClone(docWriteData)\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow,\n                'attachment-put'\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n                const rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                newAttachments[attachmentId] = {\n                    digest: attachment.digest,\n                    length: attachment.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachments data buffers directly in the document.\n     */\n    return PROMISE_RESOLVE_VOID;\n}\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.putAttachment = putAttachment;\n            proto.getAttachment = getAttachment;\n            proto.allAttachments = allAttachments;\n            Object.defineProperty(proto, 'allAttachments$', {\n                get: function allAttachments$() {\n                    return this._dataSync$\n                        .pipe(\n                            map((data: any) => {\n                                if (!data['_attachments']) {\n                                    return {};\n                                }\n                                return data['_attachments'];\n                            }),\n                            map((attachmentsData: any) => Object.entries(\n                                attachmentsData\n                            )),\n                            map(entries => {\n                                return (entries as any)\n                                    .map(([id, attachmentData]: any) => {\n                                        return fromStorageInstanceResult(\n                                            id,\n                                            attachmentData,\n                                            this\n                                        );\n                                    });\n                            })\n                        );\n                }\n            });\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preMigrateDocument: {\n            after: preMigrateDocument\n        },\n        postMigrateDocument: {\n            after: postMigrateDocument\n        }\n    }\n};\n"],"mappings":"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"}