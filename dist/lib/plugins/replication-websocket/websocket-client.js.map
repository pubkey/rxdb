{"version":3,"file":"websocket-client.js","names":["ensureIsWebsocket","w","is","CLOSING","console","dir","Error","replicateWithWebsocketServer","options","getWebSocket","url","collection","database","socketState","wsClient","socket","messages$","message$","requestCounter","getRequestId","count","token","requestFlag","randomCouchString","replicationState","replicateRxCollection","replicationIdentifier","pull","batchSize","stream$","pipe","filter","msg","id","name","map","result","handler","lastPulledCheckpoint","requestId","request","method","params","send","JSON","stringify","firstValueFrom","push","docs","error$","subscribe","err","subjects","error","next","connected$","isConnected","reSync","streamRequest","onDestroy","removeWebSocketRef","cacheKey","has","WEBSOCKET_BY_CACHE_KEY","get","IsomorphicWebSocket","ReconnectingWebSocket","WebSocket","BehaviorSubject","openPromise","Promise","res","onopen","onclose","Subject","onmessage","messageObj","message","parse","data","onerror","emitError","newRxError","errors","Array","isArray","direction","refCount","set","Map","obj","getFromMapOrThrow","complete","close"],"sources":["../../../../src/plugins/replication-websocket/websocket-client.ts"],"sourcesContent":["import { replicateRxCollection, RxReplicationState } from '../replication';\nimport {\n    WebsocketClientOptions,\n    WebsocketMessageResponseType,\n    WebsocketMessageType\n} from './websocket-types';\n\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport IsomorphicWebSocket from 'isomorphic-ws';\nimport {\n    getFromMapOrThrow,\n    randomCouchString\n} from '../../util';\nimport {\n    filter,\n    map,\n    Subject,\n    firstValueFrom,\n    BehaviorSubject\n} from 'rxjs';\nimport {\n    RxDatabase,\n    RxError,\n    RxReplicationWriteToMasterRow\n} from '../../types';\nimport { newRxError } from '../../rx-error';\n\nexport type WebsocketWithRefCount = {\n    url: string;\n    socket: ReconnectingWebSocket;\n    refCount: number;\n    openPromise: Promise<void>;\n    connected$: BehaviorSubject<boolean>;\n    message$: Subject<WebsocketMessageResponseType>;\n    error$: Subject<RxError>\n};\n\n\n/**\n * Copied and adapter from the 'reconnecting-websocket' npm module.\n * Some bundlers have problems with bundling the isomorphic-ws plugin\n * so we directly check the correctness in RxDB to ensure that we can\n * throw a helpfull error.\n */\nfunction ensureIsWebsocket(w: typeof IsomorphicWebSocket) {\n    const is = typeof w !== 'undefined' && !!w && w.CLOSING === 2;\n    if (!is) {\n        console.dir(w);\n        throw new Error('websocket not valid');\n    }\n}\n\n/**\n * Reuse the same socket even when multiple\n * collection replicate with the same server at once.\n */\nexport const WEBSOCKET_BY_CACHE_KEY: Map<string, WebsocketWithRefCount> = new Map();\nexport async function getWebSocket(\n    url: string,\n    database: RxDatabase<any, any, any>\n): Promise<WebsocketWithRefCount> {\n    /**\n     * Also use the database token as cache-key\n     * to make it easier to test and debug\n     * multi-instance setups.\n     */\n    const cacheKey = url + '|||' + database.token;\n\n    let has = WEBSOCKET_BY_CACHE_KEY.get(cacheKey);\n    if (!has) {\n        ensureIsWebsocket(IsomorphicWebSocket);\n        const wsClient = new ReconnectingWebSocket(\n            url,\n            [],\n            {\n                WebSocket: IsomorphicWebSocket\n            }\n        );\n\n        const connected$ = new BehaviorSubject<boolean>(false);\n        const openPromise = new Promise<void>(res => {\n            wsClient.onopen = () => {\n                connected$.next(true);\n                res();\n            };\n        });\n        wsClient.onclose = () => {\n            connected$.next(false);\n        };\n\n        const message$ = new Subject<WebsocketMessageResponseType>();\n        wsClient.onmessage = (messageObj) => {\n            const message: WebsocketMessageResponseType = JSON.parse(messageObj.data);\n            message$.next(message);\n        };\n\n        const error$ = new Subject<any>();\n        wsClient.onerror = (err) => {\n            const emitError = newRxError('RC_STREAM', {\n                errors: Array.isArray(err) ? err as any : [err],\n                direction: 'pull'\n            });\n            error$.next(emitError);\n        }\n\n\n        has = {\n            url,\n            socket: wsClient,\n            openPromise,\n            refCount: 1,\n            connected$,\n            message$,\n            error$\n        };\n        WEBSOCKET_BY_CACHE_KEY.set(cacheKey, has);\n    } else {\n        has.refCount = has.refCount + 1;\n    }\n\n\n    await has.openPromise;\n    return has;\n}\n\nexport function removeWebSocketRef(\n    url: string,\n    database: RxDatabase\n) {\n    const cacheKey = url + '|||' + database.token;\n    const obj = getFromMapOrThrow(WEBSOCKET_BY_CACHE_KEY, cacheKey);\n    obj.refCount = obj.refCount - 1;\n    if (obj.refCount === 0) {\n        WEBSOCKET_BY_CACHE_KEY.delete(cacheKey);\n        obj.connected$.complete();\n        obj.socket.close();\n    }\n}\n\n\n\nexport async function replicateWithWebsocketServer<RxDocType, CheckpointType>(\n    options: WebsocketClientOptions<RxDocType>\n): Promise<RxReplicationState<RxDocType, CheckpointType>> {\n    const socketState = await getWebSocket(options.url, options.collection.database);\n    const wsClient = socketState.socket;\n\n    const messages$ = socketState.message$;\n\n    let requestCounter = 0;\n    const requestFlag = randomCouchString(10);\n    function getRequestId() {\n        const count = requestCounter++;\n        return options.collection.database.token + '|' + requestFlag + '|' + count;\n    }\n    const replicationState = replicateRxCollection<RxDocType, CheckpointType>({\n        collection: options.collection,\n        replicationIdentifier: 'websocket-' + options.url,\n        pull: {\n            batchSize: options.batchSize,\n            stream$: messages$.pipe(\n                filter(msg => msg.id === 'stream' && msg.collection === options.collection.name),\n                map(msg => msg.result)\n            ),\n            async handler(lastPulledCheckpoint: CheckpointType, batchSize: number) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterChangesSince',\n                    params: [lastPulledCheckpoint, batchSize]\n                }\n                wsClient.send(JSON.stringify(request));\n                const result = await firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n                return result;\n            }\n        },\n        push: {\n            batchSize: options.batchSize,\n            handler(docs: RxReplicationWriteToMasterRow<RxDocType>[]) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterWrite',\n                    params: [docs]\n                }\n                wsClient.send(JSON.stringify(request));\n                return firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n            }\n        }\n    });\n\n    socketState.error$.subscribe(err => replicationState.subjects.error.next(err));\n\n    socketState.connected$.subscribe(isConnected => {\n        if (isConnected) {\n            /**\n             * When the client goes offline and online again,\n             * we have to send a 'RESYNC' signal because the client\n             * might have missed out events while being offline.\n             */\n            replicationState.reSync();\n\n            /**\n             * Because reconnecting creates a new websocket-instance,\n             * we have to start the changestream from the remote again\n             * each time.\n             */\n            const streamRequest: WebsocketMessageType = {\n                id: 'stream',\n                collection: options.collection.name,\n                method: 'masterChangeStream$',\n                params: []\n            }\n            wsClient.send(JSON.stringify(streamRequest));\n        }\n    });\n\n    options.collection.onDestroy.push(() => removeWebSocketRef(options.url, options.collection.database));\n    return replicationState;\n}\n"],"mappings":"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"}