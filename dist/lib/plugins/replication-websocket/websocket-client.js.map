{"version":3,"file":"websocket-client.js","names":["ensureIsWebsocket","w","is","CLOSING","console","dir","Error","WEBSOCKET_BY_CACHE_KEY","Map","getWebSocket","url","databaseToken","cacheKey","has","get","IsomorphicWebSocket","wsClient","ReconnectingWebSocket","WebSocket","connected$","BehaviorSubject","openPromise","Promise","res","onopen","next","onclose","message$","Subject","onmessage","messageObj","message","JSON","parse","data","error$","onerror","err","emitError","newRxError","errors","toArray","map","er","errorToPlainJson","direction","socket","refCount","set","removeWebSocketRef","database","token","obj","getFromMapOrThrow","complete","close","replicateWithWebsocketServer","options","getRequestId","count","requestCounter","collection","requestFlag","socketState","messages$","randomCouchString","replicationState","replicateRxCollection","replicationIdentifier","live","pull","batchSize","stream$","pipe","filter","msg","id","name","result","handler","lastPulledCheckpoint","requestId","request","method","params","send","stringify","firstValueFrom","push","docs","subscribe","subjects","error","isConnected","reSync","streamRequest","onDestroy"],"sources":["../../../../src/plugins/replication-websocket/websocket-client.ts"],"sourcesContent":["import { replicateRxCollection, RxReplicationState } from '../replication';\nimport {\n    WebsocketClientOptions,\n    WebsocketMessageType\n} from './websocket-types';\n\nimport ReconnectingWebSocket from 'reconnecting-websocket';\nimport IsomorphicWebSocket from 'isomorphic-ws';\nimport {\n    errorToPlainJson,\n    getFromMapOrThrow,\n    randomCouchString,\n    toArray\n} from '../../util';\nimport {\n    filter,\n    map,\n    Subject,\n    firstValueFrom,\n    BehaviorSubject\n} from 'rxjs';\nimport {\n    RxDatabase,\n    RxError,\n    RxReplicationWriteToMasterRow\n} from '../../types';\nimport { newRxError } from '../../rx-error';\n\nexport type WebsocketWithRefCount = {\n    url: string;\n    socket: ReconnectingWebSocket;\n    refCount: number;\n    openPromise: Promise<void>;\n    connected$: BehaviorSubject<boolean>;\n    message$: Subject<any>;\n    error$: Subject<RxError>;\n};\n\n\n/**\n * Copied and adapter from the 'reconnecting-websocket' npm module.\n * Some bundlers have problems with bundling the isomorphic-ws plugin\n * so we directly check the correctness in RxDB to ensure that we can\n * throw a helpful error.\n */\nfunction ensureIsWebsocket(w: typeof IsomorphicWebSocket) {\n    const is = typeof w !== 'undefined' && !!w && w.CLOSING === 2;\n    if (!is) {\n        console.dir(w);\n        throw new Error('websocket not valid');\n    }\n}\n\n/**\n * Reuse the same socket even when multiple\n * collection replicate with the same server at once.\n */\nexport const WEBSOCKET_BY_CACHE_KEY: Map<string, WebsocketWithRefCount> = new Map();\nexport async function getWebSocket(\n    url: string,\n    /**\n     * The value of RxDatabase.token.\n     */\n    databaseToken: string\n): Promise<WebsocketWithRefCount> {\n    /**\n     * Also use the database token as cache-key\n     * to make it easier to test and debug\n     * multi-instance setups.\n     */\n    const cacheKey = url + '|||' + databaseToken;\n\n    let has = WEBSOCKET_BY_CACHE_KEY.get(cacheKey);\n    if (!has) {\n        ensureIsWebsocket(IsomorphicWebSocket);\n        const wsClient = new ReconnectingWebSocket(\n            url,\n            [],\n            {\n                WebSocket: IsomorphicWebSocket\n            }\n        );\n\n        const connected$ = new BehaviorSubject<boolean>(false);\n        const openPromise = new Promise<void>(res => {\n            wsClient.onopen = () => {\n                connected$.next(true);\n                res();\n            };\n        });\n        wsClient.onclose = () => {\n            connected$.next(false);\n        };\n\n        const message$ = new Subject<any>();\n        wsClient.onmessage = (messageObj) => {\n            const message = JSON.parse(messageObj.data);\n            message$.next(message);\n        };\n\n        const error$ = new Subject<any>();\n        wsClient.onerror = (err) => {\n            const emitError = newRxError('RC_STREAM', {\n                errors: toArray(err).map((er: any) => errorToPlainJson(er)),\n                direction: 'pull'\n            });\n            error$.next(emitError);\n        };\n\n\n        has = {\n            url,\n            socket: wsClient,\n            openPromise,\n            refCount: 1,\n            connected$,\n            message$,\n            error$\n        };\n        WEBSOCKET_BY_CACHE_KEY.set(cacheKey, has);\n    } else {\n        has.refCount = has.refCount + 1;\n    }\n\n\n    await has.openPromise;\n    return has;\n}\n\nexport function removeWebSocketRef(\n    url: string,\n    database: RxDatabase\n) {\n    const cacheKey = url + '|||' + database.token;\n    const obj = getFromMapOrThrow(WEBSOCKET_BY_CACHE_KEY, cacheKey);\n    obj.refCount = obj.refCount - 1;\n    if (obj.refCount === 0) {\n        WEBSOCKET_BY_CACHE_KEY.delete(cacheKey);\n        obj.connected$.complete();\n        obj.socket.close();\n    }\n}\n\n\n\nexport async function replicateWithWebsocketServer<RxDocType, CheckpointType>(\n    options: WebsocketClientOptions<RxDocType>\n): Promise<RxReplicationState<RxDocType, CheckpointType>> {\n    const socketState = await getWebSocket(options.url, options.collection.database.token);\n    const wsClient = socketState.socket;\n\n    const messages$ = socketState.message$;\n\n    let requestCounter = 0;\n    const requestFlag = randomCouchString(10);\n    function getRequestId() {\n        const count = requestCounter++;\n        return options.collection.database.token + '|' + requestFlag + '|' + count;\n    }\n    const replicationState = replicateRxCollection<RxDocType, CheckpointType>({\n        collection: options.collection,\n        replicationIdentifier: 'websocket-' + options.url,\n        live: options.live,\n        pull: {\n            batchSize: options.batchSize,\n            stream$: messages$.pipe(\n                filter(msg => msg.id === 'stream' && msg.collection === options.collection.name),\n                map(msg => msg.result)\n            ),\n            async handler(lastPulledCheckpoint: CheckpointType, batchSize: number) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterChangesSince',\n                    params: [lastPulledCheckpoint, batchSize]\n                };\n                wsClient.send(JSON.stringify(request));\n                const result = await firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n                return result;\n            }\n        },\n        push: {\n            batchSize: options.batchSize,\n            handler(docs: RxReplicationWriteToMasterRow<RxDocType>[]) {\n                const requestId = getRequestId();\n                const request: WebsocketMessageType = {\n                    id: requestId,\n                    collection: options.collection.name,\n                    method: 'masterWrite',\n                    params: [docs]\n                };\n                wsClient.send(JSON.stringify(request));\n                return firstValueFrom(\n                    messages$.pipe(\n                        filter(msg => msg.id === requestId),\n                        map(msg => msg.result)\n                    )\n                );\n            }\n        }\n    });\n\n    socketState.error$.subscribe(err => replicationState.subjects.error.next(err));\n\n    socketState.connected$.subscribe(isConnected => {\n        if (isConnected) {\n            /**\n             * When the client goes offline and online again,\n             * we have to send a 'RESYNC' signal because the client\n             * might have missed out events while being offline.\n             */\n            replicationState.reSync();\n\n            /**\n             * Because reconnecting creates a new websocket-instance,\n             * we have to start the changestream from the remote again\n             * each time.\n             */\n            const streamRequest: WebsocketMessageType = {\n                id: 'stream',\n                collection: options.collection.name,\n                method: 'masterChangeStream$',\n                params: []\n            };\n            wsClient.send(JSON.stringify(streamRequest));\n        }\n    });\n\n    options.collection.onDestroy.push(() => removeWebSocketRef(options.url, options.collection.database));\n    return replicationState;\n}\n"],"mappings":"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"}