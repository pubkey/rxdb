{"version":3,"file":"index.js","names":["backupSingleDocument","rxDocument","options","data","toJSON","writtenFiles","docFolder","documentFolder","primary","clearFolder","fileLocation","path","join","writeJsonToFile","push","attachments","attachmentsFolder","ensureFolderExists","allAttachments","Promise","all","map","attachment","getData","content","attachmentFileLocation","id","writeToFile","BACKUP_STATES_BY_DB","WeakMap","addToBackupStates","db","state","has","set","ar","getFromMapOrThrow","newRxError","RxBackupState","database","isStopped","subs","persistRunning","PROMISE_RESOLVE_VOID","initialReplicationDone$","BehaviorSubject","internalWriteEvents$","Subject","writeEvents$","asObservable","batchSize","prepareFolders","persistOnce","then","_persistOnce","getMeta","meta","Object","entries","collections","collectionName","collection","primaryKey","schema","primaryPath","processedDocuments","Set","requestIdlePromise","collectionStates","lastCheckpoint","checkpoint","hasMore","storageInstance","getChangedDocumentsSince","changesResult","documents","length","docIds","doc","filter","add","elem","pos","arr","indexOf","findByIds","exec","docs","size","Array","from","values","next","name","documentId","files","deleted","docId","deleteFolder","setMeta","getValue","watchForChanges","forEach","changes$","changeStream","sub","subscribe","awaitInitialBackup","firstValueFrom","pipe","v","cancel","PROMISE_RESOLVE_FALSE","unsubscribe","PROMISE_RESOLVE_TRUE","backup","backupState","live","RxDBBackupPlugin","rxdb","prototypes","RxDatabase","proto","hooks","preDestroyRxDatabase","after","states","get"],"sources":["../../../../src/plugins/backup/index.ts"],"sourcesContent":["import * as path from 'path';\nimport {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    filter,\n    map\n} from 'rxjs/operators';\nimport { newRxError } from '../../rx-error';\nimport type {\n    BackupOptions,\n    RxBackupWriteEvent,\n    RxCollection,\n    RxDatabase,\n    RxDocument,\n    RxPlugin\n} from '../../types';\nimport {\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID\n} from '../../util';\nimport {\n    clearFolder,\n    deleteFolder,\n    documentFolder,\n    ensureFolderExists,\n    getMeta,\n    prepareFolders,\n    setMeta,\n    writeJsonToFile,\n    writeToFile\n} from './file-util';\n\n\n/**\n * Backups a single documents,\n * returns the paths to all written files\n */\nexport async function backupSingleDocument(\n    rxDocument: RxDocument<any, any>,\n    options: BackupOptions\n): Promise<string[]> {\n    const data = rxDocument.toJSON(true);\n    const writtenFiles: string[] = [];\n\n    const docFolder = documentFolder(options, rxDocument.primary);\n    await clearFolder(docFolder);\n\n    const fileLocation = path.join(\n        docFolder,\n        'document.json'\n    );\n    await writeJsonToFile(fileLocation, data);\n    writtenFiles.push(fileLocation);\n\n    if (options.attachments) {\n        const attachmentsFolder = path.join(\n            docFolder,\n            'attachments'\n        );\n        ensureFolderExists(attachmentsFolder);\n        const attachments = (rxDocument as RxDocument).allAttachments();\n        await Promise.all(\n            attachments\n                .map(async (attachment) => {\n                    const content = await attachment.getData();\n                    const attachmentFileLocation = path.join(\n                        attachmentsFolder,\n                        attachment.id\n                    );\n                    await writeToFile(attachmentFileLocation, content);\n                    writtenFiles.push(attachmentFileLocation);\n                })\n        );\n    }\n\n    return writtenFiles;\n}\n\nconst BACKUP_STATES_BY_DB: WeakMap<RxDatabase, RxBackupState[]> = new WeakMap();\nfunction addToBackupStates(db: RxDatabase, state: RxBackupState) {\n    if (!BACKUP_STATES_BY_DB.has(db)) {\n        BACKUP_STATES_BY_DB.set(db, []);\n    }\n    const ar = getFromMapOrThrow(BACKUP_STATES_BY_DB, db);\n    if (!ar) {\n        throw newRxError('SNH');\n    }\n    ar.push(state);\n}\n\nexport class RxBackupState {\n    public isStopped: boolean = false;\n    private subs: Subscription[] = [];\n    private persistRunning: Promise<void> = PROMISE_RESOLVE_VOID;\n    private initialReplicationDone$: BehaviorSubject<boolean> = new BehaviorSubject(false as any);\n\n    private readonly internalWriteEvents$: Subject<RxBackupWriteEvent> = new Subject();\n    public readonly writeEvents$: Observable<RxBackupWriteEvent> = this.internalWriteEvents$.asObservable();\n\n    constructor(\n        public readonly database: RxDatabase,\n        public readonly options: BackupOptions\n    ) {\n        if (!this.options.batchSize) {\n            this.options.batchSize = 10;\n        }\n        addToBackupStates(database, this);\n        prepareFolders(database, options);\n    }\n\n    /**\n     * Persists all data from all collections,\n     * beginning from the oldest sequence checkpoint\n     * to the newest one.\n     * Do not call this while it is already running.\n     * Returns true if there are more documents to process\n     */\n    public persistOnce() {\n        return this.persistRunning = this.persistRunning.then(() => this._persistOnce());\n    }\n\n    public async _persistOnce() {\n        const meta = await getMeta(this.options);\n\n        await Promise.all(\n            Object\n                .entries(this.database.collections)\n                .map(async ([collectionName, collection]) => {\n                    const primaryKey = collection.schema.primaryPath;\n                    const processedDocuments: Set<string> = new Set();\n\n                    await this.database.requestIdlePromise();\n\n                    if (!meta.collectionStates[collectionName]) {\n                        meta.collectionStates[collectionName] = {};\n                    }\n                    let lastCheckpoint = meta.collectionStates[collectionName].checkpoint;\n\n                    let hasMore = true;\n                    while (hasMore && !this.isStopped) {\n                        await this.database.requestIdlePromise();\n                        const changesResult = await collection.storageInstance.getChangedDocumentsSince(\n                            this.options.batchSize ? this.options.batchSize : 0,\n                            lastCheckpoint\n                        );\n                        lastCheckpoint = changesResult.documents.length > 0 ? changesResult.checkpoint : lastCheckpoint;\n                        meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\n\n                        const docIds: string[] = changesResult.documents\n                            .map(doc => doc[primaryKey])\n                            .filter(id => {\n                                if (\n                                    processedDocuments.has(id)\n                                ) {\n                                    return false;\n                                } else {\n                                    processedDocuments.add(id);\n                                    return true;\n                                }\n                            })\n                            .filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique\n                        await this.database.requestIdlePromise();\n\n                        const docs: Map<string, RxDocument> = await collection.findByIds(docIds).exec();\n                        if (docs.size === 0) {\n                            hasMore = false;\n                            continue;\n                        }\n                        await Promise.all(\n                            Array\n                                .from(docs.values())\n                                .map(async (doc) => {\n                                    const writtenFiles = await backupSingleDocument(doc, this.options);\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: doc.primary,\n                                        files: writtenFiles,\n                                        deleted: false\n                                    });\n                                })\n                        );\n                        // handle deleted documents\n                        await Promise.all(\n                            docIds\n                                .filter(docId => !docs.has(docId))\n                                .map(async (docId) => {\n                                    await deleteFolder(documentFolder(this.options, docId));\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: docId,\n                                        files: [],\n                                        deleted: true\n                                    });\n                                })\n                        );\n                    }\n                    meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\n                    await setMeta(this.options, meta);\n                })\n        );\n\n        if (!this.initialReplicationDone$.getValue()) {\n            this.initialReplicationDone$.next(true);\n        }\n    }\n\n    public watchForChanges() {\n        const collections: RxCollection[] = Object.values(this.database.collections);\n        collections.forEach(collection => {\n            const changes$ = collection.storageInstance.changeStream();\n            const sub = changes$.subscribe(() => {\n                this.persistOnce();\n            });\n            this.subs.push(sub);\n        });\n    }\n\n    /**\n     * Returns a promise that resolves when the initial backup is done\n     * and the filesystem is in sync with the database state\n     */\n    public awaitInitialBackup(): Promise<boolean> {\n        return firstValueFrom(\n            this.initialReplicationDone$.pipe(\n                filter(v => !!v),\n                map(() => true)\n            )\n        );\n    }\n\n    cancel(): Promise<boolean> {\n        if (this.isStopped) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        this.isStopped = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        return PROMISE_RESOLVE_TRUE;\n    }\n}\n\n\nexport function backup(\n    this: RxDatabase,\n    options: BackupOptions\n): RxBackupState {\n    const backupState = new RxBackupState(this, options);\n    backupState.persistOnce();\n\n    if (options.live) {\n        backupState.watchForChanges();\n    }\n\n    return backupState;\n}\n\nexport * from './file-util';\nexport const RxDBBackupPlugin: RxPlugin = {\n    name: 'backup',\n    rxdb: true,\n    prototypes: {\n        RxDatabase(proto: any) {\n            proto.backup = backup;\n        }\n    },\n    hooks: {\n        preDestroyRxDatabase: {\n            after: function preDestroyRxDatabase(db: RxDatabase) {\n                const states = BACKUP_STATES_BY_DB.get(db);\n                if (states) {\n                    states.forEach(state => state.cancel());\n                }\n            }\n        }\n    }\n};\n"],"mappings":"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"}