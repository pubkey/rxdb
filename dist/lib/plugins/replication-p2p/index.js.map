{"version":3,"file":"index.js","names":["_rxjs","require","_plugin","_replicationProtocol","_utils","_leaderElection","_replication","_p2pHelper","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_p2pTypes","_connectionHandlerSimplePeer","replicateP2P","options","collection","addRxPlugin","RxDBLeaderElectionPlugin","pull","batchSize","push","database","multiInstance","waitForLeadership","requestCounter","requestFlag","randomCouchString","getRequestId","count","token","storageToken","pool","RxP2PReplicationPool","connectionHandlerCreator","subs","connectionHandler","error$","subscribe","err","next","disconnect$","peer","removePeer","message$","pipe","filter","data","message","method","send","id","result","connectSub","connect$","canceled","tokenResponse","sendMessageAndAwaitAnswer","params","peerToken","isMaster","isMasterInP2PReplication","hashFunction","replicationState","masterHandler","masterReplicationHandler","masterChangeStreamSub","masterChangeStream$","ev","streamResponse","p","unsubscribe","messageSub","msgPeer","bind","response","replicateRxCollection","replicationIdentifier","name","topic","join","autoStart","deletedField","live","retryTime","assign","handler","lastPulledCheckpoint","answer","ensureNotFalsy","stream$","response$","m","map","undefined","docs","addPeer","peerStates$","BehaviorSubject","Map","Subject","onDestroy","cancel","rxStorageInstanceToReplicationHandler","storageInstance","conflictHandler","_proto","peerState","getValue","set","getFromMapOrThrow","delete","sub","awaitFirstPeer","firstValueFrom","peerStates","size","Array","from","destroy"],"sources":["../../../../src/plugins/replication-p2p/index.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    filter,\n    firstValueFrom,\n    map,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport { addRxPlugin } from '../../plugin';\nimport { rxStorageInstanceToReplicationHandler } from '../../replication-protocol';\nimport type {\n    RxCollection,\n    RxError,\n    RxReplicationHandler,\n    RxReplicationWriteToMasterRow,\n    RxTypeError\n} from '../../types';\nimport { ensureNotFalsy, getFromMapOrThrow, randomCouchString } from '../../plugins/utils';\nimport { RxDBLeaderElectionPlugin } from '../leader-election';\nimport { replicateRxCollection } from '../replication';\nimport { isMasterInP2PReplication, sendMessageAndAwaitAnswer } from './p2p-helper';\nimport type {\n    P2PConnectionHandler,\n    P2PPeer,\n    P2PPeerState,\n    P2PReplicationCheckpoint,\n    P2PResponse,\n    RxP2PReplicationState,\n    SyncOptionsP2P\n} from './p2p-types';\n\n\nexport async function replicateP2P<RxDocType>(\n    options: SyncOptionsP2P<RxDocType>\n): Promise<RxP2PReplicationPool<RxDocType>> {\n    const collection = options.collection;\n    addRxPlugin(RxDBLeaderElectionPlugin);\n\n    // fill defaults\n    if (options.pull) {\n        if (!options.pull.batchSize) {\n            options.pull.batchSize = 20;\n        }\n    }\n    if (options.push) {\n        if (!options.push.batchSize) {\n            options.push.batchSize = 20;\n        }\n    }\n\n    if (collection.database.multiInstance) {\n        await collection.database.waitForLeadership();\n    }\n\n    // used to easier debug stuff\n    let requestCounter = 0;\n    const requestFlag = randomCouchString(10);\n    function getRequestId() {\n        const count = requestCounter++;\n        return collection.database.token + '|' + requestFlag + '|' + count;\n    }\n\n    const storageToken = await collection.database.storageToken;\n    const pool = new RxP2PReplicationPool(\n        collection,\n        options,\n        options.connectionHandlerCreator(options)\n    );\n\n\n    pool.subs.push(\n        pool.connectionHandler.error$.subscribe(err => pool.error$.next(err)),\n        pool.connectionHandler.disconnect$.subscribe(peer => pool.removePeer(peer))\n    );\n\n    /**\n     * Answer if someone requests our storage token\n     */\n    pool.subs.push(\n        pool.connectionHandler.message$.pipe(\n            filter(data => data.message.method === 'token')\n        ).subscribe(data => {\n            pool.connectionHandler.send(data.peer, {\n                id: data.message.id,\n                result: storageToken\n            });\n        })\n    );\n\n    const connectSub = pool.connectionHandler.connect$\n        .pipe(\n            filter(() => !pool.canceled)\n        )\n        .subscribe(async (peer) => {\n            /**\n             * TODO ensure both know the correct secret\n             */\n            const tokenResponse = await sendMessageAndAwaitAnswer(\n                pool.connectionHandler,\n                peer,\n                {\n                    id: getRequestId(),\n                    method: 'token',\n                    params: []\n                }\n            );\n            const peerToken: string = tokenResponse.result;\n            const isMaster = isMasterInP2PReplication(collection.database.hashFunction, storageToken, peerToken);\n\n            let replicationState: RxP2PReplicationState<RxDocType> | undefined;\n            if (isMaster) {\n                const masterHandler = pool.masterReplicationHandler;\n                const masterChangeStreamSub = masterHandler.masterChangeStream$.subscribe(ev => {\n                    const streamResponse: P2PResponse = {\n                        id: 'masterChangeStream$',\n                        result: ev\n                    };\n                    pool.connectionHandler.send(peer, streamResponse);\n                });\n\n                // clean up the subscription\n                pool.subs.push(\n                    masterChangeStreamSub,\n                    pool.connectionHandler.disconnect$.pipe(\n                        filter(p => p.id === peer.id)\n                    ).subscribe(() => masterChangeStreamSub.unsubscribe())\n                );\n\n                const messageSub = pool.connectionHandler.message$\n                    .pipe(\n                        filter(data => data.peer.id === peer.id),\n                        filter(data => data.message.method !== 'token')\n                    )\n                    .subscribe(async (data) => {\n                        const { peer: msgPeer, message } = data;\n                        /**\n                         * If it is not a function,\n                         * it means that the client requested the masterChangeStream$\n                         */\n                        const method = (masterHandler as any)[message.method].bind(masterHandler);\n                        const result = await (method as any)(...message.params);\n                        const response: P2PResponse = {\n                            id: message.id,\n                            result\n                        };\n                        pool.connectionHandler.send(msgPeer, response);\n                    });\n                pool.subs.push(messageSub);\n            } else {\n                replicationState = replicateRxCollection({\n                    replicationIdentifier: [collection.name, options.topic, peerToken].join('||'),\n                    collection: collection,\n                    autoStart: true,\n                    deletedField: '_deleted',\n                    live: true,\n                    retryTime: options.retryTime,\n                    waitForLeadership: false,\n                    pull: options.pull ? Object.assign({}, options.pull, {\n                        async handler(lastPulledCheckpoint: P2PReplicationCheckpoint) {\n                            const answer = await sendMessageAndAwaitAnswer(\n                                pool.connectionHandler,\n                                peer,\n                                {\n                                    method: 'masterChangesSince',\n                                    params: [\n                                        lastPulledCheckpoint,\n                                        ensureNotFalsy(options.pull).batchSize\n                                    ],\n                                    id: getRequestId()\n                                }\n                            );\n                            return answer.result;\n                        },\n                        stream$: pool.connectionHandler.response$.pipe(\n                            filter(m => m.response.id === 'masterChangeStream$'),\n                            map(m => m.response.result)\n                        )\n\n                    }) : undefined,\n                    push: options.push ? Object.assign({}, options.push, {\n                        async handler(docs: RxReplicationWriteToMasterRow<RxDocType>[]) {\n                            const answer = await sendMessageAndAwaitAnswer(\n                                pool.connectionHandler,\n                                peer,\n                                {\n                                    method: 'masterWrite',\n                                    params: [docs],\n                                    id: getRequestId()\n                                }\n                            );\n                            return answer.result;\n                        }\n                    }) : undefined\n                });\n            }\n            pool.addPeer(peer, replicationState);\n        });\n    pool.subs.push(connectSub);\n    return pool;\n}\n\n\n/**\n * Because the P2P replication runs between many instances,\n * we use a Pool instead of returning a single replication state.\n */\nexport class RxP2PReplicationPool<RxDocType> {\n\n    peerStates$: BehaviorSubject<Map<P2PPeer, P2PPeerState<RxDocType>>> = new BehaviorSubject(new Map());\n    canceled: boolean = false;\n    masterReplicationHandler: RxReplicationHandler<RxDocType, P2PReplicationCheckpoint>;\n    subs: Subscription[] = [];\n\n    public error$ = new Subject<RxError | RxTypeError>();\n\n    constructor(\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly options: SyncOptionsP2P<RxDocType>,\n        public readonly connectionHandler: P2PConnectionHandler\n    ) {\n        this.collection.onDestroy.push(() => this.cancel());\n        this.masterReplicationHandler = rxStorageInstanceToReplicationHandler(\n            collection.storageInstance,\n            collection.conflictHandler,\n            collection.database.token,\n        );\n    }\n\n    addPeer(\n        peer: P2PPeer,\n        replicationState?: RxP2PReplicationState<RxDocType>\n    ) {\n        const peerState: P2PPeerState<RxDocType> = {\n            peer,\n            replicationState,\n            subs: []\n        };\n        this.peerStates$.next(this.peerStates$.getValue().set(peer, peerState));\n        if (replicationState) {\n            peerState.subs.push(\n                replicationState.error$.subscribe(ev => this.error$.next(ev))\n            );\n        }\n    }\n    removePeer(peer: P2PPeer) {\n        const peerState = getFromMapOrThrow(this.peerStates$.getValue(), peer);\n        this.peerStates$.getValue().delete(peer);\n        this.peerStates$.next(this.peerStates$.getValue());\n        peerState.subs.forEach(sub => sub.unsubscribe());\n        if (peerState.replicationState) {\n            peerState.replicationState.cancel();\n        }\n    }\n\n    // often used in unit tests\n    awaitFirstPeer() {\n        return firstValueFrom(\n            this.peerStates$.pipe(\n                filter(peerStates => peerStates.size > 0)\n            )\n        );\n    }\n\n    public async cancel() {\n        if (this.canceled) {\n            return;\n        }\n        this.canceled = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        Array.from(this.peerStates$.getValue().keys()).forEach(peer => {\n            this.removePeer(peer);\n        });\n        await this.connectionHandler.destroy();\n    }\n}\n\nexport * from './p2p-helper';\nexport * from './p2p-types';\n// export * from './connection-handler-webtorrent';\n// export * from './connection-handler-p2pcf';\nexport * from './connection-handler-simple-peer';\n"],"mappings":"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"}