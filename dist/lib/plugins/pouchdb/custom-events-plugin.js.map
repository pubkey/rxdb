{"version":3,"file":"custom-events-plugin.js","names":["eventEmitDataToStorageEvents","pouchDBInstance","primaryPath","emitData","ret","writeOptions","custom","hasOwnProperty","new_edits","Promise","all","writeDocs","map","writeDoc","id","_id","pouchDocumentDataToRxDocumentData","writeAttachmentsToAttachments","_attachments","previousDoc","previousDocs","get","parsedRevPrevious","parseRevision","_rev","parsedRevNew","height","hash","_deleted","event","operation","doc","previous","newRxError","args","changeEvent","changeEventToNormal","startTime","endTime","push","writeRowById","writeDocsById","Map","forEach","set","writeResult","resultRow","startsWith","POUCHDB_DESIGN_PREFIX","POUCHDB_LOCAL_PREFIX","getFromMapOrThrow","flatClone","rev","pouchChangeRowToChangeEvent","writeMap","error","writeRow","document","attachments","ensureNotFalsy","newDoc","Object","assign","addedToPouch","EVENT_EMITTER_BY_POUCH_INSTANCE","getCustomEventEmitterByPouch","pouch","key","__opts","name","adapter","join","emitter","subject","Subject","i","BULK_DOC_RUN_QUEUE","WeakMap","addCustomEventsPluginToPouch","oldBulkDocs","PouchDBCore","prototype","bulkDocs","newBulkDocs","body","options","callback","internalPouches","includes","call","err","result","queue","PROMISE_RESOLVE_VOID","then","newBulkDocsInner","bind","usePouchResult","hasNonErrorWrite","docs","insertDocsById","Array","from","entries","previousRev","newRev","docInDb","previousDocsInDb","docInDbRev","status","useRevisions","start","ids","_revisions","slice","unshift","useNewRev","writeToPouchDocData","ok","deeperOptions","isDeeper","callReturn","callPromise","res","rej","docIds","Set","d","heighestSequence","changesSub","heighestSequencePromise","changes","since","live","include_docs","on","change","docId","has","seq","size","cancel","useOptsForOldBulkDocs","row","eventsPromise","now","emitId","runId","events","eventBulk","randomCouchString","checkpoint","sequence","context","next","hasError","find","isArray","undefined","length","bulkGet","revs","latest","viaBulkGet","mustRefetchBecauseDeleted","results","firstDoc","reason","allDocs","keys","conflicts","deletedDocsViaAllDocs","idsWithRevs","rows","value","deletedDocsViaBulkGetWithRev","plugin","primary","storageChangeEvent","eventId","getEventKey","documentId","documentData","previousDocumentData"],"sources":["../../../../src/plugins/pouchdb/custom-events-plugin.ts"],"sourcesContent":["/*\n * Instead of listening to pouch.changes,\n * we overwrite pouchdbs bulkDocs()\n * and create our own event stream, this will work more reliable\n * and has less strange behaviors.\n * Also we can better define what data we need for our events.\n * @link http://jsbin.com/pagebi/1/edit?js,output\n * @link https://github.com/pubkey/rxdb/blob/1f4115b69bdacbb853af9c637d70f5f184d4e474/src/rx-storage-pouchdb.ts#L273\n * @link https://hasura.io/blog/couchdb-style-conflict-resolution-rxdb-hasura/\n */\n\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    PouchBulkDocOptions,\n    PouchBulkDocResultRow,\n    PouchChangesOnChangeEvent,\n    PouchCheckpoint,\n    PouchDBInstance,\n    PouchWriteError,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from '../../types';\nimport PouchDBCore from 'pouchdb-core';\nimport { Subject } from 'rxjs';\nimport {\n    ensureNotFalsy,\n    flatClone,\n    getFromMapOrThrow,\n    now,\n    parseRevision,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../util';\nimport { newRxError } from '../../rx-error';\nimport {\n    getEventKey,\n    pouchChangeRowToChangeEvent,\n    POUCHDB_DESIGN_PREFIX,\n    POUCHDB_LOCAL_PREFIX,\n    pouchDocumentDataToRxDocumentData,\n    writeAttachmentsToAttachments\n} from './pouchdb-helper';\nimport type { ChangeEvent } from 'event-reduce-js';\n\n// ensure only added once\nlet addedToPouch = false;\n\ndeclare type EmitData = {\n    emitId: number;\n    writeOptions: PouchBulkDocOptions;\n    writeDocs: any[];\n    writeResult: (PouchBulkDocResultRow | PouchWriteError)[];\n    // used on new_edits=false to check if the last revision has changed\n    previousDocs: Map<string, any>;\n    startTime: number;\n    endTime: number;\n};\n\n\ndeclare type Emitter<RxDocType> = {\n    subject: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, PouchCheckpoint>>;\n};\nexport const EVENT_EMITTER_BY_POUCH_INSTANCE: Map<string, Emitter<any>> = new Map();\n\nexport function getCustomEventEmitterByPouch<RxDocType>(\n    pouch: PouchDBInstance\n): Emitter<RxDocType> {\n    const key = [\n        pouch.__opts.name,\n        pouch.adapter\n    ].join('|');\n    let emitter = EVENT_EMITTER_BY_POUCH_INSTANCE.get(key);\n    if (!emitter) {\n        emitter = {\n            subject: new Subject()\n        };\n        EVENT_EMITTER_BY_POUCH_INSTANCE.set(key, emitter);\n    }\n    return emitter;\n}\n\n\n/**\n * Counter, used to debug stuff.\n */\nlet i = 0;\n\n\n/**\n * Because we cannot force pouchdb to await bulkDocs runs\n * inside of a transaction, like done with the other RxStorage implementations,\n * we have to ensure the calls to bulkDocs() do not run in parallel. \n * \n * TODO this is somehow a hack. Instead of doing that, inspect how\n * PouchDB runs bulkDocs internally and adapt that transaction handling.\n */\nconst BULK_DOC_RUN_QUEUE: WeakMap<PouchDBInstance, Promise<any>> = new WeakMap();\n\n/**\n * PouchDB is like a minefield,\n * where stuff randomly does not work dependend on some conditions.\n * So instead of doing plain writes,\n * we hack into the bulkDocs() function\n * and adjust the behavior accordingly.\n */\nexport function addCustomEventsPluginToPouch() {\n    if (addedToPouch) {\n        return;\n    }\n    addedToPouch = true;\n\n    const oldBulkDocs: any = PouchDBCore.prototype.bulkDocs;\n\n    /**\n     * Ensure we do not run bulkDocs() in parallel on the same PouchDB instance.\n     */\n    const newBulkDocs = function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n\n        /**\n         * Normalize inputs\n         * because there are many ways to call pouchdb.bulkDocs()\n         */\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n\n        /**\n         * PouchDB internal requests\n         * must still be handled normally\n         * to decrease the likelyness of bugs.\n         */\n        const internalPouches = [\n            '_replicator',\n            '_users',\n            'pouch__all_dbs__'\n        ];\n        if (\n            (\n                internalPouches.includes(this.name) ||\n                this.name.includes('-mrview-')\n            )\n        ) {\n            return oldBulkDocs.call(\n                this,\n                body,\n                options,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err, null) : 0;\n                    } else {\n                        if (callback) {\n                            callback(null, result);\n                        }\n                    }\n                });\n        }\n\n\n        let queue = BULK_DOC_RUN_QUEUE.get(this);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue.then(async () => {\n            const ret = await newBulkDocsInner.bind(this)(\n                body,\n                options,\n                callback\n            );\n            return ret;\n        });\n        BULK_DOC_RUN_QUEUE.set(this, queue);\n        return queue;\n    };\n\n\n    const newBulkDocsInner = async function (\n        this: PouchDBInstance,\n        body: any[] | { docs: any[], new_edits?: boolean },\n        options: PouchBulkDocOptions,\n        callback: Function\n    ) {\n        const startTime = now();\n        const runId = i++;\n\n        /**\n         * Normalize inputs\n         * because there are many ways to call pouchdb.bulkDocs()\n         */\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        if (!options) {\n            options = {};\n        }\n\n        let docs: any[];\n        if (Array.isArray(body)) {\n            docs = body;\n        } else if (body === undefined) {\n            docs = [];\n        } else {\n            docs = body.docs;\n            if (body.hasOwnProperty('new_edits')) {\n                options.new_edits = body.new_edits;\n            }\n        }\n\n        // throw if no docs given, because RxDB should never make such a call.\n        if (docs.length === 0) {\n            throw newRxError('SNH', {\n                args: {\n                    body,\n                    options\n                }\n            });\n        }\n\n\n        /**\n         * If new_edits=false we have to first find the current state\n         * of the document and can later check if the state was changed\n         * because a new revision was written and we have to emit an event.\n         */\n        const previousDocsInDb: Map<string, RxDocumentData<any>> = options.custom ? options.custom.previousDocsInDb : new Map();\n        if (\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            const viaBulkGet = await this.bulkGet({\n                docs: docs.map(doc => ({ id: doc._id })),\n                revs: true,\n                latest: true\n            });\n\n            /**\n             * bulkGet() does not return deleted documents,\n             * so we must refetch them via allDocs() afterwards.\n             */\n            const mustRefetchBecauseDeleted: string[] = [];\n\n            viaBulkGet.results.forEach(resultRow => {\n                const firstDoc = resultRow.docs[0];\n                if (firstDoc.ok) {\n                    previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                } else {\n                    if (firstDoc.error && firstDoc.error.reason === 'deleted') {\n                        mustRefetchBecauseDeleted.push(resultRow.id);\n                    }\n                }\n            });\n\n            if (mustRefetchBecauseDeleted.length > 0) {\n                const deletedDocsViaAllDocs = await this.allDocs({\n                    keys: mustRefetchBecauseDeleted,\n                    include_docs: true,\n                    conflicts: true,\n                });\n\n                const idsWithRevs: { id: string; rev: string; }[] = [];\n                deletedDocsViaAllDocs.rows.forEach(row => {\n                    idsWithRevs.push({\n                        id: row.id,\n                        rev: row.value.rev\n                    });\n                });\n\n                const deletedDocsViaBulkGetWithRev = await this.bulkGet({\n                    docs: idsWithRevs,\n                    revs: true,\n                    latest: true\n                });\n\n                deletedDocsViaBulkGetWithRev.results.forEach(resultRow => {\n                    const firstDoc = resultRow.docs[0];\n                    if (firstDoc.ok) {\n                        previousDocsInDb.set(firstDoc.ok._id, firstDoc.ok);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                deletedDocsViaBulkGetWithRev,\n                                resultRow\n                            }\n                        });\n                    }\n                });\n\n            }\n        }\n\n        /**\n         * Custom handling if the call came from RxDB (options.custom is set).\n         */\n        const usePouchResult: (PouchBulkDocResultRow | PouchWriteError)[] = [];\n        let hasNonErrorWrite = false;\n        if (\n            options.custom &&\n            options.hasOwnProperty('new_edits') &&\n            options.new_edits === false\n        ) {\n            /**\n             * Reset the write docs array,\n             * because we only write non-conflicting documents.\n             */\n            docs = [];\n            const writeRowById: Map<string, BulkWriteRow<any>> = options.custom.writeRowById;\n            const insertDocsById: Map<string, any> = options.custom.insertDocsById;\n\n            Array.from(writeRowById.entries()).forEach(([id, writeRow]) => {\n                const previousRev = writeRow.previous ? writeRow.previous._rev : null;\n                const newRev = parseRevision(writeRow.document._rev);\n                const docInDb = previousDocsInDb.get(id);\n                const docInDbRev: string | null = docInDb ? docInDb._rev : null;\n\n                if (\n                    docInDbRev !== previousRev\n                ) {\n                    // we have a conflict\n                    usePouchResult.push({\n                        error: true,\n                        id,\n                        status: 409\n                    });\n                } else {\n                    const useRevisions = {\n                        start: newRev.height,\n                        ids: docInDb ? docInDb._revisions.ids.slice(0) : []\n                    };\n                    useRevisions.ids.unshift(newRev.hash);\n                    const useNewRev = useRevisions.start + '-' + newRev.hash;\n\n                    hasNonErrorWrite = true;\n                    const writeToPouchDocData = Object.assign(\n                        {},\n                        insertDocsById.get(id),\n                        {\n                            _revisions: useRevisions,\n                            _rev: useNewRev\n                        }\n                    );\n                    docs.push(writeToPouchDocData);\n                    usePouchResult.push({\n                        ok: true,\n                        id,\n                        rev: writeRow.document._rev\n                    });\n                }\n            });\n\n            /**\n             * Optimization shortcut,\n             * if all document writes were conflict errors,\n             * we can skip directly.\n             */\n            if (!hasNonErrorWrite) {\n                return usePouchResult;\n            }\n        }\n\n        /**\n         * pouchdb calls this function again with transformed input.\n         * This would lead to duplicate events. So we marks the deeper calls via the options\n         * parameter and do not emit events if it is set.\n         */\n        const deeperOptions = flatClone(options);\n        deeperOptions.isDeeper = true;\n        let callReturn: any;\n        const callPromise = new Promise((res, rej) => {\n\n            /**\n             * The emitted EventBulk from the write to the pouchdb, needs to contain a checkpoint field.\n             * Because PouchDB works on sequence number to sort changes,\n             * we have to fetch the latest sequence number out of the events because it\n             * is not possible to that that from pouch.bulkDocs().\n             */\n            const docIds: Set<string> = new Set(docs.map(d => d._id));\n            let heighestSequence = 0;\n            let changesSub: PouchChangesOnChangeEvent;\n            const heighestSequencePromise = new Promise<number>(res => {\n                changesSub = this.changes({\n                    since: 'now',\n                    live: true,\n                    include_docs: true\n                }).on('change', (change: any) => {\n                    const docId: string = change.id;\n                    if (docIds.has(docId)) {\n                        docIds.delete(docId);\n                        if (heighestSequence < change.seq) {\n                            heighestSequence = change.seq;\n                        }\n\n                        if (docIds.size === 0) {\n                            (changesSub as any).cancel();\n                            res(heighestSequence);\n                        }\n                    }\n                }) as any;\n            });\n\n\n            /**\n             * We cannot send the custom here,\n             * because when a migration between different major RxDB versions is done,\n             * multiple versions of the RxDB PouchDB RxStorage might have added their\n             * custom method via PouchDBCore.plugin()\n             */\n            const useOptsForOldBulkDocs = flatClone(deeperOptions);\n            delete useOptsForOldBulkDocs.custom;\n\n            callReturn = oldBulkDocs.call(\n                this,\n                docs,\n                useOptsForOldBulkDocs,\n                (err: any, result: (PouchBulkDocResultRow | PouchWriteError)[]) => {\n                    if (err) {\n                        callback ? callback(err) : rej(err);\n                    } else {\n                        return (async () => {\n                            const hasError = result.find(row => (row as PouchWriteError).error);\n                            let heighestSequence = -1;\n                            if (!hasError) {\n                                heighestSequence = await heighestSequencePromise;\n                            } else {\n                                changesSub.cancel();\n                            }\n\n                            result.forEach(row => {\n                                usePouchResult.push(row);\n                            });\n\n                            /**\n                             * For calls that came from RxDB,\n                             * we have to ensure that the events are emitted\n                             * before the actual call resolves.\n                             */\n                            let eventsPromise = PROMISE_RESOLVE_VOID;\n                            if (!options.isDeeper) {\n                                const endTime = now();\n                                const emitData = {\n                                    emitId: runId,\n                                    writeDocs: docs,\n                                    writeOptions: options,\n                                    writeResult: usePouchResult,\n                                    previousDocs: previousDocsInDb,\n                                    startTime,\n                                    endTime\n                                };\n                                eventsPromise = eventEmitDataToStorageEvents(\n                                    this,\n                                    '_id',\n                                    emitData\n                                ).then(events => {\n                                    const eventBulk: EventBulk<any, PouchCheckpoint> = {\n                                        id: randomCouchString(10),\n                                        events,\n                                        checkpoint: {\n                                            sequence: heighestSequence\n                                        },\n                                        context: options.custom ? options.custom.context : 'pouchdb-internal'\n                                    };\n\n                                    const emitter = getCustomEventEmitterByPouch(this);\n                                    emitter.subject.next(eventBulk);\n                                });\n                            }\n\n                            if (callback) {\n                                callback(null, usePouchResult);\n                            } else {\n                                return eventsPromise.then(() => {\n                                    res(usePouchResult);\n                                    return usePouchResult;\n                                });\n                            }\n                        })();\n                    }\n                });\n        });\n\n        if (options.custom) {\n            return callPromise;\n        }\n\n\n\n        return callReturn;\n    };\n\n    PouchDBCore.plugin({\n        bulkDocs: newBulkDocs\n    } as any);\n\n}\n\nexport async function eventEmitDataToStorageEvents<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    emitData: EmitData\n): Promise<RxStorageChangeEvent<RxDocumentData<RxDocType>>[]> {\n    const ret: RxStorageChangeEvent<RxDocumentData<RxDocType>>[] = [];\n    if (\n        !emitData.writeOptions.custom &&\n        emitData.writeOptions.hasOwnProperty('new_edits') &&\n        emitData.writeOptions.new_edits === false\n    ) {\n        await Promise.all(\n            emitData.writeDocs.map(async (writeDoc) => {\n                const id = writeDoc._id;\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                let previousDoc = emitData.previousDocs.get(id);\n                if (previousDoc) {\n                    previousDoc = pouchDocumentDataToRxDocumentData(\n                        primaryPath,\n                        previousDoc\n                    );\n                }\n                if (previousDoc) {\n                    const parsedRevPrevious = parseRevision(previousDoc._rev);\n                    const parsedRevNew = parseRevision(writeDoc._rev);\n                    if (\n                        (\n                            parsedRevPrevious.height > parsedRevNew.height ||\n                            /**\n                             * If the revision height is equal,\n                             * we determine the higher hash as winner.\n                             */\n                            (\n                                parsedRevPrevious.height === parsedRevNew.height &&\n                                parsedRevPrevious.hash > parsedRevNew.hash\n                            )\n                        )\n                    ) {\n                        /**\n                         * The newly added document was not the latest revision\n                         * so we drop the write.\n                         * With plain PouchDB it makes sense to store conflicting branches of the document\n                         * but RxDB assumes that the conflict is resolved directly.\n                         */\n                        return;\n                    }\n                }\n\n                if (!previousDoc && writeDoc._deleted) {\n                    // deleted document was added as revision\n                    return;\n                }\n\n                if (previousDoc && previousDoc._deleted && writeDoc._deleted) {\n                    // delete document was deleted again\n                    return;\n                }\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if ((!previousDoc || previousDoc._deleted) && !writeDoc._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: writeDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeDoc._deleted && previousDoc && !previousDoc._deleted) {\n                    // was delete\n                    previousDoc._rev = writeDoc._rev;\n                    event = {\n                        operation: 'DELETE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else if (\n                    previousDoc\n                ) {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: writeDoc,\n                        id: id,\n                        previous: previousDoc\n                    };\n                } else {\n                    throw newRxError('SNH', { args: { writeDoc } });\n                }\n\n                const changeEvent = changeEventToNormal(\n                    pouchDBInstance,\n                    primaryPath,\n                    event,\n                    emitData.startTime,\n                    emitData.endTime\n                );\n\n                ret.push(changeEvent);\n            })\n        );\n    }\n    /**\n     * There is no write map given for internal pouchdb document writes\n     * like it is done with replication.\n     */\n    else if (\n        !emitData.writeOptions.custom ||\n        (emitData.writeOptions.custom && !emitData.writeOptions.custom.writeRowById)\n    ) {\n        const writeDocsById: Map<string, any> = new Map();\n        emitData.writeDocs.forEach(writeDoc => writeDocsById.set(writeDoc._id, writeDoc));\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                const id = resultRow.id;\n                if (\n                    id.startsWith(POUCHDB_DESIGN_PREFIX) ||\n                    id.startsWith(POUCHDB_LOCAL_PREFIX)\n                ) {\n                    return;\n                }\n                let writeDoc = getFromMapOrThrow(writeDocsById, resultRow.id);\n                writeDoc = pouchDocumentDataToRxDocumentData(\n                    primaryPath,\n                    writeDoc\n                );\n\n                writeDoc._attachments = await writeAttachmentsToAttachments(writeDoc._attachments);\n                writeDoc = flatClone(writeDoc);\n                writeDoc._rev = (resultRow as any).rev;\n                const event = pouchChangeRowToChangeEvent<RxDocType>(\n                    primaryPath as any,\n                    writeDoc\n                );\n                const changeEvent = changeEventToNormal(pouchDBInstance, primaryPath, event);\n                ret.push(changeEvent);\n            })\n        );\n    } else {\n        const writeMap: Map<string, BulkWriteRow<RxDocType>> = emitData.writeOptions.custom.writeRowById;\n        await Promise.all(\n            emitData.writeResult.map(async (resultRow) => {\n                if ((resultRow as PouchWriteError).error) {\n                    return;\n                }\n                const id = resultRow.id;\n                const writeRow = getFromMapOrThrow(writeMap, id);\n                const attachments = await writeAttachmentsToAttachments(writeRow.document._attachments);\n                const newDoc: RxDocumentData<RxDocType> = Object.assign(\n                    {},\n                    writeRow.document,\n                    {\n                        _attachments: attachments,\n                        _rev: (resultRow as PouchBulkDocResultRow).rev\n                    }\n                );\n\n                let event: ChangeEvent<RxDocumentData<RxDocType>>;\n                if (!writeRow.previous || writeRow.previous._deleted) {\n                    // was insert\n                    event = {\n                        operation: 'INSERT',\n                        doc: newDoc,\n                        id: id,\n                        previous: null\n                    };\n                } else if (writeRow.document._deleted) {\n                    // was delete\n\n                    // we need to add the new revision to the previous doc\n                    // so that the eventkey is calculated correctly.\n                    // Is this a hack? idk.\n                    const attachments = await writeAttachmentsToAttachments(writeRow.previous._attachments);\n                    const previousDoc = Object.assign(\n                        {},\n                        writeRow.previous,\n                        {\n                            _attachments: attachments\n                        }\n                    );\n\n                    event = {\n                        operation: 'DELETE',\n                        doc: writeRow.document,\n                        id: resultRow.id,\n                        previous: previousDoc\n                    } as any;\n                } else {\n                    // was update\n                    event = {\n                        operation: 'UPDATE',\n                        doc: newDoc,\n                        id: resultRow.id,\n                        previous: writeRow.previous\n                    };\n                }\n\n                if (\n                    writeRow.document._deleted &&\n                    (\n                        !writeRow.previous ||\n                        writeRow.previous._deleted\n                    )\n                ) {\n                    /**\n                     * A deleted document was newly added to the storage engine,\n                     * do not emit an event.\n                     */\n                } else {\n                    const changeEvent = changeEventToNormal(\n                        pouchDBInstance,\n                        ensureNotFalsy(emitData.writeOptions.custom).primaryPath,\n                        event,\n                        emitData.startTime,\n                        emitData.endTime\n                    );\n                    ret.push(changeEvent);\n                }\n            })\n        );\n    }\n\n    return ret;\n}\n\nexport function changeEventToNormal<RxDocType>(\n    pouchDBInstance: PouchDBInstance,\n    primaryPath: string,\n    change: ChangeEvent<RxDocumentData<RxDocType>>,\n    startTime?: number,\n    endTime?: number\n): RxStorageChangeEvent<RxDocumentData<RxDocType>> {\n    const doc: RxDocumentData<RxDocType> = change.operation === 'DELETE' ? change.previous as any : change.doc as any;\n    const primary: string = (doc as any)[primaryPath];\n    const storageChangeEvent: RxStorageChangeEvent<RxDocumentData<RxDocType>> = {\n        eventId: getEventKey(pouchDBInstance, primary, change),\n        documentId: primary,\n        documentData: change.doc as any,\n        previousDocumentData: change.previous as any,\n        operation: change.operation,\n        startTime,\n        endTime\n    };\n    return storageChangeEvent;\n}\n"],"mappings":"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"}