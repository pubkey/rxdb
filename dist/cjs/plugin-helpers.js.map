{"version":3,"file":"plugin-helpers.js","names":["_operators","require","_rxSchemaHelper","_index","_rxjs","VALIDATOR_CACHE_BY_VALIDATOR_KEY","Map","wrappedValidateStorageFactory","getValidator","validatorKey","VALIDATOR_CACHE","getFromMapOrCreate","initValidator","schema","JSON","stringify","args","Object","assign","storage","createStorageInstance","params","instance","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","validatorCached","requestIdleCallbackIfAvailable","oldBulkWrite","bulkWrite","bind","documentWrites","context","errors","continueWrites","forEach","row","documentId","document","validationErrors","length","push","status","isError","writeRow","writePromise","Promise","resolve","error","success","then","writeResult","validationError","wrapRxStorageInstance","originalSchema","modifyToStorage","modifyFromStorage","modifyAttachmentFromStorage","v","toStorage","docData","fromStorage","errorFromStorage","ret","flatClone","documentInDb","previous","processingChangesCount$","BehaviorSubject","wrappedInstance","databaseName","internals","cleanup","options","close","collectionName","count","info","remove","originalStorageInstance","useRows","all","map","undefined","promises","v2","err","firstValueFrom","pipe","filter","query","preparedQuery","queryResult","documents","doc","getAttachmentData","attachmentId","digest","data","findDocumentsById","ids","deleted","findResult","getChangedDocumentsSince","limit","checkpoint","result","d","changeStream","tap","next","getValue","mergeMap","eventBulk","useEvents","events","event","documentData","previousDocumentData","ev","operation","eventId","endTime","startTime","isLocal","id","conflictResultionTasks","task","assumedMasterState","input","newDocumentState","realMasterState","resolveConflictResultionTask","taskSolution","output","isEqual","useSolution"],"sources":["../../src/plugin-helpers.ts"],"sourcesContent":["import { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\nimport { WrappedRxStorageInstance } from './rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxChangeEvent,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageWriteError,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxValidationError,\n    RxStorageWriteErrorConflict,\n    MaybePromise\n} from './types/index.d.ts';\nimport {\n    flatClone,\n    getFromMapOrCreate,\n    requestIdleCallbackIfAvailable\n} from './plugins/utils/index.ts';\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n\ntype WrappedStorageFunction = <Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n) => RxStorage<Internals, InstanceCreationOptions>;\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\ntype ValidatorFunction = (docData: RxDocumentData<any>) => RxValidationError[];\n\n/**\n * cache the validators by the schema string\n * so we can reuse them when multiple collections have the same schema\n *\n * Notice: to make it easier and not dependent on a hash function,\n * we use the plain json string.\n */\nconst VALIDATOR_CACHE_BY_VALIDATOR_KEY: Map<string, Map<string, ValidatorFunction>> = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n    /**\n     * Returns a method that can be used to validate\n     * documents and throws when the document is not valid.\n     */\n    getValidator: (schema: RxJsonSchema<any>) => ValidatorFunction,\n    /**\n     * A string to identify the validation library.\n     */\n    validatorKey: string\n): WrappedStorageFunction {\n    const VALIDATOR_CACHE = getFromMapOrCreate(\n        VALIDATOR_CACHE_BY_VALIDATOR_KEY,\n        validatorKey,\n        () => new Map()\n    );\n\n    function initValidator(\n        schema: RxJsonSchema<any>\n    ): ValidatorFunction {\n        return getFromMapOrCreate(\n            VALIDATOR_CACHE,\n            JSON.stringify(schema),\n            () => getValidator(schema)\n        );\n    }\n\n    return (args) => {\n        return Object.assign(\n            {},\n            args.storage,\n            {\n                async createStorageInstance<RxDocType>(\n                    params: RxStorageInstanceCreationParams<RxDocType, any>\n                ) {\n                    const instance = await args.storage.createStorageInstance(params);\n                    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n                    /**\n                     * Lazy initialize the validator\n                     * to save initial page load performance.\n                     * Some libraries take really long to initialize the validator\n                     * from the schema.\n                     */\n                    let validatorCached: ValidatorFunction;\n                    requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n\n                    const oldBulkWrite = instance.bulkWrite.bind(instance);\n                    instance.bulkWrite = (\n                        documentWrites: BulkWriteRow<RxDocType>[],\n                        context: string\n                    ) => {\n                        if (!validatorCached) {\n                            validatorCached = initValidator(params.schema);\n                        }\n                        const errors: RxStorageWriteError<RxDocType>[] = [];\n                        const continueWrites: typeof documentWrites = [];\n                        documentWrites.forEach(row => {\n                            const documentId: string = row.document[primaryPath] as any;\n                            const validationErrors = validatorCached(row.document);\n                            if (validationErrors.length > 0) {\n                                errors.push({\n                                    status: 422,\n                                    isError: true,\n                                    documentId,\n                                    writeRow: row,\n                                    validationErrors\n                                });\n                            } else {\n                                continueWrites.push(row);\n                            }\n                        });\n                        const writePromise: Promise<RxStorageBulkWriteResponse<RxDocType>> = continueWrites.length > 0 ?\n                            oldBulkWrite(continueWrites, context) :\n                            Promise.resolve({ error: [], success: [] });\n                        return writePromise.then(writeResult => {\n                            errors.forEach(validationError => {\n                                writeResult.error.push(validationError);\n                            });\n                            return writeResult;\n                        });\n                    };\n\n                    return instance;\n                }\n            }\n        );\n    };\n\n}\n\n\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance<RxDocType>(\n    originalSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    instance: RxStorageInstance<RxDocType, any, any>,\n    modifyToStorage: (docData: RxDocumentWriteData<RxDocType>) => MaybePromise<RxDocumentData<any>>,\n    modifyFromStorage: (docData: RxDocumentData<any>) => MaybePromise<RxDocumentData<RxDocType>>,\n    modifyAttachmentFromStorage: (attachmentData: string) => MaybePromise<string> = (v) => v\n): WrappedRxStorageInstance<RxDocType, any, any> {\n    async function toStorage(docData: RxDocumentWriteData<RxDocType>): Promise<RxDocumentData<any>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyToStorage(docData);\n    }\n    async function fromStorage(docData: RxDocumentData<any> | null): Promise<RxDocumentData<RxDocType>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyFromStorage(docData);\n    }\n    async function errorFromStorage(\n        error: RxStorageWriteError<any>\n    ): Promise<RxStorageWriteError<RxDocType>> {\n        const ret = flatClone(error);\n        ret.writeRow = flatClone(ret.writeRow);\n        if ((ret as RxStorageWriteErrorConflict<any>).documentInDb) {\n            (ret as RxStorageWriteErrorConflict<any>).documentInDb = await fromStorage((ret as RxStorageWriteErrorConflict<any>).documentInDb);\n        }\n        if (ret.writeRow.previous) {\n            ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\n        }\n        ret.writeRow.document = await fromStorage(ret.writeRow.document);\n        return ret;\n    }\n\n\n    const processingChangesCount$ = new BehaviorSubject(0);\n\n    const wrappedInstance: WrappedRxStorageInstance<RxDocType, any, any> = {\n        databaseName: instance.databaseName,\n        internals: instance.internals,\n        cleanup: instance.cleanup.bind(instance),\n        options: instance.options,\n        close: instance.close.bind(instance),\n        schema: originalSchema,\n        collectionName: instance.collectionName,\n        count: instance.count.bind(instance),\n        info: instance.info.bind(instance),\n        remove: instance.remove.bind(instance),\n        originalStorageInstance: instance,\n        bulkWrite: async (\n            documentWrites: BulkWriteRow<RxDocType>[],\n            context: string\n        ) => {\n            const useRows: BulkWriteRow<any>[] = [];\n            await Promise.all(\n                documentWrites.map(async (row) => {\n                    const [previous, document] = await Promise.all([\n                        row.previous ? toStorage(row.previous) : undefined,\n                        toStorage(row.document)\n                    ]);\n                    useRows.push({ previous, document });\n                })\n            );\n\n            const writeResult = await instance.bulkWrite(useRows, context);\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\n                success: [],\n                error: []\n            };\n            const promises: Promise<any>[] = [];\n            writeResult.success.forEach(v => {\n                promises.push(\n                    fromStorage(v).then(v2 => ret.success.push(v2))\n                );\n            });\n            writeResult.error.forEach(error => {\n                promises.push(\n                    errorFromStorage(error).then(err => ret.error.push(err))\n                );\n            });\n            await Promise.all(promises);\n\n            /**\n             * By definition, all change events must be emitted\n             * BEFORE the write call resolves.\n             * To ensure that even when the modifiers are async,\n             * we wait here until the processing queue is empty.\n             */\n            await firstValueFrom(\n                processingChangesCount$.pipe(\n                    filter(v => v === 0)\n                )\n            );\n            return ret;\n        },\n        query: (preparedQuery) => {\n            return instance.query(preparedQuery)\n                .then(queryResult => {\n                    return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n                })\n                .then(documents => ({ documents: documents as any }));\n        },\n        getAttachmentData: async (\n            documentId: string,\n            attachmentId: string,\n            digest: string\n        ) => {\n            let data = await instance.getAttachmentData(documentId, attachmentId, digest);\n            data = await modifyAttachmentFromStorage(data);\n            return data;\n        },\n        findDocumentsById: (ids, deleted) => {\n            return instance.findDocumentsById(ids, deleted)\n                .then(async (findResult) => {\n                    const ret: RxDocumentData<RxDocType>[] = [];\n                    await Promise.all(\n                        findResult\n                            .map(async (doc) => {\n                                ret.push(await fromStorage(doc));\n                            })\n                    );\n                    return ret;\n                });\n        },\n        getChangedDocumentsSince: (limit, checkpoint) => {\n            return instance.getChangedDocumentsSince(limit, checkpoint)\n                .then(async (result) => {\n                    return {\n                        checkpoint: result.checkpoint,\n                        documents: await Promise.all(\n                            result.documents.map(d => fromStorage(d))\n                        )\n                    };\n                });\n        },\n        changeStream: () => {\n            return instance.changeStream().pipe(\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)),\n                mergeMap(async (eventBulk) => {\n                    const useEvents = await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            const [\n                                documentData,\n                                previousDocumentData\n                            ] = await Promise.all([\n                                fromStorage(event.documentData),\n                                fromStorage(event.previousDocumentData)\n                            ]);\n                            const ev: RxChangeEvent<RxDocType> = {\n                                operation: event.operation,\n                                eventId: event.eventId,\n                                documentId: event.documentId,\n                                endTime: event.endTime,\n                                startTime: event.startTime,\n                                documentData: documentData as any,\n                                previousDocumentData: previousDocumentData as any,\n                                isLocal: false\n                            };\n                            return ev;\n                        })\n                    );\n                    const ret: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n                        id: eventBulk.id,\n                        events: useEvents,\n                        checkpoint: eventBulk.checkpoint,\n                        context: eventBulk.context\n                    };\n                    return ret;\n                }),\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1))\n            );\n        },\n        conflictResultionTasks: () => {\n            return instance.conflictResultionTasks().pipe(\n                mergeMap(async (task) => {\n                    const assumedMasterState = await fromStorage(task.input.assumedMasterState);\n                    const newDocumentState = await fromStorage(task.input.newDocumentState);\n                    const realMasterState = await fromStorage(task.input.realMasterState);\n                    return {\n                        id: task.id,\n                        context: task.context,\n                        input: {\n                            assumedMasterState,\n                            realMasterState,\n                            newDocumentState\n                        }\n                    };\n                })\n            );\n        },\n        resolveConflictResultionTask: (taskSolution) => {\n            if (taskSolution.output.isEqual) {\n                return instance.resolveConflictResultionTask(taskSolution);\n            }\n            const useSolution = {\n                id: taskSolution.id,\n                output: {\n                    isEqual: false,\n                    documentData: taskSolution.output.documentData\n                }\n            };\n            return instance.resolveConflictResultionTask(useSolution);\n        }\n    };\n\n    return wrappedInstance;\n}\n"],"mappings":"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"}