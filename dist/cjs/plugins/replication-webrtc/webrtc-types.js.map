{"version":3,"file":"webrtc-types.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/webrtc-types.ts"],"sourcesContent":["import { Observable, Subscription } from 'rxjs';\nimport type {\n    MaybePromise,\n    ReplicationOptions,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxError,\n    RxReplicationHandler,\n    RxStorageDefaultCheckpoint,\n    RxTypeError,\n    StringKeys\n} from '../../types/index.d.ts';\nimport { RxReplicationState } from '../replication/index.ts';\nimport { WebsocketMessageResponseType, WebsocketMessageType } from '../replication-websocket/index.ts';\n\nexport type WebRTCReplicationCheckpoint = RxStorageDefaultCheckpoint;\n\n\nexport type WebRTCMessage = Omit<WebsocketMessageType, 'method' | 'collection'> & {\n    method: StringKeys<RxReplicationHandler<any, any>> | 'token';\n};\nexport type WebRTCResponse = Omit<WebsocketMessageResponseType, 'collection'>;\nexport type PeerWithMessage<PeerType> = {\n    peer: PeerType;\n    message: WebRTCMessage;\n};\nexport type PeerWithResponse<PeerType> = {\n    peer: PeerType;\n    response: WebRTCResponse;\n};\n\nexport type WebRTCConnectionHandler<PeerType> = {\n    connect$: Observable<PeerType>;\n    disconnect$: Observable<PeerType>;\n    message$: Observable<PeerWithMessage<PeerType>>;\n    response$: Observable<PeerWithResponse<PeerType>>;\n    error$: Observable<RxError | RxTypeError>;\n    send(peer: PeerType, message: WebRTCMessage | WebRTCResponse): Promise<void>;\n    close(): Promise<void>;\n};\n\nexport type WebRTCConnectionHandlerCreator<PeerType> = (\n    opts: SyncOptionsWebRTC<any, PeerType>\n) => Promise<WebRTCConnectionHandler<PeerType>>;\n\nexport type WebRTCSyncPushOptions<RxDocType> = Omit<\n    ReplicationPushOptions<RxDocType>,\n    'handler'\n> & {};\n\nexport type WebRTCSyncPullOptions<RxDocType> = Omit<\n    ReplicationPullOptions<RxDocType, WebRTCReplicationCheckpoint>,\n    'handler' | 'stream$'\n> & {};\n\nexport type SyncOptionsWebRTC<RxDocType, PeerType> = Omit<\n    ReplicationOptions<RxDocType, WebRTCReplicationCheckpoint>,\n    'pull' |\n    'push' |\n    'replicationIdentifier' |\n    'deletedField' |\n    'live' |\n    'autostart' |\n    'waitForLeadership'\n> & {\n    /**\n     * It will only replicate with other instances\n     * that use the same topic.\n     */\n    topic: string;\n    connectionHandlerCreator: WebRTCConnectionHandlerCreator<PeerType>;\n    /**\n     * Run on new peers so that bad peers can be blocked.\n     * If returns true, the peer is valid and it will replicate.\n     * If returns false, it will drop the peer.\n     */\n    isPeerValid?: (peer: PeerType) => MaybePromise<boolean>;\n    pull?: WebRTCSyncPullOptions<RxDocType>;\n    push?: WebRTCSyncPushOptions<RxDocType>;\n};\n\nexport type RxWebRTCReplicationState<RxDocType> = RxReplicationState<RxDocType, WebRTCReplicationCheckpoint>;\n\n\nexport type WebRTCPeerState<RxDocType, PeerType> = {\n    peer: PeerType;\n    // only exists when the peer was picked as master and the own client was picked as fork.\n    replicationState?: RxWebRTCReplicationState<RxDocType>;\n    // clean this up when removing the peer\n    subs: Subscription[];\n};\n"],"mappings":"","ignoreList":[]}