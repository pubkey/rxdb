{"version":3,"file":"memory-types.js","names":[],"sources":["../../../../src/plugins/storage-memory/memory-types.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport type {\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageChangeEvent,\n    RxStorageDefaultCheckpoint\n} from '../../types/index.d.ts';\n\nexport type RxStorageMemorySettings = {};\nexport type RxStorageMemoryInstanceCreationOptions = {};\nexport type RxStorageMemory = RxStorage<MemoryStorageInternals<any>, RxStorageMemoryInstanceCreationOptions> & {\n    /**\n     * State by collectionKey\n     */\n    collectionStates: Map<string, MemoryStorageInternals<any>>;\n};\n\nexport type MemoryStorageInternalsByIndex<RxDocType> = {\n    index: string[];\n    docsWithIndex: DocWithIndexString<RxDocType>[];\n    getIndexableString: (docData: RxDocumentData<RxDocType>) => string;\n};\n\n/**\n * The internals are shared between multiple storage instances\n * that have been created with the same [databaseName+collectionName] combination.\n */\nexport type MemoryStorageInternals<RxDocType> = {\n    // used to debug stuff and identify instances\n    id: string;\n\n    /**\n     * Schema of the first instance created with the given settings.\n     * Used to ensure that the same storage is not re-created with\n     * a different schema.\n     */\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>;\n\n    /**\n     * We reuse the memory state when multiple instances\n     * are created with the same params.\n     * If refCount becomes 0, we can delete the state.\n     */\n    refCount: number;\n    /**\n     * If this becomes true,\n     * it means that an instance has called remove()\n     * so all other instances should also not work anymore.\n     */\n    removed: boolean;\n    documents: Map<string, RxDocumentData<RxDocType>>;\n    /**\n     * Attachments data, indexed by a combined string\n     * consisting of [documentId + '||' + attachmentId]\n     */\n    attachments: Map<string, {\n        writeData: RxAttachmentWriteData;\n        digest: string;\n    }>;\n    byIndex: {\n        /**\n         * Because RxDB requires a deterministic sorting\n         * on all indexes, we can be sure that the composed index key\n         * of each document is unique, because it contains the primaryKey\n         * as last index part.\n         * So we do not have to store the index-position when we want to do fast\n         * writes. Instead we can do a binary search over the existing array\n         * because RxDB also knows the previous state of the document when we do a bulkWrite().\n         */\n        [indexName: string]: MemoryStorageInternalsByIndex<RxDocType>;\n    };\n\n    /**\n     * We need these to do lazy writes.\n     */\n    ensurePersistenceTask?: CategorizeBulkWriteRowsOutput<RxDocType>;\n    ensurePersistenceIdlePromise?: Promise<void>;\n\n    changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>>;\n};\n\nexport type DocWithIndexString<RxDocType> = [\n    string, // indexString, must be first because often we only need that one.\n    RxDocumentData<RxDocType>, // document\n    string, // id\n];\n"],"mappings":"","ignoreList":[]}