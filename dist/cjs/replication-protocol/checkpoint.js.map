{"version":3,"file":"checkpoint.js","names":["_rxSchemaHelper","require","_rxStorageHelper","_index","getLastCheckpointDoc","state","direction","checkpointDocId","getComposedPrimaryKeyOfDocumentData","input","metaInstance","schema","isCheckpoint","itemId","checkpointResult","findDocumentsById","checkpointDoc","lastCheckpointDoc","checkpointData","undefined","setCheckpoint","checkpoint","checkpointQueue","then","previousCheckpointDoc","events","canceled","getValue","JSON","stringify","newDoc","id","_deleted","_attachments","_meta","getDefaultRxDocumentMeta","_rev","getDefaultRevision","stackCheckpoints","lwt","now","createRevision","checkpointKey","writeRows","previous","document","result","bulkWrite","successDoc","getWrittenDocumentsFromBulkWriteResponse","primaryPath","error","status","ensureNotFalsy","documentInDb","getCheckpointKey","hash","hashFunction","identifier","forkInstance","databaseName","collectionName","join"],"sources":["../../../src/replication-protocol/checkpoint.ts"],"sourcesContent":["import { getComposedPrimaryKeyOfDocumentData } from '../rx-schema-helper.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\nimport type {\n    RxDocumentData,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationDirection,\n    RxStorageReplicationMeta\n} from '../types/index.d.ts';\nimport {\n    createRevision,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    now\n} from '../plugins/utils/index.ts';\n\nexport async function getLastCheckpointDoc<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection\n): Promise<undefined | CheckpointType> {\n    const checkpointDocId = getComposedPrimaryKeyOfDocumentData(\n        state.input.metaInstance.schema,\n        {\n            isCheckpoint: '1',\n            itemId: direction\n        }\n    );\n    const checkpointResult = await state.input.metaInstance.findDocumentsById(\n        [\n            checkpointDocId\n        ],\n        false\n    );\n\n    const checkpointDoc = checkpointResult[0];\n    state.lastCheckpointDoc[direction] = checkpointDoc;\n    if (checkpointDoc) {\n        return checkpointDoc.checkpointData;\n    } else {\n        return undefined;\n    }\n}\n\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection,\n    checkpoint: CheckpointType\n) {\n    state.checkpointQueue = state.checkpointQueue.then(async () => {\n        let previousCheckpointDoc = state.lastCheckpointDoc[direction];\n        if (\n            checkpoint &&\n            /**\n             * If the replication is already canceled,\n             * we do not write a checkpoint\n             * because that could mean we write a checkpoint\n             * for data that has been fetched from the master\n             * but not been written to the child.\n             */\n            !state.events.canceled.getValue() &&\n            /**\n             * Only write checkpoint if it is different from before\n             * to have less writes to the storage.\n             */\n            (\n                !previousCheckpointDoc ||\n                JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint)\n            )\n        ) {\n            const newDoc: RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {\n                id: '',\n                isCheckpoint: '1',\n                itemId: direction,\n                _deleted: false,\n                _attachments: {},\n                checkpointData: checkpoint,\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision()\n            };\n            newDoc.id = getComposedPrimaryKeyOfDocumentData(\n                state.input.metaInstance.schema,\n                newDoc\n            );\n            while (!state.events.canceled.getValue()) {\n                /**\n                 * Instead of just storing the new checkpoint,\n                 * we have to stack up the checkpoint with the previous one.\n                 * This is required for plugins like the sharding RxStorage\n                 * where the changeStream events only contain a Partial of the\n                 * checkpoint.\n                 */\n                if (previousCheckpointDoc) {\n                    newDoc.checkpointData = stackCheckpoints([\n                        previousCheckpointDoc.checkpointData,\n                        newDoc.checkpointData\n                    ]);\n                }\n                newDoc._meta.lwt = now();\n                newDoc._rev = createRevision(\n                    await state.checkpointKey,\n                    previousCheckpointDoc\n                );\n\n                if (state.events.canceled.getValue()) {\n                    return;\n                }\n\n                const writeRows = [{\n                    previous: previousCheckpointDoc,\n                    document: newDoc\n                }];\n                const result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\n                const successDoc = getWrittenDocumentsFromBulkWriteResponse(\n                    state.primaryPath,\n                    writeRows,\n                    result\n                )[0];\n                if (successDoc) {\n                    state.lastCheckpointDoc[direction] = successDoc;\n                    return;\n                } else {\n                    const error = result.error[0];\n                    if (error.status !== 409) {\n                        throw error;\n                    } else {\n                        previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n                        newDoc._rev = createRevision(\n                            await state.checkpointKey,\n                            previousCheckpointDoc\n                        );\n                    }\n                }\n            }\n        }\n    });\n    await state.checkpointQueue;\n}\n\nexport async function getCheckpointKey<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): Promise<string> {\n    const hash = await input.hashFunction([\n        input.identifier,\n        input.forkInstance.databaseName,\n        input.forkInstance.collectionName\n    ].join('||'));\n    return 'rx_storage_replication_' + hash;\n}\n"],"mappings":"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","ignoreList":[]}