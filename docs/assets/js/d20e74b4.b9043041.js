"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[5123],{6510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"crdt","title":"CRDT - Conflict-free replicated data type Database","description":"Learn how RxDB\'s CRDT Plugin resolves document conflicts automatically in distributed systems, ensuring seamless merges and consistent data.","source":"@site/docs/crdt.md","sourceDirName":".","slug":"/crdt.html","permalink":"/crdt.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"CRDT - Conflict-free replicated data type Database","slug":"crdt.html","description":"Learn how RxDB\'s CRDT Plugin resolves document conflicts automatically in distributed systems, ensuring seamless merges and consistent data."},"sidebar":"tutorialSidebar","previous":{"title":"Middleware","permalink":"/middleware.html"},"next":{"title":"Population","permalink":"/population.html"}}');var s=t(4848),o=t(8453);const a={title:"CRDT - Conflict-free replicated data type Database",slug:"crdt.html",description:"Learn how RxDB's CRDT Plugin resolves document conflicts automatically in distributed systems, ensuring seamless merges and consistent data."},r="RxDB CRDT Plugin (beta)",l={},c=[{value:"RxDB CRDT operations",id:"rxdb-crdt-operations",level:2},{value:"Operators",id:"operators",level:3},{value:"Installation",id:"installation",level:2},{value:"Conditional CRDT operations",id:"conditional-crdt-operations",level:2},{value:"Running multiples operations at once",id:"running-multiples-operations-at-once",level:2},{value:"CRDTs on inserts",id:"crdts-on-inserts",level:2},{value:"Deleting documents",id:"deleting-documents",level:2},{value:"CRDTs with replication",id:"crdts-with-replication",level:2},{value:"Why not automerge.js or yjs?",id:"why-not-automergejs-or-yjs",level:2},{value:"When to not use CRDTs",id:"when-to-not-use-crdts",level:2},{value:"CRDT Alternative",id:"crdt-alternative",level:2},{value:"Downsides of CRDTs",id:"downsides-of-crdts",level:3},{value:"When to choose conflict handlers",id:"when-to-choose-conflict-handlers",level:3},{value:"Example: merging different fields with conflict handlers instead of CRDT",id:"example-merging-different-fields-with-conflict-handlers-instead-of-crdt",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rxdb-crdt-plugin-beta",children:"RxDB CRDT Plugin (beta)"})}),"\n",(0,s.jsx)(n.p,{children:"Whenever there are multiple instances in a distributed system, data writes can cause conflicts. Two different clients could do a write to the same document at the same time or while they are both offline. When the clients replicate the document state with the server, a conflict emerges that must be resolved by the system."}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.a,{href:"./",children:"RxDB"}),", conflicts are normally resolved by setting a ",(0,s.jsx)(n.code,{children:"conflictHandler"})," when creating a collection. The conflict handler is a JavaScript function that gets the two conflicting states of the same document and it will return the resolved document state.\nThe ",(0,s.jsx)(n.a,{href:"/replication.html#conflict-handling",children:"default conflict handler"})," will always drop the fork state and use the master state to ensure that clients that have been offline for a long time, do not overwrite other clients changes when they go online again."]}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:"./files/document-replication-conflict.svg",alt:"document replication conflict",width:"250"})}),"\n",(0,s.jsxs)(n.p,{children:["With CRDTs (short for ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type",children:"Conflict-free replicated data type"}),'), all document\nwrites are represented as CRDT operations in plain JSON. The CRDT operations are stored together with the document and each time a conflict arises, the CRDT conflict handler will automatically merge the operations in a deterministic way. Using CRDTs is an easy way to "magically" handle all conflict problems in your application by storing the deltas of writes together with the document data.']}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:"./files/crdt-conflict-free-replicated-data-type.svg",alt:"CRDT Conflict-free replicated data type",width:"300"})}),"\n",(0,s.jsx)(n.h2,{id:"rxdb-crdt-operations",children:"RxDB CRDT operations"}),"\n",(0,s.jsxs)(n.p,{children:["In RxDB, a CRDT operation is defined with NoSQL update operators, like you might know them from ",(0,s.jsx)(n.a,{href:"https://www.mongodb.com/docs/manual/reference/operator/update/",children:"MongoDB update operations"})," or the ",(0,s.jsx)(n.a,{href:"/rx-document.html#update",children:"RxDB update plugin"}),".\nTo run the operators, RxDB uses the ",(0,s.jsx)(n.a,{href:"https://github.com/kofrasa/mingo#updating-documents",children:"mingo library"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"A CRDT operator example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const myCRDTOperation = {\n    // increment the points field by +1\n    $inc: {\n        points: 1\n    },\n    // set the modified field to true\n    $set: {\n        modified: true\n    }\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"operators",children:"Operators"}),"\n",(0,s.jsxs)(n.p,{children:["At the moment, not all possible operators are implemented in ",(0,s.jsx)(n.a,{href:"https://github.com/kofrasa/mingo#updating-documents",children:"mingo"}),", if you need additional ones, you should make a pull request there."]}),"\n",(0,s.jsx)(n.p,{children:"The following operators can be used at this point in time:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$min"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$max"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$inc"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$set"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$unset"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$push"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$addToSet"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$pop"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$pullAll"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"$rename"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For the exact definition on how each operator behaves, check out the ",(0,s.jsx)(n.a,{href:"https://www.mongodb.com/docs/manual/reference/operator/update/",children:"MongoDB documentation on update operators"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.p,{children:"To use CRDTs with RxDB, you need the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Add the CRDT plugin via ",(0,s.jsx)(n.code,{children:"addRxPlugin"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Add a field to your schema that defines where to store the CRDT operations via ",(0,s.jsx)(n.code,{children:"getCRDTSchemaPart()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Set the ",(0,s.jsx)(n.code,{children:"crdt"})," options in your schema."]}),"\n",(0,s.jsxs)(n.li,{children:["Do ",(0,s.jsx)(n.strong,{children:"NOT"})," set a custom conflict handler, the plugin will use its own one."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// import the relevant parts from the CRDT plugin\nimport {\n    getCRDTSchemaPart,\n    RxDBcrdtPlugin\n} from 'rxdb/plugins/crdt';\n\n// add the CRDT plugin to RxDB\nimport { addRxPlugin } from 'rxdb';\naddRxPlugin(RxDBcrdtPlugin);\n\n// create a database\nimport { createRxDatabase } from 'rxdb';\nimport { getRxStorageLocalstorage } from 'rxdb/plugins/storage-localstorage';\nconst myDatabase = await createRxDatabase({\n  name: 'heroesdb',\n  storage: getRxStorageLocalstorage()\n});\n\n// create a schema with the CRDT options\nconst mySchema = {\n    version: 0,\n    primaryKey: 'id',\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string',\n            maxLength: 100\n        },\n        points: {\n            type: 'number',\n            maximum: 100,\n            minimum: 0\n        },\n        crdts: getCRDTSchemaPart() // use this field to store the CRDT operations\n    },\n    required: ['id', 'points'],\n    crdt: { // CRDT options\n        field: 'crdts'\n    }\n}\n\n// add a collection\nawait db.addCollections({\n    users: {\n        schema: mySchema\n    }\n});\n\n// insert a document\nconst myDocument = await db.users.insert({id: 'alice', points: 0});\n\n// run a CRDT operation that increments the 'points' by one\nawait myDocument.updateCRDT({\n    ifMatch: {\n        $inc: {\n            points: 1\n        }\n    }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conditional-crdt-operations",children:"Conditional CRDT operations"}),"\n",(0,s.jsx)(n.p,{children:"By default, all CRDTs operations will be run to build the current document state. But in many cases, more granular operations are required to better reflect the desired business logic. For these cases, conditional CRDTs can be used."}),"\n",(0,s.jsxs)(n.p,{children:["For example if you have a field ",(0,s.jsx)(n.code,{children:"points"})," with a ",(0,s.jsx)(n.code,{children:"maximum"})," of ",(0,s.jsx)(n.code,{children:"100"}),", you might want to only run the ",(0,s.jsx)(n.code,{children:"$inc"})," operation, if the ",(0,s.jsx)(n.code,{children:"points"})," value is less than ",(0,s.jsx)(n.code,{children:"100"}),".\nIn an conditional CRDT, you can specify a ",(0,s.jsx)(n.code,{children:"selector"})," and the operation sets ",(0,s.jsx)(n.code,{children:"ifMatch"})," and ",(0,s.jsx)(n.code,{children:"ifNotMatch"}),". At each time the CRDT is applied to the document state, first the selector will run and evaluate which operations path must be used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await myDocument.updateCRDT({\n    // only if the selector matches, the ifMatch operation will run\n    selector: {\n        age: {\n            $lt: 100\n        }\n    },\n    // an operation that runs if the selector matches\n    ifMatch: {\n        $inc: {\n            points: 1\n        }\n    },\n    // if the selector does NOT match, you could run a different operation instead\n    ifNotMatch: {\n        // ...\n    }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"running-multiples-operations-at-once",children:"Running multiples operations at once"}),"\n",(0,s.jsx)(n.p,{children:"By default, one CRDT operation is applied to the document in a single database write.\nTo represent more complex logic chains, it might make sense to use multiple CRDTs and write them at once inside of a single atomic document write."}),"\n",(0,s.jsxs)(n.p,{children:["For these cases, the ",(0,s.jsx)(n.code,{children:"updateCRDT()"})," method allows to pass an array of operations."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await myDocument.updateCRDT([\n    {\n        selector: { /** ... **/ },\n        ifMatch: { /** ... **/ }\n    },\n    {\n        selector: { /** ... **/ },\n        ifMatch: { /** ... **/ }\n    },\n    {\n        selector: { /** ... **/ },\n        ifMatch: { /** ... **/ }\n    },\n    {\n        selector: { /** ... **/ },\n        ifMatch: { /** ... **/ }\n    }\n]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"crdts-on-inserts",children:"CRDTs on inserts"}),"\n",(0,s.jsxs)(n.p,{children:["When CRDTs are enabled with the plugin, all insert operations are automatically mapped as CRDT operation with the ",(0,s.jsx)(n.code,{children:"$set"})," operator."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Calling RxCollection.insert()\nawait myRxCollection.insert({\n    id: 'foo'\n    points: 1\n});\n// is exactly equal to calling insertCRDT()\nawait myRxCollection.insertCRDT({\n    ifMatch: {\n        $set: {\n            id: 'foo'\n            points: 1\n        }\n    }\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When the same document is inserted in multiple client instances and then replicated, a conflict will emerge and the insert-CRDTs will overwrite each other in a deterministic order.\nYou can use ",(0,s.jsx)(n.code,{children:"insertCRDT()"})," to make conditional insert operations with any logic. To check for the previous existence of a document, use the ",(0,s.jsx)(n.code,{children:"$exists"})," query operation on the primary key of the document."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await myRxCollection.insertCRDT({\n    selector: {\n        // only run if the document did not exist before.\n        id: { $exists: false }\n    }, \n    ifMatch: {\n        // if the document did not exist, insert it\n        $set: {\n            id: 'foo'\n            points: 1\n        }\n    },\n    ifNotMatch: {\n        // if document existed already, increment the points by +1\n        $inc: {\n            points: 1\n        }\n    }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deleting-documents",children:"Deleting documents"}),"\n",(0,s.jsxs)(n.p,{children:["You can delete a document with a CRDT operation by setting ",(0,s.jsx)(n.code,{children:"_deleted"})," to true. Calling ",(0,s.jsx)(n.code,{children:"RxDocument.remove()"})," will do exactly the same when CRDTs are activated."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await doc.updateCRDT({\n    ifMatch: {\n        $set: {\n            _deleted: true\n        }\n    }\n});\n\n// OR\nawait doc.remove();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"crdts-with-replication",children:"CRDTs with replication"}),"\n",(0,s.jsxs)(n.p,{children:["CRDT operations are stored inside of a special field besides your 'normal' document fields.\nWhen replicating document data with the ",(0,s.jsx)(n.a,{href:"/replication.html",children:"RxDB replication"})," or the ",(0,s.jsx)(n.a,{href:"/replication-couchdb.html",children:"CouchDB replication"})," or even any custom replication, the CRDT operations must be replicated together with the document data as if they would be 'normal' a document property."]}),"\n",(0,s.jsxs)(n.p,{children:["When any instances makes a write to the document, it is required to update the CRDT operations accordingly. For example if your custom backend updates a document, it must also do that by adding a CRDT operation. In ",(0,s.jsx)(n.a,{href:"/dev-mode.html",children:"dev-mode"})," RxDB will refuse to store any document data where the document properties do not match the result of the CRDT operations."]}),"\n",(0,s.jsx)(n.h2,{id:"why-not-automergejs-or-yjs",children:"Why not automerge.js or yjs?"}),"\n",(0,s.jsxs)(n.p,{children:["There are already CRDT libraries out there that have been considered to be used with RxDB. The biggest ones are ",(0,s.jsx)(n.a,{href:"https://github.com/automerge/automerge",children:"automerge"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/yjs/yjs",children:"yjs"}),". The decision was made to not use these but instead go for a more NoSQL way of designing the CRDT format because:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Users do not have to learn a new syntax but instead can use the NoSQL query operations which they already know to manipulate the JSON data of a document."}),"\n",(0,s.jsxs)(n.li,{children:["RxDB is often used to ",(0,s.jsx)(n.a,{href:"/replication.html",children:"replicate"})," data with any custom backend on an already existing infrastructure. Using NoSQL operators instead of binary data in CRDTs, makes it easy to implement the exact same logic on these backends so that the backend can also do document writes and still be compliant to the RxDB CRDT plugin."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["So instead of using YJS or Automerge with a database, you can use RxDB with the CRDT plugin to have a more database specific CRDT approach. This gives you additional features for free such as ",(0,s.jsx)(n.a,{href:"/schema-validation.html",children:"schema validation"})," or ",(0,s.jsx)(n.a,{href:"/migration-schema.html",children:"data migration"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-not-use-crdts",children:"When to not use CRDTs"}),"\n",(0,s.jsx)(n.p,{children:"CRDT can only be use when your business logic allows to represent document changes via static json operators.\nIf you can have cases where user interaction is required to correctly merge conflicting document states, you cannot use CRDTs for that."}),"\n",(0,s.jsx)(n.p,{children:"Also when CRDTs are used, it is no longer allowed to do non-CRDT writes to the document properties."}),"\n",(0,s.jsx)(n.h2,{id:"crdt-alternative",children:"CRDT Alternative"}),"\n",(0,s.jsxs)(n.p,{children:["While the CRDT plugin can automatically merge concurrent document updates, it is not the only way to resolve conflicts in RxDB.\nAn alternative approach to CRDT is to use RxDB's built-in ",(0,s.jsx)(n.a,{href:"/transactions-conflicts-revisions.html",children:"conflict handling system"}),"."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Why use conflict handlers instead of CRDT?"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Conflict handlers offer a ",(0,s.jsx)(n.strong,{children:"simpler and more flexible"}),' way to manage data conflicts. Instead of encoding changes as CRDT operations, you define how RxDB should decide which document version "wins" with plain JavaScript code. This approach is easier to reason about because it works directly with your domain logic. For example, you can compare timestamps, prioritize certain fields, or even involve user interaction to resolve conflicts.']}),"\n",(0,s.jsx)(n.p,{children:"Conflict handlers are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easier to understand"}),": you work with plain document states instead of CRDT operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fully customizable"}),": you can define any merge strategy, from simple last-write-wins to complex rule-based logic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compatible with all data types"}),": unlike CRDTs, which are best suited for numeric or set-based updates."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transparent"}),": you always know which state is being written and why."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"downsides-of-crdts",children:"Downsides of CRDTs"}),"\n",(0,s.jsx)(n.p,{children:"CRDTs are powerful for automatic conflict-free merging, but they also come with trade-offs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Higher conceptual complexity"}),": CRDTs require understanding of operation semantics, version vectors, and merge determinism."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited flexibility"}),": you can only express changes that fit the supported JSON-style update operators."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Difficult debugging"}),": when merges don't behave as expected, it can be hard to trace the sequence of CRDT operations that led to a state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Overhead for simple cases"}),": if your data rarely conflicts or needs human oversight, using CRDTs can add unnecessary complexity."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-choose-conflict-handlers",children:"When to choose conflict handlers"}),"\n",(0,s.jsx)(n.p,{children:"Use conflict handlers as CRDT alternative if:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You want full control over merge logic."}),"\n",(0,s.jsx)(n.li,{children:"Your data model includes contextual or user-specific decisions."}),"\n",(0,s.jsx)(n.li,{children:"You prefer a straightforward, rule-based resolution system over automatic merges."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Use CRDTs if:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Your app performs frequent offline writes that can be merged deterministically."}),"\n",(0,s.jsx)(n.li,{children:"Your data can be represented as additive, numeric, or array-based updates."}),"\n",(0,s.jsx)(n.li,{children:"You want minimal manual intervention during replication."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Both methods are first-class citizens in RxDB. CRDTs focus on ",(0,s.jsx)(n.strong,{children:"automatic, deterministic merging"}),", while conflict handlers emphasize ",(0,s.jsx)(n.strong,{children:"clarity, flexibility, and control"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"example-merging-different-fields-with-conflict-handlers-instead-of-crdt",children:"Example: merging different fields with conflict handlers instead of CRDT"}),"\n",(0,s.jsxs)(n.p,{children:["For example, imagine two users edit different fields of the same document at the same time. One updates a ",(0,s.jsx)(n.code,{children:"name"}),", the other updates a ",(0,s.jsx)(n.code,{children:"score"}),". A custom conflict handler can merge both changes so no data is lost:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const mergeFieldsHandler = {\n  isEqual: (a, b) => JSON.stringify(a) === JSON.stringify(b),\n  resolve: (input) => {\n    return {\n      ...input.realMasterState,\n      name: input.newDocumentState.name ?? input.realMasterState.name,\n      score: Math.max(input.newDocumentState.score, input.realMasterState.score)\n    };\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example, if the two versions change different properties, the final merged document includes both updates. This kind of logic is often easier to reason about than designing equivalent CRDT operations."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);