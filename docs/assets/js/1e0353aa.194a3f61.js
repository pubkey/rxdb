"use strict";(self.webpackChunkrxdb=self.webpackChunkrxdb||[]).push([[8588],{7602:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>n,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"rx-storage","title":"\u2699\ufe0f RxStorage Layer - Choose the Perfect RxDB Storage for Every Use Case","description":"Discover how RxDB\'s modular RxStorage lets you swap engines and unlock top performance, no matter the environment or use case.","source":"@site/docs/rx-storage.md","sourceDirName":".","slug":"/rx-storage.html","permalink":"/rx-storage.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\u2699\ufe0f RxStorage Layer - Choose the Perfect RxDB Storage for Every Use Case","slug":"rx-storage.html","description":"Discover how RxDB\'s modular RxStorage lets you swap engines and unlock top performance, no matter the environment or use case."},"sidebar":"tutorialSidebar","previous":{"title":"RxQuery","permalink":"/rx-query.html"},"next":{"title":"LocalStorage (Browser)","permalink":"/rx-storage-localstorage.html"}}');var o=a(4848),s=a(8453);const n={title:"\u2699\ufe0f RxStorage Layer - Choose the Perfect RxDB Storage for Every Use Case",slug:"rx-storage.html",description:"Discover how RxDB's modular RxStorage lets you swap engines and unlock top performance, no matter the environment or use case."},i="RxStorage",l={},d=[{value:"Quick Recommendations",id:"quick-recommendations",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Storing much data in a browser securely",id:"storing-much-data-in-a-browser-securely",level:3},{value:"High query Load",id:"high-query-load",level:3},{value:"Low Latency on Writes and Simple Reads",id:"low-latency-on-writes-and-simple-reads",level:3},{value:"All RxStorage Implementations List",id:"all-rxstorage-implementations-list",level:2},{value:"Memory",id:"memory",level:3},{value:"LocalStorage",id:"localstorage",level:3},{value:"\ud83d\udc51 IndexedDB",id:"-indexeddb",level:3},{value:"\ud83d\udc51 OPFS",id:"-opfs",level:3},{value:"\ud83d\udc51 Filesystem Node",id:"-filesystem-node",level:3},{value:"Storage Wrapper Plugins",id:"storage-wrapper-plugins",level:3},{value:"\ud83d\udc51 Worker",id:"-worker",level:4},{value:"\ud83d\udc51 SharedWorker",id:"-sharedworker",level:4},{value:"Remote",id:"remote",level:4},{value:"\ud83d\udc51 Sharding",id:"-sharding",level:4},{value:"\ud83d\udc51 Memory Mapped",id:"-memory-mapped",level:4},{value:"\ud83d\udc51 Localstorage Meta Optimizer",id:"-localstorage-meta-optimizer",level:4},{value:"Electron IpcRenderer &amp; IpcMain",id:"electron-ipcrenderer--ipcmain",level:4},{value:"Third Party based Storages",id:"third-party-based-storages",level:3},{value:"\ud83d\udc51 SQLite",id:"-sqlite",level:4},{value:"Dexie.js",id:"dexiejs",level:4},{value:"MongoDB",id:"mongodb",level:4},{value:"DenoKV",id:"denokv",level:4},{value:"FoundationDB",id:"foundationdb",level:4}];function h(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"rxstorage",children:"RxStorage"})}),"\n",(0,o.jsxs)(r.p,{children:["RxDB is not a self contained database. Instead the data is stored in an implementation of the ",(0,o.jsx)(r.a,{href:"https://github.com/pubkey/rxdb/blob/master/src/types/rx-storage.interface.d.ts",children:"RxStorage interface"}),". This allows you to ",(0,o.jsx)(r.strong,{children:"switch out"})," the underlying data layer, depending on the JavaScript environment and performance requirements. For example you can use the SQLite storage for a capacitor app or you can use the LocalStorage RxStorage to store data in localstorage in a browser based application. There are also storages for other JavaScript runtimes like Node.js, React-Native, NativeScript and more."]}),"\n",(0,o.jsx)(r.h2,{id:"quick-recommendations",children:"Quick Recommendations"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:["In the Browser: Use the ",(0,o.jsx)(r.a,{href:"/rx-storage-localstorage.html",children:"LocalStorage"})," storage for simple setup and small build size. For bigger datasets, use either the ",(0,o.jsx)(r.a,{href:"/rx-storage-dexie.html",children:"dexie.js storage"})," (free) or the ",(0,o.jsx)(r.a,{href:"/rx-storage-indexeddb.html",children:"IndexedDB RxStorage"})," if you have ",(0,o.jsx)(r.a,{href:"/premium/",children:"\ud83d\udc51 premium access"})," which is a bit faster and has a smaller build size."]}),"\n",(0,o.jsxs)(r.li,{children:["In ",(0,o.jsx)(r.a,{href:"/electron-database.html",children:"Electron"})," and ",(0,o.jsx)(r.a,{href:"/react-native-database.html",children:"ReactNative"}),": Use the ",(0,o.jsx)(r.a,{href:"/rx-storage-sqlite.html",children:"SQLite RxStorage"})," if you have ",(0,o.jsx)(r.a,{href:"/premium/",children:"\ud83d\udc51 premium access"})," or the ",(0,o.jsx)(r.a,{href:"/rx-storage-sqlite.html",children:"trial-SQLite RxStorage"})," for tryouts."]}),"\n",(0,o.jsxs)(r.li,{children:["In Capacitor: Use the ",(0,o.jsx)(r.a,{href:"/rx-storage-sqlite.html",children:"SQLite RxStorage"})," if you have ",(0,o.jsx)(r.a,{href:"/premium/",children:"\ud83d\udc51 premium access"}),", otherwise use the ",(0,o.jsx)(r.a,{href:"/rx-storage-localstorage.html",children:"localStorage"})," storage."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,o.jsx)(r.p,{children:"The RxStorage layer of RxDB is very flexible. Here are some examples on how to configure more complex settings:"}),"\n",(0,o.jsx)(r.h3,{id:"storing-much-data-in-a-browser-securely",children:"Storing much data in a browser securely"}),"\n",(0,o.jsx)(r.p,{children:"Lets say you build a browser app that needs to store a big amount of data as secure as possible. Here we can use a combination of the storages (encryption, IndexedDB, compression, schema-checks) that increase security and reduce the stored data size."}),"\n",(0,o.jsxs)(r.p,{children:["We use the schema-validation on the top level to ensure schema-errors are clearly readable and do not contain ",(0,o.jsx)(r.a,{href:"/encryption.html",children:"encrypted"}),"/",(0,o.jsx)(r.a,{href:"/key-compression.html",children:"compressed"})," data. The encryption is used inside of the compression because encryption of compressed data is more efficient."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:"import { wrappedValidateAjvStorage } from 'rxdb/plugins/validate-ajv';\nimport { wrappedKeyCompressionStorage } from 'rxdb/plugins/key-compression';\nimport { wrappedKeyEncryptionCryptoJsStorage } from 'rxdb/plugins/encryption-crypto-js';\nimport { getRxStorageIndexedDB } from 'rxdb-premium/plugins/storage-indexeddb';\n\nconst myDatabase = await createRxDatabase({\n    storage: wrappedValidateAjvStorage({\n        storage: wrappedKeyCompressionStorage({\n            storage: wrappedKeyEncryptionCryptoJsStorage({\n                storage: getRxStorageIndexedDB()\n            })\n        })\n    })\n});\n"})}),"\n",(0,o.jsx)(r.h3,{id:"high-query-load",children:"High query Load"}),"\n",(0,o.jsxs)(r.p,{children:["Also we can utilize a combination of storages to create a database that is optimized to run complex queries on the data really fast. Here we use the shardingstorage together with the worker storage. This allows to run queries in parallel multithreading instead of a single JavaScript process. Because the worker initialization can slow down the initial page load, we also use the ",(0,o.jsx)(r.a,{href:"/rx-storage-localstorage-meta-optimizer.html",children:"localstorage-meta-optimizer"})," to improve initialization time."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:"import { getRxStorageSharding } from 'rxdb-premium/plugins/storage-sharding';\nimport { getRxStorageWorker } from 'rxdb-premium/plugins/storage-worker';\nimport { getRxStorageIndexedDB } from 'rxdb-premium/plugins/storage-indexeddb';\nimport { getLocalstorageMetaOptimizerRxStorage } from 'rxdb-premium/plugins/storage-localstorage-meta-optimizer';\n\nconst myDatabase = await createRxDatabase({\n    storage: getLocalstorageMetaOptimizerRxStorage({\n        storage: getRxStorageSharding({\n            storage: getRxStorageWorker({\n                workerInput: 'path/to/worker.js',\n                storage: getRxStorageIndexedDB()\n            })\n        })\n    })\n});\n"})}),"\n",(0,o.jsx)(r.h3,{id:"low-latency-on-writes-and-simple-reads",children:"Low Latency on Writes and Simple Reads"}),"\n",(0,o.jsx)(r.p,{children:"Here we create a storage configuration that is optimized to have a low latency on simple reads and writes. It uses the memory-mapped storage to fetch and store data in memory. For persistence the OPFS storage is used in the main thread which has lower latency for fetching big chunks of data when at initialization the data is loaded from disc into memory. We do not use workers because sending data from the main thread to workers and backwards would increase the latency."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-ts",children:"import { getLocalstorageMetaOptimizerRxStorage } from 'rxdb-premium/plugins/storage-localstorage-meta-optimizer';\nimport { getMemoryMappedRxStorage } from 'rxdb-premium/plugins/storage-memory-mapped';\nimport { getRxStorageOPFSMainThread } from 'rxdb-premium/plugins/storage-worker';\n\n\nconst myDatabase = await createRxDatabase({\n    storage: getLocalstorageMetaOptimizerRxStorage({\n        storage: getMemoryMappedRxStorage({\n            storage: getRxStorageOPFSMainThread()\n        })\n    })\n});\n"})}),"\n",(0,o.jsx)(r.h2,{id:"all-rxstorage-implementations-list",children:"All RxStorage Implementations List"}),"\n",(0,o.jsx)(r.h3,{id:"memory",children:"Memory"}),"\n",(0,o.jsxs)(r.p,{children:["A storage that stores the data in as plain data in the memory of the JavaScript process. Really fast and can be used in all environments. ",(0,o.jsx)(r.a,{href:"/rx-storage-memory.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"localstorage",children:"LocalStorage"}),"\n",(0,o.jsxs)(r.p,{children:["The localstroage based storage stores the data inside of a browsers ",(0,o.jsx)(r.a,{href:"/articles/localstorage.html",children:"localStorage API"}),". It is the easiest to set up and has a small bundle size. ",(0,o.jsx)(r.strong,{children:"If you are new to RxDB, you should start with the LocalStorage RxStorage"}),". ",(0,o.jsx)(r.a,{href:"/rx-storage-localstorage.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"-indexeddb",children:"\ud83d\udc51 IndexedDB"}),"\n",(0,o.jsxs)(r.p,{children:["The IndexedDB ",(0,o.jsx)(r.code,{children:"RxStorage"})," is based on plain IndexedDB. For most use cases, this has the best performance together with the OPFS storage. ",(0,o.jsx)(r.a,{href:"/rx-storage-indexeddb.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"-opfs",children:"\ud83d\udc51 OPFS"}),"\n",(0,o.jsxs)(r.p,{children:["The OPFS ",(0,o.jsx)(r.code,{children:"RxStorage"})," is based on the File System Access API. This has the best performance of all other non-in-memory storage, when RxDB is used inside of a browser. ",(0,o.jsx)(r.a,{href:"/rx-storage-opfs.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"-filesystem-node",children:"\ud83d\udc51 Filesystem Node"}),"\n",(0,o.jsxs)(r.p,{children:["The Filesystem Node storage is best suited when you use RxDB in a Node.js process or with ",(0,o.jsx)(r.a,{href:"/electron.html",children:"electron.js"}),". ",(0,o.jsx)(r.a,{href:"/rx-storage-filesystem-node.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"storage-wrapper-plugins",children:"Storage Wrapper Plugins"}),"\n",(0,o.jsx)(r.h4,{id:"-worker",children:"\ud83d\udc51 Worker"}),"\n",(0,o.jsxs)(r.p,{children:["The worker RxStorage is a wrapper around any other RxStorage which allows to run the storage in a WebWorker (in browsers) or a Worker Thread (in Node.js). By doing so, you can take CPU load from the main process and move it into the worker's process which can improve the perceived performance of your application. ",(0,o.jsx)(r.a,{href:"/rx-storage-worker.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"-sharedworker",children:"\ud83d\udc51 SharedWorker"}),"\n",(0,o.jsxs)(r.p,{children:["The worker RxStorage is a wrapper around any other RxStorage which allows to run the storage in a SharedWorker (only in browsers). By doing so, you can take CPU load from the main process and move it into the worker's process which can improve the perceived performance of your application. ",(0,o.jsx)(r.a,{href:"/rx-storage-shared-worker.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"remote",children:"Remote"}),"\n",(0,o.jsxs)(r.p,{children:["The Remote RxStorage is made to use a remote storage and communicate with it over an asynchronous message channel. The remote part could be on another JavaScript process or even on a different host machine. Mostly used internally in other storages like Worker or Electron-ipc. ",(0,o.jsx)(r.a,{href:"/rx-storage-remote.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"-sharding",children:"\ud83d\udc51 Sharding"}),"\n",(0,o.jsxs)(r.p,{children:["On some ",(0,o.jsx)(r.code,{children:"RxStorage"})," implementations (like IndexedDB), a huge performance improvement can be done by sharding the documents into multiple database instances. With the sharding plugin you can wrap any other ",(0,o.jsx)(r.code,{children:"RxStorage"})," into a sharded storage. ",(0,o.jsx)(r.a,{href:"/rx-storage-sharding.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"-memory-mapped",children:"\ud83d\udc51 Memory Mapped"}),"\n",(0,o.jsxs)(r.p,{children:["The memory-mapped ",(0,o.jsx)(r.a,{href:"/rx-storage.html",children:"RxStorage"})," is a wrapper around any other RxStorage. The wrapper creates an in-memory storage that is used for query and write operations. This memory instance stores its data in an underlying storage for persistence.\nThe main reason to use this is to improve query/write performance while still having the data stored on disc. ",(0,o.jsx)(r.a,{href:"/rx-storage-memory-mapped.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"-localstorage-meta-optimizer",children:"\ud83d\udc51 Localstorage Meta Optimizer"}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.a,{href:"/rx-storage.html",children:"RxStorage"})," Localstorage Meta Optimizer is a wrapper around any other RxStorage. The wrapper uses the original RxStorage for normal collection documents. But to optimize the initial page load time, it uses ",(0,o.jsx)(r.a,{href:"/articles/localstorage.html",children:"localstorage"})," to store the plain key-value metadata that RxDB needs to create databases and collections. This plugin can only be used in browsers. ",(0,o.jsx)(r.a,{href:"/rx-storage-localstorage-meta-optimizer.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"electron-ipcrenderer--ipcmain",children:"Electron IpcRenderer & IpcMain"}),"\n",(0,o.jsxs)(r.p,{children:["To use RxDB in ",(0,o.jsx)(r.a,{href:"/electron-database.html",children:"electron"}),", it is recommended to run the RxStorage in the main process and the RxDatabase in the renderer processes. With the rxdb electron plugin you can create a remote RxStorage and consume it from the renderer process. ",(0,o.jsx)(r.a,{href:"/electron.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h3,{id:"third-party-based-storages",children:"Third Party based Storages"}),"\n",(0,o.jsx)(r.h4,{id:"-sqlite",children:"\ud83d\udc51 SQLite"}),"\n",(0,o.jsxs)(r.p,{children:["The SQLite storage has great performance when RxDB is used on ",(0,o.jsx)(r.strong,{children:"Node.js"}),", ",(0,o.jsx)(r.strong,{children:"Electron"}),", ",(0,o.jsx)(r.strong,{children:"React Native"}),", ",(0,o.jsx)(r.strong,{children:"Cordova"})," or ",(0,o.jsx)(r.strong,{children:"Capacitor"}),". ",(0,o.jsx)(r.a,{href:"/rx-storage-sqlite.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"dexiejs",children:"Dexie.js"}),"\n",(0,o.jsxs)(r.p,{children:["The Dexie.js based storage is based on the Dexie.js IndexedDB wrapper library. ",(0,o.jsx)(r.a,{href:"/rx-storage-dexie.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"mongodb",children:"MongoDB"}),"\n",(0,o.jsxs)(r.p,{children:["To use RxDB on the server side, the MongoDB RxStorage provides a way of having a secure, scalable and performant storage based on the popular MongoDB NoSQL database ",(0,o.jsx)(r.a,{href:"/rx-storage-mongodb.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"denokv",children:"DenoKV"}),"\n",(0,o.jsxs)(r.p,{children:["To use RxDB in Deno. The DenoKV RxStorage provides a way of having a secure, scalable and performant storage based on the Deno Key Value Store. ",(0,o.jsx)(r.a,{href:"/rx-storage-denokv.html",children:"Read more"})]}),"\n",(0,o.jsx)(r.h4,{id:"foundationdb",children:"FoundationDB"}),"\n",(0,o.jsxs)(r.p,{children:["To use RxDB on the server side, the FoundationDB RxStorage provides a way of having a secure, fault-tolerant and performant storage. ",(0,o.jsx)(r.a,{href:"/rx-storage-foundationdb.html",children:"Read more"})]})]})}function c(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,r,a)=>{a.d(r,{R:()=>n,x:()=>i});var t=a(6540);const o={},s=t.createContext(o);function n(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);