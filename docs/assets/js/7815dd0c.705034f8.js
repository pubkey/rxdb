"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[5335],{2015:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"population","title":"Populate and Link Docs in RxDB","description":"Learn how to reference and link documents across collections in RxDB. Discover easy population without joins and handle complex relationships.","source":"@site/docs/population.md","sourceDirName":".","slug":"/population.html","permalink":"/population.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Populate and Link Docs in RxDB","slug":"population.html","description":"Learn how to reference and link documents across collections in RxDB. Discover easy population without joins and handle complex relationships."},"sidebar":"tutorialSidebar","previous":{"title":"CRDT","permalink":"/crdt.html"},"next":{"title":"ORM","permalink":"/orm.html"}}');var a=t(4848),i=t(8453);const r={title:"Populate and Link Docs in RxDB",slug:"population.html",description:"Learn how to reference and link documents across collections in RxDB. Discover easy population without joins and handle complex relationships."},s="Population",l={},c=[{value:"Schema with ref",id:"schema-with-ref",level:2},{value:"populate()",id:"populate",level:2},{value:"via method",id:"via-method",level:3},{value:"via getter",id:"via-getter",level:3},{value:"Example with nested reference",id:"example-with-nested-reference",level:2},{value:"Example with array",id:"example-with-array",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"population",children:"Population"})}),"\n",(0,a.jsx)(n.p,{children:"There are no joins in RxDB but sometimes we still want references to documents in other collections. This is where population comes in. You can specify a relation from one RxDocument to another RxDocument in the same or another RxCollection of the same database.\nThen you can get the referenced document with the population-getter."}),"\n",(0,a.jsxs)(n.p,{children:["This works exactly like population with ",(0,a.jsx)(n.a,{href:"http://mongoosejs.com/docs/populate.html",children:"mongoose"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"schema-with-ref",children:"Schema with ref"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ref"}),"-keyword in properties describes to which collection the field-value belongs to (has a relationship)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export const refHuman = {\n    title: 'human related to other human',\n    version: 0,\n    primaryKey: 'name',\n    properties: {\n        name: {\n            type: 'string'\n        },\n        bestFriend: {\n            ref: 'human',     // refers to collection human\n            type: 'string'    // ref-values must always be string or ['string','null'] (primary of foreign RxDocument) \n        }\n    }\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also have a one-to-many reference by using a string-array."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"export const schemaWithOneToManyReference = {\n  version: 0,\n  primaryKey: 'name',\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    },\n    friends: {\n      type: 'array',\n      ref: 'human',\n      items: {\n        type: 'string'\n      }\n    }\n  }\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"populate",children:"populate()"}),"\n",(0,a.jsx)(n.h3,{id:"via-method",children:"via method"}),"\n",(0,a.jsx)(n.p,{children:"To get the referred RxDocument, you can use the populate()-method.\nIt takes the field-path as attribute and returns a Promise which resolves to the foreign document or null if not found."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"await humansCollection.insert({\n  name: 'Alice',\n  bestFriend: 'Carol'\n});\nawait humansCollection.insert({\n  name: 'Bob',\n  bestFriend: 'Alice'\n});\nconst doc = await humansCollection.findOne('Bob').exec();\nconst bestFriend = await doc.populate('bestFriend');\nconsole.dir(bestFriend); //> RxDocument[Alice]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"via-getter",children:"via getter"}),"\n",(0,a.jsxs)(n.p,{children:["You can also get the populated RxDocument with the direct getter. Therefore you have to add an underscore suffix ",(0,a.jsx)(n.code,{children:"_"})," to the fieldname.\nThis works also on nested values."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"await humansCollection.insert({\n  name: 'Alice',\n  bestFriend: 'Carol'\n});\nawait humansCollection.insert({\n  name: 'Bob',\n  bestFriend: 'Alice'\n});\nconst doc = await humansCollection.findOne('Bob').exec();\nconst bestFriend = await doc.bestFriend_; // notice the underscore_\nconsole.dir(bestFriend); //> RxDocument[Alice]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"example-with-nested-reference",children:"Example with nested reference"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const myCollection = await myDatabase.addCollections({\n  human: {\n    schema: {\n      version: 0,\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        },\n        family: {\n          type: 'object',\n          properties: {\n            mother: {\n              type: 'string',\n              ref: 'human'\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\nconst mother = await myDocument.family.mother_;\nconsole.dir(mother); //> RxDocument\n"})}),"\n",(0,a.jsx)(n.h2,{id:"example-with-array",children:"Example with array"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const myCollection = await myDatabase.addCollections({\n  human: {\n    schema: {\n      version: 0,\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        },\n        friends: {\n          type: 'array',\n          ref: 'human',\n          items: {\n              type: 'string'\n          }\n        }\n      }\n    }\n  } \n});\n\n//[insert other humans here]\n\nawait myCollection.insert({\n  name: 'Alice',\n  friends: [\n    'Bob',\n    'Carol',\n    'Dave'\n  ]\n});\n\nconst doc = await humansCollection.findOne('Alice').exec();\nconst friends = await myDocument.friends_;\nconsole.dir(friends); //> Array.<RxDocument>\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(6540);const a={},i=o.createContext(a);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);