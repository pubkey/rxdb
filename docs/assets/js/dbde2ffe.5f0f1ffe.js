"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[6543],{4506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"rx-document","title":"RxDocument","description":"Master RxDB\'s RxDocument - Insert, find, update, remove, and more for streamlined data handling in modern apps.","source":"@site/docs/rx-document.md","sourceDirName":".","slug":"/rx-document.html","permalink":"/rx-document.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"RxDocument","slug":"rx-document.html","description":"Master RxDB\'s RxDocument - Insert, find, update, remove, and more for streamlined data handling in modern apps."},"sidebar":"tutorialSidebar","previous":{"title":"RxCollection","permalink":"/rx-collection.html"},"next":{"title":"RxQuery","permalink":"/rx-query.html"}}');var o=t(4848),s=t(8453);const i={title:"RxDocument",slug:"rx-document.html",description:"Master RxDB's RxDocument - Insert, find, update, remove, and more for streamlined data handling in modern apps."},l="RxDocument",d={},c=[{value:"insert",id:"insert",level:2},{value:"find",id:"find",level:2},{value:"Functions",id:"functions",level:2},{value:"get()",id:"get",level:3},{value:"get$()",id:"get-1",level:3},{value:"proxy-get",id:"proxy-get",level:3},{value:"update()",id:"update",level:3},{value:"modify()",id:"modify",level:3},{value:"patch()",id:"patch",level:3},{value:"Prevent conflicts with the incremental methods",id:"prevent-conflicts-with-the-incremental-methods",level:3},{value:"getLatest()",id:"getlatest",level:3},{value:"Observe $",id:"observe-",level:3},{value:"remove()",id:"remove",level:3},{value:"Remove and update in a single atomic operation",id:"remove-and-update-in-a-single-atomic-operation",level:3},{value:"deleted$",id:"deleted",level:3},{value:"get deleted",id:"get-deleted",level:3},{value:"toJSON()",id:"tojson",level:3},{value:"toMutableJSON()",id:"tomutablejson",level:3},{value:"isRxDocument",id:"isrxdocument",level:3}];function r(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"rxdocument",children:"RxDocument"})}),"\n",(0,o.jsxs)(n.p,{children:["A RxDocument is a object which represents the data of a single JSON document is stored in a collection. It can be compared to a single record in a relational database table. You get an ",(0,o.jsx)(n.code,{children:"RxDocument"})," either as return on inserts/updates, or as result-set of ",(0,o.jsx)(n.a,{href:"/rx-query.html",children:"queries"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"RxDB works on RxDocuments instead of plain JSON data to have more convenient operations on the documents. Also Documents that are fetched multiple times by different queries or operations are automatically de-duplicated by RxDB in memory."}),"\n",(0,o.jsx)(n.h2,{id:"insert",children:"insert"}),"\n",(0,o.jsx)(n.p,{children:"To insert a document into a collection, you have to call the collection's .insert()-function."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"await myCollection.insert({\n  name: 'foo',\n  lastname: 'bar'\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"find",children:"find"}),"\n",(0,o.jsxs)(n.p,{children:["To find documents in a collection, you have to call the collection's .find()-function. ",(0,o.jsx)(n.a,{href:"/rx-query.html",children:"See RxQuery"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const docs = await myCollection.find().exec(); // <- find all documents\n"})}),"\n",(0,o.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,o.jsx)(n.h3,{id:"get",children:"get()"}),"\n",(0,o.jsx)(n.p,{children:"This will get a single field of the document. If the field is encrypted, it will be automatically decrypted before returning."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const name = myDocument.get('name'); // returns the name\n// OR\nconst name = myDocument.name;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"get-1",children:"get$()"}),"\n",(0,o.jsx)(n.p,{children:"This function returns an observable of the given paths-value.\nThe current value of this path will be emitted each time the document changes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// get the live-updating value of 'name'\nvar isName;\nmyDocument.get$('name')\n  .subscribe(newName => {\n    isName = newName;\n  });\n\nawait myDocument.incrementalPatch({name: 'foobar2'});\nconsole.dir(isName); // isName is now 'foobar2'\n\n// OR\n\nmyDocument.name$\n  .subscribe(newName => {\n    isName = newName;\n  });\n\n"})}),"\n",(0,o.jsx)(n.h3,{id:"proxy-get",children:"proxy-get"}),"\n",(0,o.jsxs)(n.p,{children:["All properties of a ",(0,o.jsx)(n.code,{children:"RxDocument"})," are assigned as getters so you can also directly access values instead of using the get()-function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"  // Identical to myDocument.get('name');\n  var name = myDocument.name;\n  // Can also get nested values.\n  var nestedValue = myDocument.whatever.nestedfield;\n\n  // Also usable with observables:\n  myDocument.firstName$.subscribe(newName => console.log('name is: ' + newName));\n  // > 'name is: Stefe'\n  await myDocument.incrementalPatch({firstName: 'Steve'});\n  // > 'name is: Steve'\n"})}),"\n",(0,o.jsx)(n.h3,{id:"update",children:"update()"}),"\n",(0,o.jsxs)(n.p,{children:["Updates the document based on the ",(0,o.jsx)(n.a,{href:"https://docs.mongodb.com/manual/reference/operator/update-field/",children:"mongo-update-syntax"}),", based on the ",(0,o.jsx)(n.a,{href:"https://github.com/kofrasa/mingo#updating-documents",children:"mingo library"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"\n/**\n * If not done before, you have to add the update plugin.\n */\nimport { addRxPlugin } from 'rxdb';\nimport { RxDBUpdatePlugin } from 'rxdb/plugins/update';\naddRxPlugin(RxDBUpdatePlugin);\n\nawait myDocument.update({\n    $inc: {\n        age: 1 // increases age by 1\n    },\n    $set: {\n        firstName: 'foobar' // sets firstName to foobar\n    }\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"modify",children:"modify()"}),"\n",(0,o.jsx)(n.p,{children:"Updates a documents data based on a function that mutates the current data and returns the new value."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"\nconst changeFunction = (oldData) => {\n    oldData.age = oldData.age + 1;\n    oldData.name = 'foooobarNew';\n    return oldData;\n}\nawait myDocument.modify(changeFunction);\nconsole.log(myDocument.name); // 'foooobarNew'\n"})}),"\n",(0,o.jsx)(n.h3,{id:"patch",children:"patch()"}),"\n",(0,o.jsx)(n.p,{children:"Overwrites the given attributes over the documents data."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"await myDocument.patch({\n  name: 'Steve',\n  age: undefined // setting an attribute to undefined will remove it\n});\nconsole.log(myDocument.name); // 'Steve'\n"})}),"\n",(0,o.jsx)(n.h3,{id:"prevent-conflicts-with-the-incremental-methods",children:"Prevent conflicts with the incremental methods"}),"\n",(0,o.jsxs)(n.p,{children:["Making a normal change to the non-latest version of a ",(0,o.jsx)(n.code,{children:"RxDocument"})," will lead to a ",(0,o.jsx)(n.code,{children:"409 CONFLICT"})," error because RxDB\nuses ",(0,o.jsx)(n.a,{href:"/transactions-conflicts-revisions.html",children:"revision checks"})," instead of transactions."]}),"\n",(0,o.jsxs)(n.p,{children:["To make a change to a document, no matter what the current state is, you can use the ",(0,o.jsx)(n.code,{children:"incremental"})," methods:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// update\nawait myDocument.incrementalUpdate({\n    $inc: {\n        age: 1 // increases age by 1\n    }\n});\n\n// modify\nawait myDocument.incrementalModify(docData => {\n  docData.age = docData.age + 1;\n  return docData;\n});\n\n// patch\nawait myDocument.incrementalPatch({\n  age: 100\n});\n\n// remove\nawait myDocument.incrementalRemove({\n  age: 100\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getlatest",children:"getLatest()"}),"\n",(0,o.jsxs)(n.p,{children:["Returns the latest known state of the ",(0,o.jsx)(n.code,{children:"RxDocument"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const myDocument = await myCollection.findOne('foobar').exec();\nconst docAfterEdit = await myDocument.incrementalPatch({\n  age: 10\n});\nconst latestDoc = myDocument.getLatest();\nconsole.log(docAfterEdit === latestDoc); // > true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"observe-",children:"Observe $"}),"\n",(0,o.jsxs)(n.p,{children:["Calling this will return an ",(0,o.jsx)(n.a,{href:"https://rxjs.dev/guide/observable",children:"RxJS-Observable"})," which the current newest state of the RxDocument."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// get all changeEvents\nmyDocument.$\n  .subscribe(currentRxDocument => console.dir(currentRxDocument));\n"})}),"\n",(0,o.jsx)(n.h3,{id:"remove",children:"remove()"}),"\n",(0,o.jsxs)(n.p,{children:["This removes the document from the collection. Notice that this will not purge the document from the store but set ",(0,o.jsx)(n.code,{children:"_deleted:true"})," so that it will be no longer returned on queries.\nTo fully purge a document, use the ",(0,o.jsx)(n.a,{href:"/cleanup.html",children:"cleanup plugin"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"myDocument.remove();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"remove-and-update-in-a-single-atomic-operation",children:"Remove and update in a single atomic operation"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes you want to change a documents value and also remove it in the same operation. For example this can be useful when you use ",(0,o.jsx)(n.a,{href:"/replication.html",children:"replication"})," and want to set a ",(0,o.jsx)(n.code,{children:"deletedAt"})," timestamp. Then you might have to ensure that setting this timestamp and deleting the document happens in the same atomic operation."]}),"\n",(0,o.jsxs)(n.p,{children:["To do this the modifying operations of a document accept setting the ",(0,o.jsx)(n.code,{children:"_deleted"})," field. For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"\n// update() and remove()\nawait doc.update({\n  $set: {\n    deletedAt: new Date().getTime(),\n    _deleted: true\n  }\n});\n\n// modify() and remove()\nawait doc.modify(data => {\n  data.age = 1;\n  data._deleted = true;\n  return data;\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"deleted",children:"deleted$"}),"\n",(0,o.jsx)(n.p,{children:"Emits a boolean value, depending on whether the RxDocument is deleted or not."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"let lastState = null;\nmyDocument.deleted$.subscribe(state => lastState = state);\n\nconsole.log(lastState);\n// false\n\nawait myDocument.remove();\n\nconsole.log(lastState);\n// true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"get-deleted",children:"get deleted"}),"\n",(0,o.jsxs)(n.p,{children:["A getter to get the current value of ",(0,o.jsx)(n.code,{children:"deleted$"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"console.log(myDocument.deleted);\n// false\n\nawait myDocument.remove();\n\nconsole.log(myDocument.deleted);\n// true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"tojson",children:"toJSON()"}),"\n",(0,o.jsxs)(n.p,{children:["Returns the document's data as plain json object. This will return an ",(0,o.jsx)(n.strong,{children:"immutable"})," object. To get something that can be modified, use ",(0,o.jsx)(n.code,{children:"toMutableJSON()"})," instead."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const json = myDocument.toJSON();\nconsole.dir(json);\n/* { passportId: 'h1rg9ugdd30o',\n  firstName: 'Carolina',\n  lastName: 'Gibson',\n  age: 33 ...\n*/\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can also set ",(0,o.jsx)(n.code,{children:"withMetaFields: true"})," to get additional meta fields like the revision, attachments or the deleted flag."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const json = myDocument.toJSON(true);\nconsole.dir(json);\n/* { passportId: 'h1rg9ugdd30o',\n  firstName: 'Carolina',\n  lastName: 'Gibson',\n  _deleted: false,\n  _attachments: { ... },\n  _rev: '1-aklsdjfhaklsdjhf...'\n*/\n"})}),"\n",(0,o.jsx)(n.h3,{id:"tomutablejson",children:"toMutableJSON()"}),"\n",(0,o.jsxs)(n.p,{children:["Same as ",(0,o.jsx)(n.code,{children:"toJSON()"})," but returns a deep cloned object that can be mutated afterwards.\nRemember that deep cloning is performance expensive and should only be done when necessary."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const json = myDocument.toMutableJSON();\njson.firstName = 'Alice'; // The returned document can be mutated\n"})}),"\n",(0,o.jsx)(n.admonition,{title:"All methods of RxDocument are bound to the instance",type:"note",children:(0,o.jsxs)(n.p,{children:["When you get a method from a ",(0,o.jsx)(n.code,{children:"RxDocument"}),", the method is automatically bound to the documents instance. This means you do not have to use things like ",(0,o.jsx)(n.code,{children:"myMethod.bind(myDocument)"})," like you would do in jsx."]})}),"\n",(0,o.jsx)(n.h3,{id:"isrxdocument",children:"isRxDocument"}),"\n",(0,o.jsx)(n.p,{children:"Returns true if the given object is an instance of RxDocument. Returns false if not."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const is = isRxDocument(myObj);\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var a=t(6540);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);