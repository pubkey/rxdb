"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[4141],{5579:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"rx-server-scaling","title":"RxServer Scaling - Vertical or Horizontal","description":"Discover vertical and horizontal techniques to boost RxServer. Learn multiple processes, worker threads, and replication for limitless performance.","source":"@site/docs/rx-server-scaling.md","sourceDirName":".","slug":"/rx-server-scaling.html","permalink":"/rx-server-scaling.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"RxServer Scaling - Vertical or Horizontal","slug":"rx-server-scaling.html","description":"Discover vertical and horizontal techniques to boost RxServer. Learn multiple processes, worker threads, and replication for limitless performance."},"sidebar":"tutorialSidebar","previous":{"title":"RxServer","permalink":"/rx-server.html"},"next":{"title":"Transactions Conflicts Revisions","permalink":"/transactions-conflicts-revisions.html"}}');var s=r(4848),n=r(8453);const i={title:"RxServer Scaling - Vertical or Horizontal",slug:"rx-server-scaling.html",description:"Discover vertical and horizontal techniques to boost RxServer. Learn multiple processes, worker threads, and replication for limitless performance."},o="Scaling the RxServer",l={},c=[{value:"Vertical Scaling",id:"vertical-scaling",level:2},{value:"Run multiple JavaScript processes",id:"run-multiple-javascript-processes",level:3},{value:"Using workers to split up the load",id:"using-workers-to-split-up-the-load",level:3},{value:"Use an in-memory storage at the user facing level",id:"use-an-in-memory-storage-at-the-user-facing-level",level:3},{value:"Horizontal Scaling",id:"horizontal-scaling",level:2},{value:"Single Datastore with multiple branches",id:"single-datastore-with-multiple-branches",level:3},{value:"Moving the branches to &quot;the edge&quot;",id:"moving-the-branches-to-the-edge",level:3},{value:"Replicate Databases for Microservices",id:"replicate-databases-for-microservices",level:3},{value:"Use a self-scaling RxStorage",id:"use-a-self-scaling-rxstorage",level:3}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"scaling-the-rxserver",children:"Scaling the RxServer"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.a,{href:"/rx-server.html",children:"RxDB Server"})," run in JavaScript and JavaScript runs on a single process on the operating system. This can make the CPU performance limit to be the main bottleneck when serving requests to your users. To mitigate that problem, there are a wide range of methods to scale up the server so that it can serve more requests at the same time faster."]}),"\n",(0,s.jsx)(t.h2,{id:"vertical-scaling",children:"Vertical Scaling"}),"\n",(0,s.jsx)(t.p,{children:'Vertical Scaling aka "scaling up" has the goal to get more power out of a single server by utilizing more of the servers compute. Vertical scaling should be the first step when you decide it is time to scale.'}),"\n",(0,s.jsx)(t.h3,{id:"run-multiple-javascript-processes",children:"Run multiple JavaScript processes"}),"\n",(0,s.jsxs)(t.p,{children:["To utilize more compute power of your server, the first step is to scale vertically by running the RxDB server on ",(0,s.jsx)(t.strong,{children:"multiple processes"})," in parallel.\nRxDB itself is already build to support multiInstance-usage on the client, like when the user has opened multiple browser tabs at once. The same method works also on the server side in Node.js. You can spawn multiple JavaScript processes that use the same ",(0,s.jsx)(t.a,{href:"/rx-database.html",children:"RxDatabase"})," and the instances will automatically communicate with each other and distribute their data and events with the ",(0,s.jsx)(t.a,{href:"https://github.com/pubkey/broadcast-channel",children:"BroadcastChannel"}),".\nBy default the ",(0,s.jsx)(t.a,{href:"/rx-database.html#multiinstance",children:"multiInstance param"})," is set to ",(0,s.jsx)(t.code,{children:"true"})," when calling ",(0,s.jsx)(t.code,{children:"createRxDatabase()"}),", so you do not have to change anything. To make all processes accessible through the same endpoint, you can put a load-balancer like ",(0,s.jsx)(t.a,{href:"https://nginx.org/en/docs/http/load_balancing.html",children:"nginx"})," in front of them."]}),"\n",(0,s.jsx)(t.h3,{id:"using-workers-to-split-up-the-load",children:"Using workers to split up the load"}),"\n",(0,s.jsxs)(t.p,{children:["Another way to increases the server capacity is to put the storage into a ",(0,s.jsx)(t.a,{href:"/rx-storage-worker.html",children:"Worker thread"}),' so that the "main" thread with the webserver can handle more requests. This might be easier to set up compared to using multiple JavaScript processes and a load balancer.']}),"\n",(0,s.jsx)(t.h3,{id:"use-an-in-memory-storage-at-the-user-facing-level",children:"Use an in-memory storage at the user facing level"}),"\n",(0,s.jsxs)(t.p,{children:["Another way to serve more requests to your end users, is to use an ",(0,s.jsx)(t.a,{href:"/rx-storage-memory.html",children:"in-memory"})," storage that has the ",(0,s.jsx)(t.a,{href:"/rx-storage-performance.html",children:"best"})," read- and write performance. It outperformans persistent storages by a factor of 10x.\nSo instead of directly serving requests from the persistence layer, you add an in-memory layer on top of that. You could either do a ",(0,s.jsx)(t.a,{href:"/replication.html",children:"replication"})," from your memory database to the persistent one, or you use the ",(0,s.jsx)(t.a,{href:"/rx-storage-memory-mapped.html",children:"memory mapped"})," storage which has this build in."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { getRxStorageMemory } from 'rxdb/plugins/storage-memory';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport { getRxStorageFilesystemNode } from 'rxdb-premium/plugins/storage-filesystem-node';\nimport { getMemoryMappedRxStorage } from 'rxdb-premium/plugins/storage-memory-mapped';\nconst myRxDatabase = await createRxDatabase({\n    name: 'mydb',\n    storage: getMemoryMappedRxStorage({\n        storage: getRxStorageFilesystemNode({\n            basePath: path.join(__dirname, 'my-database-folder')\n        })\n    })\n});\nawait myDatabase.addCollections({/* ... */});\n\nconst myServer = await startRxServer({\n    database: myRxDatabase,\n    port: 443\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["But notice that you have to check your persistence requirements. When a write happens to the memory layer and the server crashes while it has not persisted, in rare cases the write operation might get lost. You can remove that risk by setting ",(0,s.jsx)(t.code,{children:"awaitWritePersistence: true"})," on the  ",(0,s.jsx)(t.a,{href:"/rx-storage-memory-mapped.html",children:"memory mapped storage"})," settings."]}),"\n",(0,s.jsx)(t.h2,{id:"horizontal-scaling",children:"Horizontal Scaling"}),"\n",(0,s.jsx)(t.p,{children:"To scale the RxDB Server above a single physical hardware unit, there are different solutions where the decision depends on the exact use case."}),"\n",(0,s.jsx)(t.h3,{id:"single-datastore-with-multiple-branches",children:"Single Datastore with multiple branches"}),"\n",(0,s.jsxs)(t.p,{children:['The most common way to use multiple servers with RxDB is to split up the server into a tree with a root "datastore" and multiple "branches". The datastore contains the persisted data and only servers as a replication endpoint for the branches. The branches themself will replicate data to and from the datastore and server requests to the end users.\nThis is mostly useful on read-heavy applications because reads will directly run on the branches without ever reaching the main datastore and you can always add more branches to ',(0,s.jsx)(t.strong,{children:"scale up"}),'. Even adding additional layers of "datastores" is possible so the tree can grow (or shrink) with the demand.']}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:"./files/server-scaling-tree.png",alt:"Server Scaling Tree",width:"320",class:"img-padding"})}),"\n",(0,s.jsx)(t.h3,{id:"moving-the-branches-to-the-edge",children:'Moving the branches to "the edge"'}),"\n",(0,s.jsxs)(t.p,{children:['Instead of running the "branches" of the tree on the same physical location as the datastore, it often makes sense to move the branches into a datacenter near the end users. Because the RxDB ',(0,s.jsx)(t.a,{href:"/replication.html",children:"replication algorithm"})," is made to work with slow and even partially offline users, using it for physically separated servers will work the same way. Latency is not that important because writes and reads will not decrease performance by blocking each other and the replication can run in the background without blocking other servers during transaction."]}),"\n",(0,s.jsx)(t.h3,{id:"replicate-databases-for-microservices",children:"Replicate Databases for Microservices"}),"\n",(0,s.jsxs)(t.p,{children:["If your application is build with a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Microservices",children:"microservice architecture"})," and your microservices are also build in Node.js, you can scale the database horizontally by moving the database into the microservices and use the ",(0,s.jsx)(t.a,{href:"/replication.html",children:"RxDB replication"}),' to do a realtime sync between the microservices and a main "datastore" server. The "datastore" server would then only handle the replication requests or do some additional things like logging or ',(0,s.jsx)(t.a,{href:"/backup.html",children:"backups"}),". The compute for reads and writes will then mainly be done on the microservices themself. This simplifies setting up more and more microservices without decreasing the performance of the whole system."]}),"\n",(0,s.jsx)(t.h3,{id:"use-a-self-scaling-rxstorage",children:"Use a self-scaling RxStorage"}),"\n",(0,s.jsxs)(t.p,{children:["An alternative to scaling up the RxDB servers themself, you can also switch to a ",(0,s.jsx)(t.a,{href:"/rx-storage.html",children:"RxStorage"})," which scales up internally. For example the ",(0,s.jsx)(t.a,{href:"/rx-storage-foundationdb.html",children:"FoundationDB storage"})," or ",(0,s.jsx)(t.a,{href:"/rx-storage-mongodb.html",children:"MongoDB"})," can work on top of a cluster that can increase load by adding more servers to itself. With that you can always add more Node.js RxDB processes that connect to the same cluster and server requests from it."]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>o});var a=r(6540);const s={},n=a.createContext(s);function i(e){const t=a.useContext(n);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);