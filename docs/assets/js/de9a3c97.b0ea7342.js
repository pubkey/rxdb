"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[4194],{1837:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"articles/reactjs-storage","title":"ReactJS Storage - From Basic LocalStorage to Advanced Offline Apps with RxDB","description":"Discover how to implement reactjs storage using localStorage for quick key-value data, then move on to more robust offline-first approaches with RxDB, IndexedDB, preact signals, encryption plugins, and more.","source":"@site/docs/articles/reactjs-storage.md","sourceDirName":"articles","slug":"/articles/reactjs-storage.html","permalink":"/articles/reactjs-storage.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"ReactJS Storage - From Basic LocalStorage to Advanced Offline Apps with RxDB","slug":"reactjs-storage.html","description":"Discover how to implement reactjs storage using localStorage for quick key-value data, then move on to more robust offline-first approaches with RxDB, IndexedDB, preact signals, encryption plugins, and more."},"sidebar":"tutorialSidebar","previous":{"title":"JSON-Based Databases - Why NoSQL and RxDB Simplify App Development","permalink":"/articles/json-based-database.html"},"next":{"title":"Contribute & Innovate with RxDB","permalink":"/contribution.html"}}');var s=r(4848),a=r(8453);const i={title:"ReactJS Storage - From Basic LocalStorage to Advanced Offline Apps with RxDB",slug:"reactjs-storage.html",description:"Discover how to implement reactjs storage using localStorage for quick key-value data, then move on to more robust offline-first approaches with RxDB, IndexedDB, preact signals, encryption plugins, and more."},o="ReactJS Storage \u2013 From Basic LocalStorage to Advanced Offline Apps with RxDB",l={},c=[{value:"Part 1: Storing Data in ReactJS with LocalStorage",id:"part-1-storing-data-in-reactjs-with-localstorage",level:2},{value:"Part 2: LocalStorage vs. IndexedDB",id:"part-2-localstorage-vs-indexeddb",level:2},{value:"Part 3: Moving Beyond Basic Storage: RxDB for ReactJS",id:"part-3-moving-beyond-basic-storage-rxdb-for-reactjs",level:2},{value:"RxDB Quick Example (Observables)",id:"rxdb-quick-example-observables",level:3},{value:"Part 4: Using Preact Signals Instead of Observables",id:"part-4-using-preact-signals-instead-of-observables",level:2},{value:"Part 5: Encrypting the Storage with RxDB",id:"part-5-encrypting-the-storage-with-rxdb",level:2},{value:"Offline Sync",id:"offline-sync",level:2},{value:"Overview: localStorage vs IndexedDB vs RxDB",id:"overview-localstorage-vs-indexeddb-vs-rxdb",level:2},{value:"Follow Up",id:"follow-up",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"reactjs-storage--from-basic-localstorage-to-advanced-offline-apps-with-rxdb",children:"ReactJS Storage \u2013 From Basic LocalStorage to Advanced Offline Apps with RxDB"})}),"\n",(0,s.jsxs)(n.p,{children:["Modern ",(0,s.jsx)(n.strong,{children:"ReactJS"})," applications often need to store data on the client side. Whether you\u2019re preserving simple user preferences or building offline-ready features, choosing the right ",(0,s.jsx)(n.strong,{children:"storage"})," mechanism can make or break your development experience. In this guide, we\u2019ll start with a basic ",(0,s.jsx)(n.strong,{children:"localStorage"})," approach for minimal data. Then, we\u2019ll explore more powerful, reactive solutions via ",(0,s.jsx)(n.a,{href:"/",children:"RxDB"}),"\u2014including offline functionality, indexing, ",(0,s.jsx)(n.code,{children:"preact signals"}),", and even encryption."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"part-1-storing-data-in-reactjs-with-localstorage",children:"Part 1: Storing Data in ReactJS with LocalStorage"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"localStorage"})," is a built-in browser API for storing key-value pairs in the user\u2019s browser. It\u2019s straightforward to set and get items\u2014ideal for trivial preferences or small usage data."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useState, useEffect } from 'react';\n\nfunction LocalStorageExample() {\n  const [username, setUsername] = useState(() => {\n    const saved = localStorage.getItem('username');\n    return saved ? JSON.parse(saved) : '';\n  });\n\n  useEffect(() => {\n    localStorage.setItem('username', JSON.stringify(username));\n  }, [username]);\n\n  return (\n    <div>\n      <h2>ReactJS LocalStorage Demo</h2>\n      <input\n        type=\"text\"\n        value={username}\n        onChange={e => setUsername(e.target.value)}\n        placeholder=\"Enter your username\"\n      />\n      <p>Stored: {username}</p>\n    </div>\n  );\n}\n\nexport default LocalStorageExample;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros"})," of localStorage in ReactJS:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Easy to implement quickly for minimal data"}),"\n",(0,s.jsx)(n.li,{children:"Built-in to the browser\u2014no extra libs"}),"\n",(0,s.jsx)(n.li,{children:"Persistent across sessions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Downsides of localStorage"}),"\nWhile localStorage is convenient for small amounts of data, it has certain limitations:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Synchronous: Reading or writing localStorage can block the main thread if data is large."}),"\n",(0,s.jsx)(n.li,{children:"No advanced queries: You only store stringified objects by a single key. Searching or filtering requires manually scanning everything."}),"\n",(0,s.jsx)(n.li,{children:"No concurrency or offline logic: If multiple tabs or users need to manipulate the same data, localStorage doesn\u2019t handle concurrency or sync with a server."}),"\n",(0,s.jsx)(n.li,{children:"No indexing: You can\u2019t perform partial lookups or advanced matching."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For \u201cremember user preference\u201d use cases, localStorage is excellent. But if your app grows complex\u2014needing structured data, large data sets, or offline-first features\u2014you might quickly surpass localStorage\u2019s utility."}),"\n",(0,s.jsx)(n.h2,{id:"part-2-localstorage-vs-indexeddb",children:"Part 2: LocalStorage vs. IndexedDB"}),"\n",(0,s.jsx)(n.p,{children:"While localStorage is simple, it\u2019s limited to string-based key-value lookups and can be synchronous for all reads/writes. For more robust ReactJS storage needs, browsers also provide IndexedDB\u2014a low-level, asynchronous API that can store larger amounts of JSON data with indexing."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"LocalStorage:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good for small amounts of data (like user settings or flags)"}),"\n",(0,s.jsx)(n.li,{children:"String-only storage"}),"\n",(0,s.jsx)(n.li,{children:"Single key-value access, no searching by subfields"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"IndexedDB:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Stores ",(0,s.jsx)(n.a,{href:"/articles/indexeddb-max-storage-limit.html",children:"large"})," JSON objects, able to index by multiple fields"]}),"\n",(0,s.jsx)(n.li,{children:"Asynchronous and usually more scalable"}),"\n",(0,s.jsxs)(n.li,{children:["More complicated to use directly (i.e., not as simple as .getItem())\n",(0,s.jsx)(n.a,{href:"/",children:"RxDB"}),", as you\u2019ll see, simplifies ",(0,s.jsx)(n.a,{href:"/rx-storage-indexeddb.html",children:"IndexedDB"})," usage in ReactJS by adding a more intuitive layer for queries, reactivity, and advanced capabilities like ",(0,s.jsx)(n.a,{href:"/encryption.html",children:"encryption"}),"."]}),"\n"]}),"\n",(0,s.jsx)("center",{children:(0,s.jsx)("a",{href:"https://rxdb.info/",children:(0,s.jsx)("img",{src:"/files/logo/rxdb_javascript_database.svg",alt:"RxDB",width:"250"})})}),"\n",(0,s.jsx)(n.h2,{id:"part-3-moving-beyond-basic-storage-rxdb-for-reactjs",children:"Part 3: Moving Beyond Basic Storage: RxDB for ReactJS"}),"\n",(0,s.jsx)(n.p,{children:"When data shapes get complex\u2014large sets of nested documents, or you want offline sync to a server\u2014RxDB can transform your approach to ReactJS storage. It stores documents in (usually) IndexedDB or alternative backends but offers a reactive, NoSQL-based interface."}),"\n",(0,s.jsx)(n.h3,{id:"rxdb-quick-example-observables",children:"RxDB Quick Example (Observables)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createRxDatabase } from 'rxdb';\nimport { getRxStorageLocalstorage } from 'rxdb/plugins/storage-localstorage';\n\n(async function setUpRxDB() {\n  const db = await createRxDatabase({\n    name: 'heroDB',\n    storage: getRxStorageLocalstorage(),\n    multiInstance: false\n  });\n\n  const heroSchema = {\n    title: 'hero schema',\n    version: 0,\n    type: 'object',\n    primaryKey: 'id',\n    properties: {\n      id: { type: 'string' },\n      name: { type: 'string' },\n      power: { type: 'string' }\n    },\n    required: ['id', 'name']\n  };\n\n  await db.addCollections({ heroes: { schema: heroSchema } });\n\n  // Insert a doc\n  await db.heroes.insert({ id: '1', name: 'AlphaHero', power: 'Lightning' });\n\n  // Query docs once\n  const allHeroes = await db.heroes.find().exec();\n  console.log('Heroes: ', allHeroes);\n})();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reactive Queries: In a React component, you can subscribe to a query via RxDB\u2019s $ property, letting your UI automatically update when data changes. React components can subscribe to updates from .find() queries, letting the UI automatically reflect changes\u2014perfect for dynamic offline-first apps."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import React, { useEffect, useState } from 'react';\n\nfunction HeroList({ collection }) {\n  const [heroes, setHeroes] = useState([]);\n\n  useEffect(() => {\n    const query = collection.find();\n    // query.$ is an RxJS Observable that emits whenever data changes\n    const sub = query.$.subscribe(newHeroes => {\n      setHeroes(newHeroes);\n    });\n\n    return () => sub.unsubscribe(); // clean up subscription\n  }, [collection]);\n\n  return (\n    <ul>\n      {heroes.map(hero => (\n        <li key={hero.id}>\n          {hero.name} - Power: {hero.power}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default HeroList;\n"})}),"\n",(0,s.jsx)("p",{align:"center",children:(0,s.jsx)("img",{src:"../files/animations/realtime.gif",alt:"realtime ui updates",width:"700"})}),"\n",(0,s.jsx)(n.p,{children:"By using these reactive queries, your React app knows exactly when data changes locally (or from another browser tab) or from remote sync, keeping your UI in sync effortlessly."}),"\n",(0,s.jsx)(n.h2,{id:"part-4-using-preact-signals-instead-of-observables",children:"Part 4: Using Preact Signals Instead of Observables"}),"\n",(0,s.jsx)(n.p,{children:"RxDB typically exposes reactivity via RxJS observables. However, some developers prefer newer reactivity approaches like Preact Signals. RxDB supports them via a special plugin or advanced usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createRxDatabase } from 'rxdb/plugins/core';\nimport { getRxStorageLocalstorage } from 'rxdb/plugins/storage-localstorage';\nimport { PreactSignalsRxReactivityFactory } from 'rxdb-premium/plugins/reactivity-preact-signals';\n\n(async function setUpRxDBWithSignals() {\n  const db = await createRxDatabase({\n    name: 'heroDB_signals',\n    storage: getRxStorageLocalstorage(),\n    reactivity: PreactSignalsRxReactivityFactory\n  });\n\n  // Create a signal-based query instead of using Observables:\n  const collection = db.heroes;\n  const heroesSignal = collection.find().$$; // signals version\n  // Now you can reference heroesSignal() in Preact or React with adapter usage\n})();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Preact Signals rely on \u201csignals\u201d instead of Observables\u2014some developers find them more straightforward to adopt, especially for fine-grained reactivity. In ReactJS, you might still prefer RxJS-based subscriptions unless you add bridging code for signals."}),"\n",(0,s.jsx)(n.h2,{id:"part-5-encrypting-the-storage-with-rxdb",children:"Part 5: Encrypting the Storage with RxDB"}),"\n",(0,s.jsxs)(n.p,{children:["For more advanced ReactJS storage needs\u2014especially when sensitive user data is involved\u2014you might want to encrypt stored documents at rest. RxDB provides a robust ",(0,s.jsx)(n.a,{href:"/encryption.html",children:"encryption plugin"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { createRxDatabase } from 'rxdb';\nimport { wrappedKeyEncryptionCryptoJsStorage } from 'rxdb/plugins/encryption-crypto-js';\nimport { getRxStorageLocalstorage } from 'rxdb/plugins/storage-localstorage';\n\n(async function secureSetup() {\n  const encryptedStorage = wrappedKeyEncryptionCryptoJsStorage({\n    storage: getRxStorageLocalstorage()\n  });\n\n  // Provide a password for encryption\n  const db = await createRxDatabase({\n    name: 'secureReactStorage',\n    storage: encryptedStorage,\n    password: 'MyStrongPassword123'\n  });\n\n  await db.addCollections({\n    secrets: {\n      schema: {\n        title: 'secret schema',\n        version: 0,\n        type: 'object',\n        primaryKey: 'id',\n        properties: {\n          id: { type: 'string' },\n          secretInfo: { type: 'string' }\n        },\n        required: ['id'],\n        encrypted: ['secretInfo'] // field to encrypt\n      }\n    }\n  });\n})();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All data in the marked ",(0,s.jsx)(n.code,{children:"encrypted"})," fields is automatically encrypted at rest. This is crucial if you store user credentials, private messages, or other personal data in your ReactJS application storage."]}),"\n",(0,s.jsx)(n.h2,{id:"offline-sync",children:"Offline Sync"}),"\n",(0,s.jsxs)(n.p,{children:["If you need multi-device or multi-user data synchronization, RxDB provides ",(0,s.jsx)(n.a,{href:"/replication.html",children:"replication plugins"})," for various endpoints (HTTP, ",(0,s.jsx)(n.a,{href:"/replication-graphql.html",children:"GraphQL"}),", ",(0,s.jsx)(n.a,{href:"/replication-couchdb.html",children:"CouchDB"}),", ",(0,s.jsx)(n.a,{href:"/replication-firestore.html",children:"Firestore"}),", etc.). Your ",(0,s.jsx)(n.a,{href:"/offline-first.html",children:"local offline"})," changes can then merge automatically with a remote database whenever internet connectivity is restored."]}),"\n",(0,s.jsxs)(n.h2,{id:"overview-localstorage-vs-indexeddb-vs-rxdb",children:["Overview: ",(0,s.jsx)(n.a,{href:"/articles/localstorage-indexeddb-cookies-opfs-sqlite-wasm.html",children:"localStorage vs IndexedDB vs RxDB"})]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Characteristic"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"localStorage"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"IndexedDB"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"RxDB"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Data Model"})}),(0,s.jsx)(n.td,{children:"Key-value store (only strings)"}),(0,s.jsx)(n.td,{children:"Low-level, JSON-like storage engine with object stores and indexes"}),(0,s.jsx)(n.td,{children:"NoSQL JSON documents with optional JSON-Schema"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Query Capabilities"})}),(0,s.jsx)(n.td,{children:"Basic get/set by key; manual parse for more complex searches"}),(0,s.jsx)(n.td,{children:"Index-based queries, but API is fairly verbose; lacks a high-level query language"}),(0,s.jsx)(n.td,{children:"JSON-based queries, optional indexes, real-time reactivity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Observability"})}),(0,s.jsx)(n.td,{children:"None. Must re-fetch data yourself."}),(0,s.jsx)(n.td,{children:"None natively. Must implement eventing or manual re-check."}),(0,s.jsx)(n.td,{children:"Built-in reactivity. UI auto-updates via Observables or Preact signals"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Large Data Usage"})}),(0,s.jsx)(n.td,{children:"Not recommended for large data (blocking, synchronous calls)"}),(0,s.jsx)(n.td,{children:"Better for large amounts of data, asynchronous reads/writes"}),(0,s.jsx)(n.td,{children:"Scales for medium to large data. Uses IndexedDB or other storages under the hood"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Concurrency"})}),(0,s.jsx)(n.td,{children:"Minimal. Overwrites if multiple tabs write simultaneously"}),(0,s.jsx)(n.td,{children:"Multiple tabs can open the same DB, but must handle concurrency logic carefully"}),(0,s.jsx)(n.td,{children:"Multi-instance concurrency with built-in conflict resolution plugins if needed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Offline Sync"})}),(0,s.jsx)(n.td,{children:"None. Purely local."}),(0,s.jsx)(n.td,{children:"None out of the box. Must be implemented manually"}),(0,s.jsx)(n.td,{children:"Built-in replication to remote endpoints (HTTP, GraphQL, CouchDB, etc.) for offline-first usage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Encryption"})}),(0,s.jsx)(n.td,{children:"Not supported natively"}),(0,s.jsx)(n.td,{children:"Not supported natively; must encrypt data manually before storing"}),(0,s.jsx)(n.td,{children:"Encryption plugins available. Supports field-level encryption at rest"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Usage"})}),(0,s.jsx)(n.td,{children:"Great for small flags or settings"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"follow-up",children:"Follow Up"}),"\n",(0,s.jsxs)(n.p,{children:["If you\u2019re looking to dive deeper into ",(0,s.jsx)(n.strong,{children:"ReactJS storage"})," topics and take full advantage of RxDB\u2019s offline-first, real-time capabilities, here are some recommended resources:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/overview.html",children:"RxDB Official Documentation"})}),(0,s.jsx)(n.br,{}),"\n","Explore detailed guides on setting up storage adapters, defining ",(0,s.jsx)(n.a,{href:"/rx-schema.html",children:"JSON schemas"}),", ",(0,s.jsx)(n.a,{href:"/transactions-conflicts-revisions.html",children:"handling conflicts"}),", and enabling ",(0,s.jsx)(n.a,{href:"/replication.html",children:"offline synchronization"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://rxdb.info/quickstart.html",children:"RxDB Quickstart"})}),(0,s.jsx)(n.br,{}),"\n","Get a step-by-step tutorial to create your first RxDB-based application in minutes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/pubkey/rxdb",children:"RxDB GitHub Repository"})}),(0,s.jsx)(n.br,{}),"\n","See the source code, open issues, and browse community-driven examples that integrate ReactJS, Preact Signals, and advanced features like encryption."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://rxdb.info/encryption.html",children:"RxDB Encryption Plugins"})}),(0,s.jsx)(n.br,{}),"\n","Learn how to encrypt fields in your collections, protecting user data and meeting compliance requirements."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/preactjs/signals#react",children:"Preact Signals React Integration (Example)"})}),(0,s.jsx)(n.br,{}),"\n","If you want to combine React with signals-based reactivity, check out example code and bridging approaches."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API",children:"MDN: Using the Web Storage API"})}),(0,s.jsx)(n.br,{}),"\n","Refresh on localStorage basics, including best practices for small key-value data in traditional React apps."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["With these follow-up steps, you can refine your ",(0,s.jsx)(n.strong,{children:"reactjs storage"})," strategy to meet your app\u2019s unique needs, whether it\u2019s simple user preferences or robust offline data syncing."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);