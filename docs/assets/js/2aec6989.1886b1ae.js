"use strict";(globalThis.webpackChunkrxdb=globalThis.webpackChunkrxdb||[]).push([[7498],{8453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>n});var i=t(6540);const a={},o=i.createContext(a);function s(e){const r=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function n(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:r},e.children)}},9985:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>n,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"articles/indexeddb-max-storage-limit","title":"IndexedDB Max Storage Size Limit - Detailed Best Practices","description":"Learn how browsers enforce IndexedDB storage size limits, how to test and handle quota exceeded errors, and best practices for storing large amounts of data offline.","source":"@site/docs/articles/indexeddb-max-storage-limit.md","sourceDirName":"articles","slug":"/articles/indexeddb-max-storage-limit.html","permalink":"/articles/indexeddb-max-storage-limit.html","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"IndexedDB Max Storage Size Limit - Detailed Best Practices","slug":"indexeddb-max-storage-limit.html","description":"Learn how browsers enforce IndexedDB storage size limits, how to test and handle quota exceeded errors, and best practices for storing large amounts of data offline."},"sidebar":"tutorialSidebar","previous":{"title":"Zero Latency Local First Apps with RxDB \u2013 Sync, Encryption and Compression","permalink":"/articles/zero-latency-local-first.html"},"next":{"title":"JSON-Based Databases - Why NoSQL and RxDB Simplify App Development","permalink":"/articles/json-based-database.html"}}');var a=t(4848),o=t(8453);const s={title:"IndexedDB Max Storage Size Limit - Detailed Best Practices",slug:"indexeddb-max-storage-limit.html",description:"Learn how browsers enforce IndexedDB storage size limits, how to test and handle quota exceeded errors, and best practices for storing large amounts of data offline."},n="IndexedDB Max Storage Size Limit",d={},l=[{value:"Why IndexedDB Has a Storage Limit",id:"why-indexeddb-has-a-storage-limit",level:2},{value:"Browser-Specific IndexedDB Limits",id:"browser-specific-indexeddb-limits",level:2},{value:"Checking Your Current IndexedDB Usage",id:"checking-your-current-indexeddb-usage",level:2},{value:"Testing Your App\u2019s IndexedDB Quotas",id:"testing-your-apps-indexeddb-quotas",level:2},{value:"Handling Errors When Limits Are Reached",id:"handling-errors-when-limits-are-reached",level:2},{value:"Tricks to Exceed the Storage Size Limitation",id:"tricks-to-exceed-the-storage-size-limitation",level:2},{value:"IndexedDB Max Size of a Single Object",id:"indexeddb-max-size-of-a-single-object",level:2},{value:"Is There a Time Limit for Data Stored in IndexedDB?",id:"is-there-a-time-limit-for-data-stored-in-indexeddb",level:2},{value:"Follow Up",id:"follow-up",level:2}];function c(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"indexeddb-max-storage-size-limit",children:"IndexedDB Max Storage Size Limit"})}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB is widely known as the primary browser-based storage API for large client-side data, particularly valuable for modern offline-first applications. These apps aim to keep everything functional and interactive even without an internet connection, which naturally demands substantial local storage. However, IndexedDB has various size limits depending on the browser, disk space, and user settings. Being aware of these constraints is crucial so you can avoid quota errors and deliver a seamless user experience without unexpected data loss."}),"\n",(0,a.jsx)(r.p,{children:"Offline-first apps have grown in popularity because they provide immediate feedback, zero-latency interactions, and resilience in poor network conditions. Storing big data sets, or even entire data models, in IndexedDB has become far more common than in the era of small localStorage or cookie usage. But all this local data is subject to quotas, and that\u2019s exactly what this guide will help you understand and manage."}),"\n",(0,a.jsx)(r.h2,{id:"why-indexeddb-has-a-storage-limit",children:"Why IndexedDB Has a Storage Limit"}),"\n",(0,a.jsxs)(r.p,{children:["Browsers need a way to curb runaway disk usage and safeguard user resources. This is accomplished through ",(0,a.jsx)(r.strong,{children:"quota management"})," policies, which can vary among Chrome, Firefox, Safari, Edge, and others. Some browsers use a percentage of your total disk space, while others rely on a fixed maximum or dynamic approach per origin. These policies are designed to prevent malicious or poorly optimized web pages from consuming an unreasonable amount of user storage."]}),"\n",(0,a.jsx)(r.p,{children:"Chrome (and Chromium-based browsers) typically allow you to use a percentage of the user\u2019s free disk space, whereas Firefox historically prompts users to allow more than 5 MB in mobile or 50 MB in desktop. Safari often sets tighter maximum caps, especially on iOS devices. Edge aligns closely with Chrome\u2019s rules but can also include enterprise or corporate policy overrides. Understanding these default or dynamic limits prepares you to plan your app\u2019s storage needs appropriately."}),"\n",(0,a.jsx)(r.h2,{id:"browser-specific-indexeddb-limits",children:"Browser-Specific IndexedDB Limits"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB size quotas differ significantly across browsers and platforms. While there isn\u2019t a universal rule, the following table summarizes approximate limits and any notes or caveats you should be aware of:"}),"\n",(0,a.jsxs)(r.table,{children:[(0,a.jsx)(r.thead,{children:(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.th,{children:"Browser"}),(0,a.jsx)(r.th,{children:"Approx. Limit"}),(0,a.jsx)(r.th,{children:"Notes"})]})}),(0,a.jsxs)(r.tbody,{children:[(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"Chrome/Chromium"}),(0,a.jsx)(r.td,{children:"Up to ~80% of free disk, per origin cap"}),(0,a.jsx)(r.td,{children:"Often cited as 60 GB on a 100 GB drive. Shared pool approach. Quota usage can prompt partial or extended user approvals."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"Firefox"}),(0,a.jsx)(r.td,{children:"~2 GB (desktop) or ~5 MB initial for mobile"}),(0,a.jsx)(r.td,{children:"Older versions asked permission at 50 MB for desktop. Ephemeral/incognito sessions may require repeated user prompts."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"Safari (iOS)"}),(0,a.jsx)(r.td,{children:"~1 GB per origin (variable)"}),(0,a.jsx)(r.td,{children:"Historically stricter. iOS devices limit quotas further. Behavior can differ between iOS Safari versions or iPadOS."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"Edge"}),(0,a.jsx)(r.td,{children:"Similar to Chrome\u2019s 80% of free space"}),(0,a.jsx)(r.td,{children:"Can be influenced by Windows enterprise policies. Generally aligned with Chromium approach."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"iOS Safari"}),(0,a.jsx)(r.td,{children:"Typically 1 GB, can be less on older iOS"}),(0,a.jsx)(r.td,{children:"Early iOS versions were known for more aggressive quotas and data eviction on low space."})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:"Android Chrome"}),(0,a.jsx)(r.td,{children:"Similar to desktop Chrome"}),(0,a.jsx)(r.td,{children:"May exhibit warnings in especially low-storage devices. The same 80% free space logic generally applies."})]})]})]}),"\n",(0,a.jsxs)(r.p,{children:["Historically, these limits have evolved. For instance, older Firefox versions included ",(0,a.jsx)(r.code,{children:"dom.indexedDB.warningQuota"}),", showing a 50 MB prompt on desktop or a 5 MB prompt on mobile\u2014many developers wrote about these notifications on Stack Overflow. Since around 2015, Firefox has changed its quota approach significantly. Likewise, Safari used to limit data more aggressively on older iOS versions. Some older tutorials suggest comparing IndexedDB to localStorage, but modern browsers allow far larger and more flexible storage with IndexedDB than the old localStorage or cookie-based setups."]}),"\n",(0,a.jsx)(r.hr,{}),"\n",(0,a.jsx)(r.h2,{id:"checking-your-current-indexeddb-usage",children:"Checking Your Current IndexedDB Usage"}),"\n",(0,a.jsxs)(r.p,{children:["To assess where your app stands relative to these storage limits, you can use the ",(0,a.jsx)(r.strong,{children:"Storage Estimation API"}),". The snippet below shows how to estimate both your used storage and the total space allocated to your origin:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",children:"const quota = await navigator.storage.estimate();\nconst totalSpace = quota.quota;\nconst usedSpace = quota.usage;\nconsole.log('Approx total allocated space:', totalSpace);\nconsole.log('Approx used space:', usedSpace);\n"})}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/StorageManager/persist#browser_compatibility",children:"Some browsers (all modern ones)"})," also provide a ",(0,a.jsx)(r.code,{children:"navigator.storage.persist()"})," method to request persistent storage, preventing the browser from automatically clearing your data if the user\u2019s device runs low on space. Note that users might deny such requests, or the request might fail silently on stricter environments. Always handle these outcomes gracefully and design your app to degrade if persistent storage is unavailable."]}),"\n",(0,a.jsx)(r.h2,{id:"testing-your-apps-indexeddb-quotas",children:"Testing Your App\u2019s IndexedDB Quotas"}),"\n",(0,a.jsx)(r.p,{children:"The best way to handle real-world usage is to test for low storage conditions and large data sets in different environments. You can fill up the space manually by writing repetitive test data or running scripts that bulk-insert documents until an error occurs."}),"\n",(0,a.jsxs)(r.p,{children:["Real-time usage monitors or dashboards can keep track of your ",(0,a.jsx)(r.code,{children:"navigator.storage.estimate()"})," results, letting you see how close you are to the max limit in production. Developer tools in Chrome or Firefox can simulate limited storage situations, which is crucial for QA:"]}),"\n",(0,a.jsx)("center",{children:(0,a.jsx)("iframe",{width:"315",height:"360",src:"https://www.youtube.com/embed/Nf37yutU8y4",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0})}),"\n",(0,a.jsx)(r.p,{children:"This short tutorial shows how you can artificially reduce available storage in Google Chrome\u2019s dev tools to see how your app behaves when nearing or exceeding the quota."}),"\n",(0,a.jsx)(r.h2,{id:"handling-errors-when-limits-are-reached",children:"Handling Errors When Limits Are Reached"}),"\n",(0,a.jsxs)(r.p,{children:["When the user\u2019s device is too full or your app exceeds the allotted quota, most browsers will throw a ",(0,a.jsx)(r.strong,{children:"QuotaExceededError"})," (or similarly named exception) when trying to store additional data. Often, the request to IndexedDB simply fails with an error event. Handling this gracefully is essential to avoid crashes or data corruption."]}),"\n",(0,a.jsxs)(r.p,{children:["A typical approach is to wrap your write operations in try/catch blocks or in ",(0,a.jsx)(r.code,{children:"onsuccess"})," / ",(0,a.jsx)(r.code,{children:"onerror"})," event callbacks. If you detect a quota error, you can prompt the user to clear out old items or reduce the scope of offline data. Some apps implement a fallback system that removes less critical documents to free space and then retries the write."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-js",children:"try {\n  const tx = db.transaction('largeStore', 'readwrite');\n  const store = tx.objectStore('largeStore');\n  await store.add(hugeData, someKey);\n  await tx.done;\n} catch (error) {\n  if (error.name === 'QuotaExceededError') {\n    console.warn('IndexedDB quota exceeded. Cleanup or prompt user to free space.');\n    // Optionally remove older data or show a UI hint:\n    // removeOldDocuments();\n    // displayStorageFullDialog();\n  } else {\n    // handle other errors\n    console.error('IndexedDB write error:', error);\n  }\n}\n"})}),"\n",(0,a.jsx)(r.h2,{id:"tricks-to-exceed-the-storage-size-limitation",children:"Tricks to Exceed the Storage Size Limitation"}),"\n",(0,a.jsx)(r.p,{children:"Even if you plan well, your app might need more storage than a single origin typically allows. There are a few advanced tactics you can use:"}),"\n",(0,a.jsxs)(r.p,{children:["If you store binary data such as images or videos, consider compressing them via the Compression Streams API. For textual or ",(0,a.jsx)(r.a,{href:"/articles/json-based-database.html",children:"JSON data"}),", a library like ",(0,a.jsx)(r.a,{href:"/",children:"RxDB"})," supports built-in ",(0,a.jsx)(r.a,{href:"/key-compression.html",children:"key-compression"})," to shorten field names or entire documents. This can be extremely helpful when storing large sets of objects:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-ts",children:'// Example: How key-compression can transform your documents internally\nconst uncompressed = {\n  "firstName": "Corrine",\n  "lastName": "Ziemann",\n  "shoppingCartItems": [\n    {\n      "productNumber": 29857,\n      "amount": 1\n    },\n    {\n      "productNumber": 53409,\n      "amount": 6\n    }\n  ]\n};\nconst compressed = {\n  "|e": "Corrine",\n  "|g": "Ziemann",\n  "|i": [\n    {\n      "|h": 29857,\n      "|b": 1\n    },\n    {\n      "|h": 53409,\n      "|b": 6\n    }\n  ]\n};\n'})}),"\n",(0,a.jsxs)(r.p,{children:["Sharding data across multiple subdomains or iframes is another trick, though it complicates communication. When you need truly massive offline data, you might store part of the data under ",(0,a.jsx)(r.code,{children:"sub1.yoursite.com"})," and another chunk under ",(0,a.jsx)(r.code,{children:"sub2.yoursite.com"}),", using ",(0,a.jsx)(r.code,{children:"postMessage()"})," to coordinate. This can circumvent single-origin limitations, but it introduces extra complexity. Another effective method is to let data expire automatically\u2014perhaps older records are removed if they haven\u2019t been accessed for a certain period."]}),"\n",(0,a.jsx)("center",{children:(0,a.jsx)("a",{href:"https://rxdb.info/",children:(0,a.jsx)("img",{src:"../files/logo/rxdb_javascript_database.svg",alt:"JavaScript Database",width:"220"})})}),"\n",(0,a.jsx)(r.h2,{id:"indexeddb-max-size-of-a-single-object",children:"IndexedDB Max Size of a Single Object"}),"\n",(0,a.jsxs)(r.p,{children:["There is no explicit cap on how large an individual object or record in IndexedDB can be, other than the overall disk quota. If you attempt to store one extremely large object, you will eventually hit browser memory constraints or the global storage quota. In practice, you\u2019ll encounter out-of-memory issues in JavaScript before IndexedDB itself refuses a single large write. A helpful test can be seen in ",(0,a.jsx)(r.a,{href:"https://jsfiddle.net/sdrqf8om/2/",children:"this JSFiddle experiment"})," where you see browsers can crash when creating massive in-memory objects."]}),"\n",(0,a.jsx)(r.h2,{id:"is-there-a-time-limit-for-data-stored-in-indexeddb",children:"Is There a Time Limit for Data Stored in IndexedDB?"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB data can remain indefinitely as long as the user does not clear the browser\u2019s data or the origin does not run afoul of automated eviction policies (e.g., Safari or Android might remove large caches for sites unused over a long period when space is needed). Typically, there is no \u201ctime limit,\u201d but ephemeral modes or incognito sessions have their own rules. If you rely on permanent offline data, request persistent storage and handle the possibility that the user or the OS could still remove your data under extreme conditions. Especially Safari is known to be very fast in deleting local data."}),"\n",(0,a.jsx)("p",{align:"center",children:(0,a.jsx)("img",{src:"/files/safari-database.png",alt:"safari database",width:"200"})}),"\n",(0,a.jsx)(r.h2,{id:"follow-up",children:"Follow Up"}),"\n",(0,a.jsxs)(r.p,{children:["Learn more by checking the ",(0,a.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"IndexedDB official docs"}),", which detail store design, error handling, and quota usage. If you need a straightforward way to manage large offline data with compression and conflict resolution, explore the ",(0,a.jsx)(r.a,{href:"/quickstart.html",children:"RxDB Quickstart"}),". You can also join the community on ",(0,a.jsx)(r.a,{href:"/code/",children:"GitHub"})," to share tips on overcoming the ",(0,a.jsx)(r.strong,{children:"IndexedDB max storage size limit"})," in production environments."]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);