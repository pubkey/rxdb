"use strict";(self.webpackChunkrxdb=self.webpackChunkrxdb||[]).push([[7018],{9003:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=t(5893),n=t(1151);const s={title:"\ud83d\udcc8 RxStorage Performance",slug:"rx-storage-performance.html"},a=void 0,i={id:"rx-storage-performance",title:"\ud83d\udcc8 RxStorage Performance",description:"RxStorage Performance comparison",source:"@site/docs/rx-storage-performance.md",sourceDirName:".",slug:"/rx-storage-performance.html",permalink:"/rx-storage-performance.html",draft:!1,unlisted:!1,editUrl:"https://github.com/pubkey/rxdb/tree/master/docs-src/docs/rx-storage-performance.md",tags:[],version:"current",frontMatter:{title:"\ud83d\udcc8 RxStorage Performance",slug:"rx-storage-performance.html"},sidebar:"tutorialSidebar",previous:{title:"\u2699\ufe0f Rxstorage Layer",permalink:"/rx-storage.html"},next:{title:"Dexie.js RxStorage",permalink:"/rx-storage-dexie.html"}},c={},l=[{value:"RxStorage Performance comparison",id:"rxstorage-performance-comparison",level:2}];function m(e){const r={a:"a",h2:"h2",p:"p",strong:"strong",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.h2,{id:"rxstorage-performance-comparison",children:"RxStorage Performance comparison"}),"\n",(0,o.jsxs)(r.p,{children:["A big difference in the RxStorage implementations is the performance. In difference to a server side database, RxDB is bound to the limits of the JavaScript runtime. For example in the browser it is only possible to store data in a ",(0,o.jsx)(r.a,{href:"/slow-indexeddb.html",children:"slow IndexedDB"})," instead of a filesystem."]}),"\n",(0,o.jsxs)(r.p,{children:["Semi-persistend storages like ",(0,o.jsx)(r.a,{href:"/rx-storage-memory-synced.html",children:"Memory-Synced"})," and ",(0,o.jsx)(r.a,{href:"/rx-storage-lokijs.html",children:"LokiJS"})," store all data in memory and only saves to disc occasionally (or on exit). Therefore it has a very fast read/write performance, but loading all data into memory on the first page load can take longer for big amounts of documents. Also these storages can only be used when all data fits into the memory at least once."]}),"\n",(0,o.jsxs)(r.p,{children:["The \ud83d\udc51 Premium ",(0,o.jsx)(r.a,{href:"/rx-storage-sharding.html",children:"sharding RxStorage"})," is only useful when big amounts of documents have to be stored or queries. Small single-document reads and writes are likely slower with the sharding plugin in use."]}),"\n",(0,o.jsxs)(r.p,{children:["Many storages run lazy, so it makes no sense to compare the time which is required to create a database with collections. Instead we measure the ",(0,o.jsx)(r.strong,{children:"time-to-first-insert"})," which is the whole timespan from database creation until the first single document write is done."]}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsx)("img",{src:"./files/rx-storage-performance-browser.png",alt:"RxStorage performance - browser",width:"700"})}),"\n",(0,o.jsx)("p",{align:"center",children:(0,o.jsx)("img",{src:"./files/rx-storage-performance-node.png",alt:"RxStorage performance - Node.js",width:"700"})})]})}function d(e={}){const{wrapper:r}={...(0,n.a)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},1151:(e,r,t)=>{t.d(r,{Z:()=>i,a:()=>a});var o=t(7294);const n={},s=o.createContext(n);function a(e){const r=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(s.Provider,{value:r},e.children)}}}]);