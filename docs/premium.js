/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/es/change-event-buffer.js":
/*!****************************************!*\
  !*** ./dist/es/change-event-buffer.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChangeEventBuffer\": () => (/* binding */ ChangeEventBuffer),\n/* harmony export */   \"createChangeEventBuffer\": () => (/* binding */ createChangeEventBuffer)\n/* harmony export */ });\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\n\nvar ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.filter)(cE => !cE.isLocal)).subscribe(cE => this._handleChangeEvent(cE)));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0);\n    // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n    var docEventMap = {};\n    changeEvents.forEach(changeEvent => {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  };\n  _proto.destroy = function destroy() {\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nfunction createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n//# sourceMappingURL=change-event-buffer.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/change-event-buffer.js?");

/***/ }),

/***/ "./dist/es/doc-cache.js":
/*!******************************!*\
  !*** ./dist/es/doc-cache.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DocumentCache\": () => (/* binding */ DocumentCache)\n/* harmony export */ });\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-revision.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/* harmony import */ var _rx_change_event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-change-event */ \"./dist/es/rx-change-event.js\");\n\n\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nvar DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);\n        if (cacheItem.documentByRevisionHeight.size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(changeEvent => {\n      var docId = changeEvent.documentId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        var documentData = (0,_rx_change_event__WEBPACK_IMPORTED_MODULE_0__.getDocumentDataOfRxChangeEvent)(changeEvent);\n        cacheItem.latestDoc = documentData;\n      }\n    });\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   */\n  var _proto = DocumentCache.prototype;\n  _proto.getCachedRxDocument = function getCachedRxDocument(docData) {\n    var docId = docData[this.primaryPath];\n    var revisionHeight = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.getHeightOfRevision)(docData._rev);\n    var cacheItem = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getFromMapOrFill)(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));\n    var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);\n    var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n    if (!cachedRxDocument) {\n      docData = _overwritable__WEBPACK_IMPORTED_MODULE_3__.overwritable.deepFreezeWhenDevMode(docData);\n      cachedRxDocument = this.documentCreator(docData);\n      cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n      if (this.registry) {\n        this.registry.register(cachedRxDocument, {\n          docId,\n          revisionHeight\n        });\n      }\n    }\n    return cachedRxDocument;\n  }\n\n  /**\n   * Throws if not exists\n   */;\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    var cacheItem = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getFromMapOrThrow)(this.cacheItemByDocId, docId);\n    return cacheItem.latestDoc;\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem.latestDoc;\n    }\n  };\n  return DocumentCache;\n}();\nfunction getNewCacheItem(docData) {\n  return {\n    documentByRevisionHeight: new Map(),\n    latestDoc: docData\n  };\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nfunction createWeakRefWithFallback(obj) {\n  if (HAS_WEAK_REF) {\n    return new WeakRef(obj);\n  } else {\n    return {\n      deref() {\n        return obj;\n      }\n    };\n  }\n}\n//# sourceMappingURL=doc-cache.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/doc-cache.js?");

/***/ }),

/***/ "./dist/es/event-reduce.js":
/*!*********************************!*\
  !*** ./dist/es/event-reduce.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RXQUERY_QUERY_PARAMS_CACHE\": () => (/* binding */ RXQUERY_QUERY_PARAMS_CACHE),\n/* harmony export */   \"calculateNewResults\": () => (/* binding */ calculateNewResults),\n/* harmony export */   \"getQueryParams\": () => (/* binding */ getQueryParams),\n/* harmony export */   \"getSortFieldsOfQuery\": () => (/* binding */ getSortFieldsOfQuery)\n/* harmony export */ });\n/* harmony import */ var event_reduce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! event-reduce-js */ \"./node_modules/event-reduce-js/dist/es/index.js\");\n/* harmony import */ var _rx_change_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-change-event */ \"./dist/es/rx-change-event.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _rx_query_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-query-helper */ \"./dist/es/rx-query-helper.js\");\n\n\n\n\nfunction getSortFieldsOfQuery(primaryKey, query) {\n  if (!query.sort || query.sort.length === 0) {\n    return [primaryKey];\n  } else {\n    return query.sort.map(part => Object.keys(part)[0]);\n  }\n}\nvar RXQUERY_QUERY_PARAMS_CACHE = new WeakMap();\nfunction getQueryParams(rxQuery) {\n  if (!RXQUERY_QUERY_PARAMS_CACHE.has(rxQuery)) {\n    var collection = rxQuery.collection;\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var normalizedMangoQuery = (0,_rx_query_helper__WEBPACK_IMPORTED_MODULE_0__.normalizeMangoQuery)(collection.storageInstance.schema, (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.clone)(rxQuery.mangoQuery));\n    var primaryKey = collection.schema.primaryPath;\n\n    /**\n     * Create a custom sort comparator\n     * that uses the hooks to ensure\n     * we send for example compressed documents to be sorted by compressed queries.\n     */\n    var sortComparator = collection.database.storage.statics.getSortComparator(collection.schema.jsonSchema, preparedQuery);\n    var useSortComparator = (docA, docB) => {\n      var sortComparatorData = {\n        docA,\n        docB,\n        rxQuery\n      };\n      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n    };\n\n    /**\n     * Create a custom query matcher\n     * that uses the hooks to ensure\n     * we send for example compressed documents to match compressed queries.\n     */\n    var queryMatcher = collection.database.storage.statics.getQueryMatcher(collection.schema.jsonSchema, preparedQuery);\n    var useQueryMatcher = doc => {\n      var queryMatcherData = {\n        doc,\n        rxQuery\n      };\n      return queryMatcher(queryMatcherData.doc);\n    };\n    var ret = {\n      primaryKey: rxQuery.collection.schema.primaryPath,\n      skip: normalizedMangoQuery.skip,\n      limit: normalizedMangoQuery.limit,\n      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),\n      sortComparator: useSortComparator,\n      queryMatcher: useQueryMatcher\n    };\n    RXQUERY_QUERY_PARAMS_CACHE.set(rxQuery, ret);\n    return ret;\n  } else {\n    return RXQUERY_QUERY_PARAMS_CACHE.get(rxQuery);\n  }\n}\nfunction calculateNewResults(rxQuery, rxChangeEvents) {\n  if (!rxQuery.collection.database.eventReduce) {\n    return {\n      runFullQueryAgain: true\n    };\n  }\n  var queryParams = getQueryParams(rxQuery);\n  var previousResults = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.ensureNotFalsy)(rxQuery._result).docsData.slice(0);\n  var previousResultsMap = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.ensureNotFalsy)(rxQuery._result).docsDataMap;\n  var changed = false;\n  var eventReduceEvents = rxChangeEvents.map(cE => (0,_rx_change_event__WEBPACK_IMPORTED_MODULE_3__.rxChangeEventToEventReduceChangeEvent)(cE)).filter(_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.arrayFilterNotEmpty);\n  var foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n    var stateResolveFunctionInput = {\n      queryParams,\n      changeEvent: eventReduceEvent,\n      previousResults,\n      keyDocumentMap: previousResultsMap\n    };\n    var actionName = (0,event_reduce_js__WEBPACK_IMPORTED_MODULE_5__.calculateActionName)(stateResolveFunctionInput);\n    if (actionName === 'runFullQueryAgain') {\n      return true;\n    } else if (actionName !== 'doNothing') {\n      changed = true;\n      (0,event_reduce_js__WEBPACK_IMPORTED_MODULE_5__.runAction)(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);\n      return false;\n    }\n  });\n  if (foundNonOptimizeable) {\n    return {\n      runFullQueryAgain: true\n    };\n  } else {\n    return {\n      runFullQueryAgain: false,\n      changed,\n      newResults: previousResults\n    };\n  }\n}\n//# sourceMappingURL=event-reduce.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/event-reduce.js?");

/***/ }),

/***/ "./dist/es/hooks.js":
/*!**************************!*\
  !*** ./dist/es/hooks.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HOOKS\": () => (/* binding */ HOOKS),\n/* harmony export */   \"_clearHook\": () => (/* binding */ _clearHook),\n/* harmony export */   \"runAsyncPluginHooks\": () => (/* binding */ runAsyncPluginHooks),\n/* harmony export */   \"runPluginHooks\": () => (/* binding */ runPluginHooks)\n/* harmony export */ });\n/**\n * hook-functions that can be extended by the plugin\n */\nvar HOOKS = {\n  /**\n   * Runs before a plugin is added.\n   * Use this to block the usage of non-compatible plugins.\n   */\n  preAddRxPlugin: [],\n  /**\n   * functions that run before the database is created\n   */\n  preCreateRxDatabase: [],\n  /**\n   * runs after the database is created and prepared\n   * but before the instance is returned to the user\n   * @async\n   */\n  createRxDatabase: [],\n  preCreateRxCollection: [],\n  createRxCollection: [],\n  /**\n  * runs at the end of the destroy-process of a collection\n  * @async\n  */\n  postDestroyRxCollection: [],\n  /**\n   * Runs after a collection is removed.\n   * @async\n   */\n  postRemoveRxCollection: [],\n  /**\n    * functions that get the json-schema as input\n    * to do additionally checks/manipulation\n    */\n  preCreateRxSchema: [],\n  /**\n   * functions that run after the RxSchema is created\n   * gets RxSchema as attribute\n   */\n  createRxSchema: [],\n  preCreateRxQuery: [],\n  /**\n   * Runs before a query is send to the\n   * prepareQuery function of the storage engine.\n   */\n  prePrepareQuery: [],\n  createRxDocument: [],\n  /**\n   * runs after a RxDocument is created,\n   * cannot be async\n   */\n  postCreateRxDocument: [],\n  /**\n   * Runs before a RxStorageInstance is created\n   * gets the params of createStorageInstance()\n   * as attribute so you can manipulate them.\n   * Notice that you have to clone stuff before mutating the inputs.\n   */\n  preCreateRxStorageInstance: [],\n  /**\n   * runs on the document-data before the document is migrated\n   * {\n   *   doc: Object, // originam doc-data\n   *   migrated: // migrated doc-data after run through migration-strategies\n   * }\n   */\n  preMigrateDocument: [],\n  /**\n   * runs after the migration of a document has been done\n   */\n  postMigrateDocument: [],\n  /**\n   * runs at the beginning of the destroy-process of a database\n   */\n  preDestroyRxDatabase: [],\n  /**\n   * runs after a database has been removed\n   * @async\n   */\n  postRemoveRxDatabase: []\n};\nfunction runPluginHooks(hookKey, obj) {\n  if (HOOKS[hookKey]) {\n    HOOKS[hookKey].forEach(fun => fun(obj));\n  }\n}\n\n/**\n * TODO\n * we should not run the hooks in parallel\n * this makes stuff unpredictable.\n */\nfunction runAsyncPluginHooks(hookKey, obj) {\n  return Promise.all(HOOKS[hookKey].map(fun => fun(obj)));\n}\n\n/**\n * used in tests to remove hooks\n */\nfunction _clearHook(type, fun) {\n  HOOKS[type] = HOOKS[type].filter(h => h !== fun);\n}\n//# sourceMappingURL=hooks.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/hooks.js?");

/***/ }),

/***/ "./dist/es/incremental-write.js":
/*!**************************************!*\
  !*** ./dist/es/incremental-write.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IncrementalWriteQueue\": () => (/* binding */ IncrementalWriteQueue),\n/* harmony export */   \"findNewestOfDocumentStates\": () => (/* binding */ findNewestOfDocumentStates),\n/* harmony export */   \"modifierFromPublicToInternal\": () => (/* binding */ modifierFromPublicToInternal)\n/* harmony export */ });\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-revision.js\");\n\n\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nvar IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrFill)(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.ensureNotFalsy)(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.clone)(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: {},\n      success: {}\n    };\n\n    // process success\n    await Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {\n      this.postWrite(result);\n      var items = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrThrow)(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {\n      var items = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrThrow)(itemsById, docId);\n      var isConflict = (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.isBulkWriteConflictError)(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.getFromMapOrFill)(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.ensureNotFalsy)(isConflict.documentInDb);\n          (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.ensureNotFalsy)(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.rxStorageWriteErrorToRxError)(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nfunction modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.stripMetaDataFromDocument)(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nfunction findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.parseRevision)(newest._rev).height;\n  docs.forEach(doc => {\n    var height = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.parseRevision)(doc._rev).height;\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n//# sourceMappingURL=incremental-write.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/incremental-write.js?");

/***/ }),

/***/ "./dist/es/overwritable.js":
/*!*********************************!*\
  !*** ./dist/es/overwritable.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"overwritable\": () => (/* binding */ overwritable)\n/* harmony export */ });\n/**\n * functions that can or should be overwritten by plugins\n * IMPORTANT: Do not import any big stuff from RxDB here!\n * An 'overwritable' can be used inside WebWorkers for RxStorage only,\n * and we do not want to have the full RxDB lib bundled in them.\n */\n\nvar overwritable = {\n  /**\n   * if this method is overwritten with one\n   * that returns true, we do additional checks\n   * which help the developer but have bad performance\n   */\n  isDevMode() {\n    return false;\n  },\n  /**\n   * Deep freezes and object when in dev-mode.\n   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.\n   * Also, we can ensure the readonly state via typescript\n   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n   */\n  deepFreezeWhenDevMode(obj) {\n    return obj;\n  },\n  /**\n   * overwritten to map error-codes to text-messages\n   */\n  tunnelErrorMessage(message) {\n    return \"RxDB Error-Code \" + message + \".\\n        Error messages are not included in RxDB core to reduce build size.\\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=\" + message + \"\\n        \";\n  }\n};\n//# sourceMappingURL=overwritable.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/overwritable.js?");

/***/ }),

/***/ "./dist/es/plugin.js":
/*!***************************!*\
  !*** ./dist/es/plugin.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addRxPlugin\": () => (/* binding */ addRxPlugin)\n/* harmony export */ });\n/* harmony import */ var _rx_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema */ \"./dist/es/rx-schema.js\");\n/* harmony import */ var _rx_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-document */ \"./dist/es/rx-document.js\");\n/* harmony import */ var _rx_query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-query */ \"./dist/es/rx-query.js\");\n/* harmony import */ var _rx_collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-collection */ \"./dist/es/rx-collection.js\");\n/* harmony import */ var _rx_database__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-database */ \"./dist/es/rx-database.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/**\n * this handles how plugins are added to rxdb\n * basically it changes the internal prototypes\n * by passing them to the plugins-functions\n */\n\n\n\n\n\n\n\n\n\n/**\n * prototypes that can be manipulated with a plugin\n */\nvar PROTOTYPES = {\n  RxSchema: _rx_schema__WEBPACK_IMPORTED_MODULE_0__.RxSchema.prototype,\n  RxDocument: _rx_document__WEBPACK_IMPORTED_MODULE_1__.basePrototype,\n  RxQuery: _rx_query__WEBPACK_IMPORTED_MODULE_2__.RxQueryBase.prototype,\n  RxCollection: _rx_collection__WEBPACK_IMPORTED_MODULE_3__.RxCollectionBase.prototype,\n  RxDatabase: _rx_database__WEBPACK_IMPORTED_MODULE_4__.RxDatabaseBase.prototype\n};\nvar ADDED_PLUGINS = new Set();\nvar ADDED_PLUGIN_NAMES = new Set();\n\n/**\n * Add a plugin to the RxDB library.\n * Plugins are added globally and cannot be removed.\n */\nfunction addRxPlugin(plugin) {\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_5__.runPluginHooks)('preAddRxPlugin', {\n    plugin,\n    plugins: ADDED_PLUGINS\n  });\n\n  // do nothing if added before\n  if (ADDED_PLUGINS.has(plugin)) {\n    return;\n  } else {\n    // ensure no other plugin with the same name was already added\n    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_6__.newRxError)('PL3', {\n        name: plugin.name,\n        plugin\n      });\n    }\n    ADDED_PLUGINS.add(plugin);\n    ADDED_PLUGIN_NAMES.add(plugin.name);\n  }\n\n  /**\n   * To identify broken configurations,\n   * we only allow RxDB plugins to be passed into addRxPlugin().\n   */\n  if (!plugin.rxdb) {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_6__.newRxTypeError)('PL1', {\n      plugin\n    });\n  }\n  if (plugin.init) {\n    plugin.init();\n  }\n\n  // prototype-overwrites\n  if (plugin.prototypes) {\n    Object.entries(plugin.prototypes).forEach(([name, fun]) => {\n      return fun(PROTOTYPES[name]);\n    });\n  }\n  // overwritable-overwrites\n  if (plugin.overwritable) {\n    Object.assign(_overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable, plugin.overwritable);\n  }\n  // extend-hooks\n  if (plugin.hooks) {\n    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {\n      if (hooksObj.after) {\n        _hooks__WEBPACK_IMPORTED_MODULE_5__.HOOKS[name].push(hooksObj.after);\n      }\n      if (hooksObj.before) {\n        _hooks__WEBPACK_IMPORTED_MODULE_5__.HOOKS[name].unshift(hooksObj.before);\n      }\n    });\n  }\n}\n//# sourceMappingURL=plugin.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugin.js?");

/***/ }),

/***/ "./dist/es/plugins/local-documents/index.js":
/*!**************************************************!*\
  !*** ./dist/es/plugins/local-documents/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LOCAL_DOC_STATE_BY_PARENT\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.LOCAL_DOC_STATE_BY_PARENT),\n/* harmony export */   \"LOCAL_DOC_STATE_BY_PARENT_RESOLVED\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.LOCAL_DOC_STATE_BY_PARENT_RESOLVED),\n/* harmony export */   \"RX_LOCAL_DOCUMENT_SCHEMA\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.RX_LOCAL_DOCUMENT_SCHEMA),\n/* harmony export */   \"RxDBLocalDocumentsPlugin\": () => (/* binding */ RxDBLocalDocumentsPlugin),\n/* harmony export */   \"closeStateByParent\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent),\n/* harmony export */   \"createLocalDocStateByParent\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent),\n/* harmony export */   \"createLocalDocumentStorageInstance\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.createLocalDocumentStorageInstance),\n/* harmony export */   \"createRxLocalDocument\": () => (/* reexport safe */ _rx_local_document__WEBPACK_IMPORTED_MODULE_2__.createRxLocalDocument),\n/* harmony export */   \"getCollectionLocalInstanceName\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.getCollectionLocalInstanceName),\n/* harmony export */   \"getLocal\": () => (/* reexport safe */ _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal),\n/* harmony export */   \"getLocal$\": () => (/* reexport safe */ _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal$),\n/* harmony export */   \"getLocalDocStateByParent\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent),\n/* harmony export */   \"insertLocal\": () => (/* reexport safe */ _local_documents__WEBPACK_IMPORTED_MODULE_1__.insertLocal),\n/* harmony export */   \"removeLocalDocumentsStorageInstance\": () => (/* reexport safe */ _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance),\n/* harmony export */   \"upsertLocal\": () => (/* reexport safe */ _local_documents__WEBPACK_IMPORTED_MODULE_1__.upsertLocal)\n/* harmony export */ });\n/* harmony import */ var _local_documents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./local-documents */ \"./dist/es/plugins/local-documents/local-documents.js\");\n/* harmony import */ var _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./local-documents-helper */ \"./dist/es/plugins/local-documents/local-documents-helper.js\");\n/* harmony import */ var _rx_local_document__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-local-document */ \"./dist/es/plugins/local-documents/rx-local-document.js\");\n\n\n\n\n\nvar RxDBLocalDocumentsPlugin = {\n  name: 'local-documents',\n  rxdb: true,\n  prototypes: {\n    RxCollection: proto => {\n      proto.insertLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.insertLocal;\n      proto.upsertLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.upsertLocal;\n      proto.getLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal;\n      proto.getLocal$ = _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal$;\n    },\n    RxDatabase: proto => {\n      proto.insertLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.insertLocal;\n      proto.upsertLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.upsertLocal;\n      proto.getLocal = _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal;\n      proto.getLocal$ = _local_documents__WEBPACK_IMPORTED_MODULE_1__.getLocal$;\n    }\n  },\n  hooks: {\n    createRxDatabase: {\n      before: args => {\n        if (args.creator.localDocuments) {\n          /**\n           * We do not have to await\n           * the creation to speed up initial page load.\n           */\n          /* await */\n          (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent)(args.database);\n        }\n      }\n    },\n    createRxCollection: {\n      before: args => {\n        if (args.creator.localDocuments) {\n          /**\n           * We do not have to await\n           * the creation to speed up initial page load.\n           */\n          /* await */\n          (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.createLocalDocStateByParent)(args.collection);\n        }\n      }\n    },\n    preDestroyRxDatabase: {\n      after: db => {\n        return (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent)(db);\n      }\n    },\n    postDestroyRxCollection: {\n      after: collection => (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.closeStateByParent)(collection)\n    },\n    postRemoveRxDatabase: {\n      after: args => {\n        return (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance)(args.storage, args.databaseName, '');\n      }\n    },\n    postRemoveRxCollection: {\n      after: args => {\n        return (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.removeLocalDocumentsStorageInstance)(args.storage, args.databaseName, args.collectionName);\n      }\n    }\n  },\n  overwritable: {}\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/local-documents/index.js?");

/***/ }),

/***/ "./dist/es/plugins/local-documents/local-documents-helper.js":
/*!*******************************************************************!*\
  !*** ./dist/es/plugins/local-documents/local-documents-helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LOCAL_DOC_STATE_BY_PARENT\": () => (/* binding */ LOCAL_DOC_STATE_BY_PARENT),\n/* harmony export */   \"LOCAL_DOC_STATE_BY_PARENT_RESOLVED\": () => (/* binding */ LOCAL_DOC_STATE_BY_PARENT_RESOLVED),\n/* harmony export */   \"RX_LOCAL_DOCUMENT_SCHEMA\": () => (/* binding */ RX_LOCAL_DOCUMENT_SCHEMA),\n/* harmony export */   \"closeStateByParent\": () => (/* binding */ closeStateByParent),\n/* harmony export */   \"createLocalDocStateByParent\": () => (/* binding */ createLocalDocStateByParent),\n/* harmony export */   \"createLocalDocumentStorageInstance\": () => (/* binding */ createLocalDocumentStorageInstance),\n/* harmony export */   \"getCollectionLocalInstanceName\": () => (/* binding */ getCollectionLocalInstanceName),\n/* harmony export */   \"getLocalDocStateByParent\": () => (/* binding */ getLocalDocStateByParent),\n/* harmony export */   \"removeLocalDocumentsStorageInstance\": () => (/* binding */ removeLocalDocumentsStorageInstance)\n/* harmony export */ });\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _doc_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../doc-cache */ \"./dist/es/doc-cache.js\");\n/* harmony import */ var _incremental_write__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../incremental-write */ \"./dist/es/incremental-write.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _rx_local_document__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-local-document */ \"./dist/es/plugins/local-documents/rx-local-document.js\");\n\n\n\n\n\n\n\n\nvar LOCAL_DOC_STATE_BY_PARENT = new WeakMap();\nvar LOCAL_DOC_STATE_BY_PARENT_RESOLVED = new WeakMap();\nfunction createLocalDocStateByParent(parent) {\n  var database = parent.database ? parent.database : parent;\n  var collectionName = parent.database ? parent.name : '';\n  var statePromise = (async () => {\n    var storageInstance = await createLocalDocumentStorageInstance(database.token, database.storage, database.name, collectionName, database.instanceCreationOptions, database.multiInstance);\n    storageInstance = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_0__.getWrappedStorageInstance)(database, storageInstance, RX_LOCAL_DOCUMENT_SCHEMA);\n    var docCache = new _doc_cache__WEBPACK_IMPORTED_MODULE_1__.DocumentCache('id', parent.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.filter)(cE => cE.isLocal)), docData => (0,_rx_local_document__WEBPACK_IMPORTED_MODULE_3__.createRxLocalDocument)(docData, parent));\n    var incrementalWriteQueue = new _incremental_write__WEBPACK_IMPORTED_MODULE_4__.IncrementalWriteQueue(storageInstance, 'id', () => {}, () => {});\n\n    /**\n     * Emit the changestream into the collections change stream\n     */\n    var databaseStorageToken = await database.storageToken;\n    var subLocalDocs = storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        internal: false,\n        collectionName: parent.database ? parent.name : undefined,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events.map(ev => (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_0__.storageChangeEventToRxChangeEvent)(true, ev, parent.database ? parent : undefined)),\n        databaseToken: database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      database.$emit(changeEventBulk);\n    });\n    parent._subs.push(subLocalDocs);\n    var state = {\n      database,\n      parent,\n      storageInstance,\n      docCache,\n      incrementalWriteQueue\n    };\n    LOCAL_DOC_STATE_BY_PARENT_RESOLVED.set(parent, state);\n    return state;\n  })();\n  LOCAL_DOC_STATE_BY_PARENT.set(parent, statePromise);\n}\nfunction getLocalDocStateByParent(parent) {\n  var statePromise = LOCAL_DOC_STATE_BY_PARENT.get(parent);\n  if (!statePromise) {\n    var database = parent.database ? parent.database : parent;\n    var collectionName = parent.database ? parent.name : '';\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_5__.newRxError)('LD8', {\n      database: database.name,\n      collection: collectionName\n    });\n  }\n  return statePromise;\n}\nfunction createLocalDocumentStorageInstance(databaseInstanceToken, storage, databaseName, collectionName, instanceCreationOptions, multiInstance) {\n  return storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName: databaseName,\n    /**\n     * Use a different collection name for the local documents instance\n     * so that the local docs can be kept while deleting the normal instance\n     * after migration.\n     */\n    collectionName: getCollectionLocalInstanceName(collectionName),\n    schema: RX_LOCAL_DOCUMENT_SCHEMA,\n    options: instanceCreationOptions,\n    multiInstance\n  });\n}\nfunction closeStateByParent(parent) {\n  var statePromise = LOCAL_DOC_STATE_BY_PARENT.get(parent);\n  if (statePromise) {\n    LOCAL_DOC_STATE_BY_PARENT.delete(parent);\n    return statePromise.then(state => state.storageInstance.close());\n  }\n}\nasync function removeLocalDocumentsStorageInstance(storage, databaseName, collectionName) {\n  var databaseInstanceToken = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.randomCouchString)(10);\n  var storageInstance = await createLocalDocumentStorageInstance(databaseInstanceToken, storage, databaseName, collectionName, {}, false);\n  await storageInstance.remove();\n}\nfunction getCollectionLocalInstanceName(collectionName) {\n  return 'plugin-local-documents-' + collectionName;\n}\nvar RX_LOCAL_DOCUMENT_SCHEMA = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_7__.fillWithDefaultSettings)({\n  title: 'RxLocalDocument',\n  version: 0,\n  primaryKey: 'id',\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 128\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  required: ['id', 'data']\n});\n//# sourceMappingURL=local-documents-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/local-documents/local-documents-helper.js?");

/***/ }),

/***/ "./dist/es/plugins/local-documents/local-documents.js":
/*!************************************************************!*\
  !*** ./dist/es/plugins/local-documents/local-documents.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getLocal\": () => (/* binding */ getLocal),\n/* harmony export */   \"getLocal$\": () => (/* binding */ getLocal$),\n/* harmony export */   \"insertLocal\": () => (/* binding */ insertLocal),\n/* harmony export */   \"upsertLocal\": () => (/* binding */ upsertLocal)\n/* harmony export */ });\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/startWith.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _local_documents_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./local-documents-helper */ \"./dist/es/plugins/local-documents/local-documents-helper.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n\n\n\n\n\n/**\n * save the local-document-data\n * throws if already exists\n */\nasync function insertLocal(id, data) {\n  var state = await (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent)(this);\n\n  // create new one\n  var docData = {\n    id: id,\n    data,\n    _deleted: false,\n    _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.getDefaultRxDocumentMeta)(),\n    _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.getDefaultRevision)(),\n    _attachments: {}\n  };\n  return (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_2__.writeSingle)(state.storageInstance, {\n    document: docData\n  }, 'local-document-insert').then(newDocData => state.docCache.getCachedRxDocument(newDocData));\n}\n\n/**\n * save the local-document-data\n * overwrites existing if exists\n */\nfunction upsertLocal(id, data) {\n  return this.getLocal(id).then(existing => {\n    if (!existing) {\n      // create new one\n      var docPromise = this.insertLocal(id, data);\n      return docPromise;\n    } else {\n      // update existing\n      return existing.incrementalModify(() => {\n        return data;\n      });\n    }\n  });\n}\nasync function getLocal(id) {\n  var state = await (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_0__.getLocalDocStateByParent)(this);\n  var docCache = state.docCache;\n\n  // check in doc-cache\n  var found = docCache.getLatestDocumentDataIfExists(id);\n  if (found) {\n    return Promise.resolve(docCache.getCachedRxDocument(found));\n  }\n\n  // if not found, check in storage instance\n  return (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_2__.getSingleDocument)(state.storageInstance, id).then(docData => {\n    if (!docData) {\n      return null;\n    }\n    return state.docCache.getCachedRxDocument(docData);\n  });\n}\nfunction getLocal$(id) {\n  return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(async cE => {\n    if (cE) {\n      return {\n        changeEvent: cE\n      };\n    } else {\n      var doc = await this.getLocal(id);\n      return {\n        doc: doc\n      };\n    }\n  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(async changeEventOrDoc => {\n    if (changeEventOrDoc.changeEvent) {\n      var cE = changeEventOrDoc.changeEvent;\n      if (!cE.isLocal || cE.documentId !== id) {\n        return {\n          use: false\n        };\n      } else {\n        var doc = await this.getLocal(id);\n        return {\n          use: true,\n          doc: doc\n        };\n      }\n    } else {\n      return {\n        use: true,\n        doc: changeEventOrDoc.doc\n      };\n    }\n  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.filter)(filterFlagged => filterFlagged.use), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.map)(filterFlagged => {\n    return filterFlagged.doc;\n  }));\n}\n//# sourceMappingURL=local-documents.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/local-documents/local-documents.js?");

/***/ }),

/***/ "./dist/es/plugins/local-documents/rx-local-document.js":
/*!**************************************************************!*\
  !*** ./dist/es/plugins/local-documents/rx-local-document.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createRxLocalDocument\": () => (/* binding */ createRxLocalDocument)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/startWith.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../overwritable */ \"./dist/es/overwritable.js\");\n/* harmony import */ var _rx_change_event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rx-change-event */ \"./dist/es/rx-change-event.js\");\n/* harmony import */ var _rx_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-document */ \"./dist/es/rx-document.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-object-dot-prop.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _local_documents_helper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./local-documents-helper */ \"./dist/es/plugins/local-documents/local-documents-helper.js\");\n\n\n\n\n\n\n\n\n\nvar RxDocumentParent = (0,_rx_document__WEBPACK_IMPORTED_MODULE_1__.createRxDocumentConstructor)();\nvar RxLocalDocumentClass = /*#__PURE__*/function (_RxDocumentParent) {\n  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxLocalDocumentClass, _RxDocumentParent);\n  function RxLocalDocumentClass(id, jsonData, parent) {\n    var _this2;\n    _this2 = _RxDocumentParent.call(this, null, jsonData) || this;\n    _this2.id = id;\n    _this2.parent = parent;\n    return _this2;\n  }\n  return RxLocalDocumentClass;\n}(RxDocumentParent);\nvar RxLocalDocumentPrototype = {\n  get isLocal() {\n    return true;\n  },\n  //\n  // overwrites\n  //\n  get allAttachments$() {\n    // this is overwritten here because we cannot re-set getters on the prototype\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD1', {\n      document: this\n    });\n  },\n  get primaryPath() {\n    return 'id';\n  },\n  get primary() {\n    return this.id;\n  },\n  get $() {\n    var _this = this;\n    return _this.parent.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(changeEvent => changeEvent.isLocal), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(changeEvent => changeEvent.documentId === this.primary), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(changeEvent => (0,_rx_change_event__WEBPACK_IMPORTED_MODULE_5__.getDocumentDataOfRxChangeEvent)(changeEvent)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.startWith)(this._data), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.shareReplay)(_plugins_utils__WEBPACK_IMPORTED_MODULE_9__.RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  getLatest() {\n    var state = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_9__.getFromMapOrThrow)(_local_documents_helper__WEBPACK_IMPORTED_MODULE_10__.LOCAL_DOC_STATE_BY_PARENT_RESOLVED, this.parent);\n    var latestDocData = state.docCache.getLatestDocumentData(this.primary);\n    return state.docCache.getCachedRxDocument(latestDocData);\n  },\n  get(objPath) {\n    objPath = 'data.' + objPath;\n    if (!this._data) {\n      return undefined;\n    }\n    if (typeof objPath !== 'string') {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxTypeError)('LD2', {\n        objPath\n      });\n    }\n    var valueObj = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_11__.getProperty)(this._data, objPath);\n    valueObj = _overwritable__WEBPACK_IMPORTED_MODULE_12__.overwritable.deepFreezeWhenDevMode(valueObj);\n    return valueObj;\n  },\n  get$(objPath) {\n    objPath = 'data.' + objPath;\n    if (_overwritable__WEBPACK_IMPORTED_MODULE_12__.overwritable.isDevMode()) {\n      if (objPath.includes('.item.')) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD3', {\n          objPath\n        });\n      }\n      if (objPath === this.primaryPath) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD4');\n      }\n    }\n    return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(data => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_11__.getProperty)(data, objPath)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.distinctUntilChanged)());\n  },\n  async incrementalModify(mutationFunction) {\n    var state = await (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_10__.getLocalDocStateByParent)(this.parent);\n    return state.incrementalWriteQueue.addWrite(this._data, async docData => {\n      docData.data = await mutationFunction(docData.data, this);\n      return docData;\n    }).then(result => state.docCache.getCachedRxDocument(result));\n  },\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  async _saveData(newData) {\n    var state = await (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_10__.getLocalDocStateByParent)(this.parent);\n    var oldData = this._data;\n    newData.id = this.id;\n    return state.storageInstance.bulkWrite([{\n      previous: oldData,\n      document: newData\n    }], 'local-document-save-data').then(res => {\n      var docResult = res.success[newData.id];\n      if (!docResult) {\n        throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.getFromObjectOrThrow)(res.error, newData.id);\n      }\n      newData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.flatClone)(newData);\n      newData._rev = docResult._rev;\n    });\n  },\n  async remove() {\n    var state = await (0,_local_documents_helper__WEBPACK_IMPORTED_MODULE_10__.getLocalDocStateByParent)(this.parent);\n    var writeData = {\n      id: this._data.id,\n      data: {},\n      _deleted: true,\n      _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_14__.getDefaultRxDocumentMeta)(),\n      _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_14__.getDefaultRevision)(),\n      _attachments: {}\n    };\n    return (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_15__.writeSingle)(state.storageInstance, {\n      previous: this._data,\n      document: writeData\n    }, 'local-document-remove').then(writeResult => state.docCache.getCachedRxDocument(writeResult));\n  }\n};\nvar INIT_DONE = false;\nvar _init = () => {\n  if (INIT_DONE) return;else INIT_DONE = true;\n\n  // add functions of RxDocument\n  var docBaseProto = _rx_document__WEBPACK_IMPORTED_MODULE_1__.basePrototype;\n  var props = Object.getOwnPropertyNames(docBaseProto);\n  props.forEach(key => {\n    var exists = Object.getOwnPropertyDescriptor(RxLocalDocumentPrototype, key);\n    if (exists) return;\n    var desc = Object.getOwnPropertyDescriptor(docBaseProto, key);\n    Object.defineProperty(RxLocalDocumentPrototype, key, desc);\n  });\n\n  /**\n   * Overwrite things that do not work on local documents\n   * with a throwing function.\n   */\n  var getThrowingFun = k => () => {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('LD6', {\n      functionName: k\n    });\n  };\n  ['populate', 'update', 'putAttachment', 'getAttachment', 'allAttachments'].forEach(k => RxLocalDocumentPrototype[k] = getThrowingFun(k));\n};\nfunction createRxLocalDocument(data, parent) {\n  _init();\n  var newDoc = new RxLocalDocumentClass(data.id, data, parent);\n  Object.setPrototypeOf(newDoc, RxLocalDocumentPrototype);\n  newDoc.prototype = RxLocalDocumentPrototype;\n  return newDoc;\n}\n//# sourceMappingURL=rx-local-document.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/local-documents/rx-local-document.js?");

/***/ }),

/***/ "./dist/es/plugins/storage-dexie/dexie-helper.js":
/*!*******************************************************!*\
  !*** ./dist/es/plugins/storage-dexie/dexie-helper.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEXIE_CHANGES_TABLE_NAME\": () => (/* binding */ DEXIE_CHANGES_TABLE_NAME),\n/* harmony export */   \"DEXIE_DELETED_DOCS_TABLE_NAME\": () => (/* binding */ DEXIE_DELETED_DOCS_TABLE_NAME),\n/* harmony export */   \"DEXIE_DOCS_TABLE_NAME\": () => (/* binding */ DEXIE_DOCS_TABLE_NAME),\n/* harmony export */   \"DEXIE_PIPE_SUBSTITUTE\": () => (/* binding */ DEXIE_PIPE_SUBSTITUTE),\n/* harmony export */   \"RX_STORAGE_NAME_DEXIE\": () => (/* binding */ RX_STORAGE_NAME_DEXIE),\n/* harmony export */   \"RxStorageDexieStatics\": () => (/* binding */ RxStorageDexieStatics),\n/* harmony export */   \"closeDexieDb\": () => (/* binding */ closeDexieDb),\n/* harmony export */   \"dexieReplaceIfStartsWithPipe\": () => (/* binding */ dexieReplaceIfStartsWithPipe),\n/* harmony export */   \"dexieReplaceIfStartsWithPipeRevert\": () => (/* binding */ dexieReplaceIfStartsWithPipeRevert),\n/* harmony export */   \"ensureNoBooleanIndex\": () => (/* binding */ ensureNoBooleanIndex),\n/* harmony export */   \"fromDexieToStorage\": () => (/* binding */ fromDexieToStorage),\n/* harmony export */   \"fromStorageToDexie\": () => (/* binding */ fromStorageToDexie),\n/* harmony export */   \"getDexieDbWithTables\": () => (/* binding */ getDexieDbWithTables),\n/* harmony export */   \"getDexieStoreSchema\": () => (/* binding */ getDexieStoreSchema),\n/* harmony export */   \"getDocsInDb\": () => (/* binding */ getDocsInDb)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"./node_modules/dexie/dist/modern/dexie.mjs\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_storage_statics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-storage-statics */ \"./dist/es/rx-storage-statics.js\");\n\n\n\n\n\nvar DEXIE_DOCS_TABLE_NAME = 'docs';\nvar DEXIE_DELETED_DOCS_TABLE_NAME = 'deleted-docs';\nvar DEXIE_CHANGES_TABLE_NAME = 'changes';\nvar RX_STORAGE_NAME_DEXIE = 'dexie';\nvar RxStorageDexieStatics = _rx_storage_statics__WEBPACK_IMPORTED_MODULE_1__.RxStorageDefaultStatics;\nvar DEXIE_STATE_DB_BY_NAME = new Map();\nvar REF_COUNT_PER_DEXIE_DB = new Map();\nfunction getDexieDbWithTables(databaseName, collectionName, settings, schema) {\n  var primaryPath = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);\n  var dexieDbName = 'rxdb-dexie-' + databaseName + '--' + schema.version + '--' + collectionName;\n  var state = DEXIE_STATE_DB_BY_NAME.get(dexieDbName);\n  if (!state) {\n    state = (async () => {\n      /**\n       * IndexedDB was not designed for dynamically adding tables on the fly,\n       * so we create one dexie database per RxDB storage instance.\n       * @link https://github.com/dexie/Dexie.js/issues/684#issuecomment-373224696\n       */\n      var useSettings = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.flatClone)(settings);\n      useSettings.autoOpen = false;\n      var dexieDb = new dexie__WEBPACK_IMPORTED_MODULE_0__.Dexie(dexieDbName, useSettings);\n      var dexieStoresSettings = {\n        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),\n        [DEXIE_CHANGES_TABLE_NAME]: '++sequence, id',\n        /**\n         * Instead of adding {deleted: false} to every query we run over the document store,\n         * we move deleted documents into a separate store where they can only be queried\n         * by primary key.\n         * This increases performance because it is way easier for the query planner to select\n         * a good index and we also do not have to add the _deleted field to every index.\n         *\n         * We also need the [_meta.lwt+' + primaryPath + '] index for getChangedDocumentsSince()\n         */\n        [DEXIE_DELETED_DOCS_TABLE_NAME]: primaryPath + ',_meta.lwt,[_meta.lwt+' + primaryPath + ']'\n      };\n      dexieDb.version(1).stores(dexieStoresSettings);\n      await dexieDb.open();\n      return {\n        dexieDb,\n        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],\n        dexieDeletedTable: dexieDb[DEXIE_DELETED_DOCS_TABLE_NAME]\n      };\n    })();\n    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);\n    REF_COUNT_PER_DEXIE_DB.set(state, 0);\n  }\n  return state;\n}\nasync function closeDexieDb(statePromise) {\n  var state = await statePromise;\n  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);\n  var newCount = prevCount - 1;\n  if (newCount === 0) {\n    state.dexieDb.close();\n    REF_COUNT_PER_DEXIE_DB.delete(statePromise);\n  } else {\n    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);\n  }\n}\nfunction ensureNoBooleanIndex(schema) {\n  if (!schema.indexes) {\n    return;\n  }\n  var checkedFields = new Set();\n  schema.indexes.forEach(index => {\n    var fields = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.toArray)(index);\n    fields.forEach(field => {\n      if (checkedFields.has(field)) {\n        return;\n      }\n      checkedFields.add(field);\n      var schemaObj = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__.getSchemaByObjectPath)(schema, field);\n      if (schemaObj.type === 'boolean') {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_5__.newRxError)('DXE1', {\n          schema,\n          index,\n          field\n        });\n      }\n    });\n  });\n}\n\n/**\n * It is not possible to set non-javascript-variable-syntax\n * keys as IndexedDB indexes. So we have to substitute the pipe-char\n * which comes from the key-compression plugin.\n */\nvar DEXIE_PIPE_SUBSTITUTE = '__';\nfunction dexieReplaceIfStartsWithPipe(str) {\n  var split = str.split('.');\n  if (split.length > 1) {\n    return split.map(part => dexieReplaceIfStartsWithPipe(part)).join('.');\n  }\n  if (str.startsWith('|')) {\n    var withoutFirst = str.substring(1);\n    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;\n  } else {\n    return str;\n  }\n}\nfunction dexieReplaceIfStartsWithPipeRevert(str) {\n  var split = str.split('.');\n  if (split.length > 1) {\n    return split.map(part => dexieReplaceIfStartsWithPipeRevert(part)).join('.');\n  }\n  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {\n    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);\n    return '|' + withoutFirst;\n  } else {\n    return str;\n  }\n}\n\n/**\n * @recursive\n */\nfunction fromStorageToDexie(documentData) {\n  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {\n    return documentData;\n  } else if (Array.isArray(documentData)) {\n    return documentData.map(row => fromStorageToDexie(row));\n  } else if (typeof documentData === 'object') {\n    var ret = {};\n    Object.entries(documentData).forEach(([key, value]) => {\n      if (typeof value === 'object') {\n        value = fromStorageToDexie(value);\n      }\n      ret[dexieReplaceIfStartsWithPipe(key)] = value;\n    });\n    return ret;\n  }\n}\nfunction fromDexieToStorage(documentData) {\n  if (!documentData || typeof documentData === 'string' || typeof documentData === 'number' || typeof documentData === 'boolean') {\n    return documentData;\n  } else if (Array.isArray(documentData)) {\n    return documentData.map(row => fromDexieToStorage(row));\n  } else if (typeof documentData === 'object') {\n    var ret = {};\n    Object.entries(documentData).forEach(([key, value]) => {\n      if (typeof value === 'object' || Array.isArray(documentData)) {\n        value = fromDexieToStorage(value);\n      }\n      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;\n    });\n    return ret;\n  }\n}\n\n/**\n * Creates a string that can be used to create the dexie store.\n * @link https://dexie.org/docs/API-Reference#quick-reference\n */\nfunction getDexieStoreSchema(rxJsonSchema) {\n  var parts = [];\n\n  /**\n   * First part must be the primary key\n   * @link https://github.com/dexie/Dexie.js/issues/1307#issuecomment-846590912\n   */\n  var primaryKey = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);\n  parts.push([primaryKey]);\n\n  // add other indexes\n  if (rxJsonSchema.indexes) {\n    rxJsonSchema.indexes.forEach(index => {\n      var arIndex = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.toArray)(index);\n      parts.push(arIndex);\n    });\n  }\n\n  // we also need the _meta.lwt+primaryKey index for the getChangedDocumentsSince() method.\n  parts.push(['_meta.lwt', primaryKey]);\n\n  /**\n   * It is not possible to set non-javascript-variable-syntax\n   * keys as IndexedDB indexes. So we have to substitute the pipe-char\n   * which comes from the key-compression plugin.\n   */\n  parts = parts.map(part => {\n    return part.map(str => dexieReplaceIfStartsWithPipe(str));\n  });\n  return parts.map(part => {\n    if (part.length === 1) {\n      return part[0];\n    } else {\n      return '[' + part.join('+') + ']';\n    }\n  }).join(', ');\n}\n\n/**\n * Returns all documents in the database.\n * Non-deleted plus deleted ones.\n */\nasync function getDocsInDb(internals, docIds) {\n  var state = await internals;\n  var [nonDeletedDocsInDb, deletedDocsInDb] = await Promise.all([state.dexieTable.bulkGet(docIds), state.dexieDeletedTable.bulkGet(docIds)]);\n  var docsInDb = deletedDocsInDb.slice(0);\n  nonDeletedDocsInDb.forEach((doc, idx) => {\n    if (doc) {\n      docsInDb[idx] = doc;\n    }\n  });\n  return docsInDb;\n}\n//# sourceMappingURL=dexie-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/storage-dexie/dexie-helper.js?");

/***/ }),

/***/ "./dist/es/plugins/storage-dexie/dexie-query.js":
/*!******************************************************!*\
  !*** ./dist/es/plugins/storage-dexie/dexie-query.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dexieCount\": () => (/* binding */ dexieCount),\n/* harmony export */   \"dexieQuery\": () => (/* binding */ dexieQuery),\n/* harmony export */   \"getKeyRangeByQueryPlan\": () => (/* binding */ getKeyRangeByQueryPlan)\n/* harmony export */ });\n/* harmony import */ var _rx_storage_statics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../rx-storage-statics */ \"./dist/es/rx-storage-statics.js\");\n/* harmony import */ var _dexie_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dexie-helper */ \"./dist/es/plugins/storage-dexie/dexie-helper.js\");\n\n\nfunction getKeyRangeByQueryPlan(queryPlan, IDBKeyRange) {\n  if (!IDBKeyRange) {\n    if (typeof window === 'undefined') {\n      throw new Error('IDBKeyRange missing');\n    } else {\n      IDBKeyRange = window.IDBKeyRange;\n    }\n  }\n  var ret;\n  /**\n   * If index has only one field,\n   * we have to pass the keys directly, not the key arrays.\n   */\n  if (queryPlan.index.length === 1) {\n    ret = IDBKeyRange.bound(queryPlan.startKeys[0], queryPlan.endKeys[0], queryPlan.inclusiveStart, queryPlan.inclusiveEnd);\n  } else {\n    ret = IDBKeyRange.bound(queryPlan.startKeys, queryPlan.endKeys, queryPlan.inclusiveStart, queryPlan.inclusiveEnd);\n  }\n  return ret;\n}\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nasync function dexieQuery(instance, preparedQuery) {\n  var state = await instance.internals;\n  var query = preparedQuery.query;\n  var skip = query.skip ? query.skip : 0;\n  var limit = query.limit ? query.limit : Infinity;\n  var skipPlusLimit = skip + limit;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryMatcher = false;\n  if (!queryPlan.selectorSatisfiedByIndex) {\n    queryMatcher = _rx_storage_statics__WEBPACK_IMPORTED_MODULE_0__.RxStorageDefaultStatics.getQueryMatcher(instance.schema, preparedQuery);\n  }\n  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n  var queryPlanFields = queryPlan.index;\n  var rows = [];\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    /**\n     * TODO here we use the native IndexedDB transaction\n     * to get the cursor.\n     * Instead we should not leave Dexie.js API and find\n     * a way to create the cursor with Dexie.js.\n     */\n    var tx = dexieTx.idbtrans;\n\n    // const nativeIndexedDB = state.dexieDb.backendDB();\n    // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n    var store = tx.objectStore(_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.DEXIE_DOCS_TABLE_NAME);\n    var index;\n    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n      index = store;\n    } else {\n      var indexName;\n      if (queryPlanFields.length === 1) {\n        indexName = (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);\n      } else {\n        indexName = '[' + queryPlanFields.map(field => (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.dexieReplaceIfStartsWithPipe)(field)).join('+') + ']';\n      }\n      index = store.index(indexName);\n    }\n    var cursorReq = index.openCursor(keyRange);\n    await new Promise(res => {\n      cursorReq.onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (cursor) {\n          // We have a record in cursor.value\n          var docData = (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.fromDexieToStorage)(cursor.value);\n          if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {\n            rows.push(docData);\n          }\n\n          /**\n           * If we do not have to manually sort\n           * and have enough documents,\n           * we can abort iterating over the cursor\n           * because we already have every relevant document.\n           */\n          if (queryPlan.sortFieldsSameAsIndexFields && rows.length === skipPlusLimit) {\n            res();\n          } else {\n            cursor.continue();\n          }\n        } else {\n          // Iteration complete\n          res();\n        }\n      };\n    });\n  });\n  if (!queryPlan.sortFieldsSameAsIndexFields) {\n    var sortComparator = _rx_storage_statics__WEBPACK_IMPORTED_MODULE_0__.RxStorageDefaultStatics.getSortComparator(instance.schema, preparedQuery);\n    rows = rows.sort(sortComparator);\n  }\n\n  // apply skip and limit boundaries.\n  rows = rows.slice(skip, skipPlusLimit);\n\n  /**\n   * Comment this in for debugging to check all fields in the database.\n   */\n  // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n  // let documents = docsInDb\n  //     .map(docData => stripDexieKey(docData))\n  //     .sort(sortComparator);\n  // if (preparedQuery.skip) {\n  //     documents = documents.slice(preparedQuery.skip);\n  // }\n  // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n  //     documents = documents.slice(0, preparedQuery.limit);\n  // }\n\n  return {\n    documents: rows\n  };\n}\nasync function dexieCount(instance, preparedQuery) {\n  var state = await instance.internals;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryPlanFields = queryPlan.index;\n  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n  var count = -1;\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    var tx = dexieTx.idbtrans;\n    var store = tx.objectStore(_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.DEXIE_DOCS_TABLE_NAME);\n    var index;\n    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n      index = store;\n    } else {\n      var indexName;\n      if (queryPlanFields.length === 1) {\n        indexName = (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);\n      } else {\n        indexName = '[' + queryPlanFields.map(field => (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_1__.dexieReplaceIfStartsWithPipe)(field)).join('+') + ']';\n      }\n      index = store.index(indexName);\n    }\n    var request = index.count(keyRange);\n    count = await new Promise((res, rej) => {\n      request.onsuccess = function () {\n        res(request.result);\n      };\n      request.onerror = err => rej(err);\n    });\n  });\n  return count;\n}\n//# sourceMappingURL=dexie-query.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/storage-dexie/dexie-query.js?");

/***/ }),

/***/ "./dist/es/plugins/storage-dexie/rx-storage-dexie.js":
/*!***********************************************************!*\
  !*** ./dist/es/plugins/storage-dexie/rx-storage-dexie.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxStorageDexie\": () => (/* binding */ RxStorageDexie),\n/* harmony export */   \"getRxStorageDexie\": () => (/* binding */ getRxStorageDexie)\n/* harmony export */ });\n/* harmony import */ var _dexie_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dexie-helper */ \"./dist/es/plugins/storage-dexie/dexie-helper.js\");\n/* harmony import */ var _rx_storage_instance_dexie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-storage-instance-dexie */ \"./dist/es/plugins/storage-dexie/rx-storage-instance-dexie.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n\n\n\nvar RxStorageDexie = /*#__PURE__*/function () {\n  function RxStorageDexie(settings) {\n    this.name = _dexie_helper__WEBPACK_IMPORTED_MODULE_0__.RX_STORAGE_NAME_DEXIE;\n    this.statics = _dexie_helper__WEBPACK_IMPORTED_MODULE_0__.RxStorageDexieStatics;\n    this.settings = settings;\n  }\n  var _proto = RxStorageDexie.prototype;\n  _proto.createStorageInstance = function createStorageInstance(params) {\n    (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_1__.ensureRxStorageInstanceParamsAreCorrect)(params);\n    (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_0__.ensureNoBooleanIndex)(params.schema);\n    return (0,_rx_storage_instance_dexie__WEBPACK_IMPORTED_MODULE_2__.createDexieStorageInstance)(this, params, this.settings);\n  };\n  return RxStorageDexie;\n}();\nfunction getRxStorageDexie(settings = {}) {\n  var storage = new RxStorageDexie(settings);\n  return storage;\n}\n//# sourceMappingURL=rx-storage-dexie.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/storage-dexie/rx-storage-dexie.js?");

/***/ }),

/***/ "./dist/es/plugins/storage-dexie/rx-storage-instance-dexie.js":
/*!********************************************************************!*\
  !*** ./dist/es/plugins/storage-dexie/rx-storage-instance-dexie.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxStorageInstanceDexie\": () => (/* binding */ RxStorageInstanceDexie),\n/* harmony export */   \"createDexieStorageInstance\": () => (/* binding */ createDexieStorageInstance)\n/* harmony export */ });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _dexie_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dexie-helper */ \"./dist/es/plugins/storage-dexie/dexie-helper.js\");\n/* harmony import */ var _dexie_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dexie-query */ \"./dist/es/plugins/storage-dexie/dexie-query.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _rx_storage_multiinstance__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../rx-storage-multiinstance */ \"./dist/es/rx-storage-multiinstance.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../rx-error */ \"./dist/es/rx-error.js\");\n\n\n\n\n\n\n\n\nvar instanceId = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\nvar RxStorageInstanceDexie = /*#__PURE__*/function () {\n  function RxStorageInstanceDexie(storage, databaseName, collectionName, schema, internals, options, settings) {\n    this.changes$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n    this.instanceId = instanceId++;\n    this.closed = false;\n    this.storage = storage;\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.schema = schema;\n    this.internals = internals;\n    this.options = options;\n    this.settings = settings;\n    this.primaryPath = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_2__.getPrimaryFieldOfPrimaryKey)(this.schema.primaryKey);\n  }\n  var _proto = RxStorageInstanceDexie.prototype;\n  _proto.bulkWrite = async function bulkWrite(documentWrites, context) {\n    ensureNotClosed(this);\n\n    /**\n     * Check some assumptions to ensure RxDB\n     * does not call the storage with an invalid write.\n     */\n    documentWrites.forEach(row => {\n      // ensure revision is set\n      if (!row.document._rev || row.previous && !row.previous._rev) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_3__.newRxError)('SNH', {\n          args: {\n            row\n          }\n        });\n      }\n    });\n    var state = await this.internals;\n    var ret = {\n      success: {},\n      error: {}\n    };\n    var documentKeys = documentWrites.map(writeRow => writeRow.document[this.primaryPath]);\n    var categorized;\n    await state.dexieDb.transaction('rw', state.dexieTable, state.dexieDeletedTable, async () => {\n      var docsInDbMap = new Map();\n      var docsInDbWithInternals = await (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.getDocsInDb)(this.internals, documentKeys);\n      docsInDbWithInternals.forEach(docWithDexieInternals => {\n        var doc = docWithDexieInternals ? (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.fromDexieToStorage)(docWithDexieInternals) : docWithDexieInternals;\n        if (doc) {\n          docsInDbMap.set(doc[this.primaryPath], doc);\n        }\n        return doc;\n      });\n      categorized = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__.categorizeBulkWriteRows)(this, this.primaryPath, docsInDbMap, documentWrites, context);\n      ret.error = categorized.errors;\n\n      /**\n       * Batch up the database operations\n       * so we can later run them in bulk.\n       */\n      var bulkPutDocs = [];\n      var bulkRemoveDocs = [];\n      var bulkPutDeletedDocs = [];\n      var bulkRemoveDeletedDocs = [];\n      categorized.bulkInsertDocs.forEach(row => {\n        var docId = row.document[this.primaryPath];\n        ret.success[docId] = row.document;\n        bulkPutDocs.push(row.document);\n      });\n      categorized.bulkUpdateDocs.forEach(row => {\n        var docId = row.document[this.primaryPath];\n        ret.success[docId] = row.document;\n        if (row.document._deleted && row.previous && !row.previous._deleted) {\n          // newly deleted\n          bulkRemoveDocs.push(docId);\n          bulkPutDeletedDocs.push(row.document);\n        } else if (row.document._deleted && row.previous && row.previous._deleted) {\n          // deleted was modified but is still deleted\n          bulkPutDeletedDocs.push(row.document);\n        } else if (!row.document._deleted) {\n          // non-deleted was changed\n          bulkPutDocs.push(row.document);\n        } else {\n          throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_3__.newRxError)('SNH', {\n            args: {\n              row\n            }\n          });\n        }\n      });\n      await Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map(d => (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.fromStorageToDexie)(d))) : _utils__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : _utils__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map(d => (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.fromStorageToDexie)(d))) : _utils__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : _utils__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_VOID]);\n    });\n    categorized = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.ensureNotFalsy)(categorized);\n    if (categorized.eventBulk.events.length > 0) {\n      var lastState = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.ensureNotFalsy)(categorized.newestRow).document;\n      categorized.eventBulk.checkpoint = {\n        id: lastState[this.primaryPath],\n        lwt: lastState._meta.lwt\n      };\n      var endTime = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.now)();\n      categorized.eventBulk.events.forEach(event => event.endTime = endTime);\n      this.changes$.next(categorized.eventBulk);\n    }\n    return ret;\n  };\n  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    var ret = {};\n    await state.dexieDb.transaction('r', state.dexieTable, state.dexieDeletedTable, async () => {\n      var docsInDb;\n      if (deleted) {\n        docsInDb = await (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.getDocsInDb)(this.internals, ids);\n      } else {\n        docsInDb = await state.dexieTable.bulkGet(ids);\n      }\n      ids.forEach((id, idx) => {\n        var documentInDb = docsInDb[idx];\n        if (documentInDb && (!documentInDb._deleted || deleted)) {\n          ret[id] = (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.fromDexieToStorage)(documentInDb);\n        }\n      });\n    });\n    return ret;\n  };\n  _proto.query = function query(preparedQuery) {\n    ensureNotClosed(this);\n    return (0,_dexie_query__WEBPACK_IMPORTED_MODULE_8__.dexieQuery)(this, preparedQuery);\n  };\n  _proto.count = async function count(preparedQuery) {\n    var result = await (0,_dexie_query__WEBPACK_IMPORTED_MODULE_8__.dexieCount)(this, preparedQuery);\n    return {\n      count: result,\n      mode: 'fast'\n    };\n  };\n  _proto.getChangedDocumentsSince = async function getChangedDocumentsSince(limit, checkpoint) {\n    ensureNotClosed(this);\n    var sinceLwt = checkpoint ? checkpoint.lwt : _utils__WEBPACK_IMPORTED_MODULE_9__.RX_META_LWT_MINIMUM;\n    var sinceId = checkpoint ? checkpoint.id : '';\n    var state = await this.internals;\n    var [changedDocsNormal, changedDocsDeleted] = await Promise.all([state.dexieTable, state.dexieDeletedTable].map(async table => {\n      var query = table.where('[_meta.lwt+' + this.primaryPath + ']').above([sinceLwt, sinceId]).limit(limit);\n      var changedDocuments = await query.toArray();\n      return changedDocuments.map(d => (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.fromDexieToStorage)(d));\n    }));\n    var changedDocs = changedDocsNormal.concat(changedDocsDeleted);\n    changedDocs = (0,_utils__WEBPACK_IMPORTED_MODULE_9__.sortDocumentsByLastWriteTime)(this.primaryPath, changedDocs);\n    changedDocs = changedDocs.slice(0, limit);\n    var lastDoc = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.lastOfArray)(changedDocs);\n    return {\n      documents: changedDocs,\n      checkpoint: lastDoc ? {\n        id: lastDoc[this.primaryPath],\n        lwt: lastDoc._meta.lwt\n      } : checkpoint ? checkpoint : {\n        id: '',\n        lwt: 0\n      }\n    };\n  };\n  _proto.remove = async function remove() {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);\n    return this.close();\n  };\n  _proto.changeStream = function changeStream() {\n    ensureNotClosed(this);\n    return this.changes$.asObservable();\n  };\n  _proto.cleanup = async function cleanup(minimumDeletedTime) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await state.dexieDb.transaction('rw', state.dexieDeletedTable, async () => {\n      var maxDeletionTime = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - minimumDeletedTime;\n      var toRemove = await state.dexieDeletedTable.where('_meta.lwt').below(maxDeletionTime).toArray();\n      var removeIds = toRemove.map(doc => doc[this.primaryPath]);\n      await state.dexieDeletedTable.bulkDelete(removeIds);\n    });\n\n    /**\n     * TODO instead of deleting all deleted docs at once,\n     * only clean up some of them and return false if there are more documents to clean up.\n     * This ensures that when many documents have to be purged,\n     * we do not block the more important tasks too long.\n     */\n    return true;\n  };\n  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId) {\n    ensureNotClosed(this);\n    throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n  };\n  _proto.close = function close() {\n    ensureNotClosed(this);\n    this.closed = true;\n    this.changes$.complete();\n    (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.closeDexieDb)(this.internals);\n    return _utils__WEBPACK_IMPORTED_MODULE_6__.PROMISE_RESOLVE_VOID;\n  };\n  _proto.conflictResultionTasks = function conflictResultionTasks() {\n    return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n  };\n  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {};\n  return RxStorageInstanceDexie;\n}();\nfunction createDexieStorageInstance(storage, params, settings) {\n  var internals = (0,_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.getDexieDbWithTables)(params.databaseName, params.collectionName, settings, params.schema);\n  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);\n  (0,_rx_storage_multiinstance__WEBPACK_IMPORTED_MODULE_11__.addRxStorageMultiInstanceSupport)(_dexie_helper__WEBPACK_IMPORTED_MODULE_4__.RX_STORAGE_NAME_DEXIE, params, instance);\n  return Promise.resolve(instance);\n}\nfunction ensureNotClosed(instance) {\n  if (instance.closed) {\n    throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n  }\n}\n//# sourceMappingURL=rx-storage-instance-dexie.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/storage-dexie/rx-storage-instance-dexie.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-array.js":
/*!**********************************************!*\
  !*** ./dist/es/plugins/utils/utils-array.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrayFilterNotEmpty\": () => (/* binding */ arrayFilterNotEmpty),\n/* harmony export */   \"batchArray\": () => (/* binding */ batchArray),\n/* harmony export */   \"isMaybeReadonlyArray\": () => (/* binding */ isMaybeReadonlyArray),\n/* harmony export */   \"lastOfArray\": () => (/* binding */ lastOfArray),\n/* harmony export */   \"removeOneFromArrayIfMatches\": () => (/* binding */ removeOneFromArrayIfMatches),\n/* harmony export */   \"shuffleArray\": () => (/* binding */ shuffleArray),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray)\n/* harmony export */ });\nfunction lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n\n/**\n * shuffle the given array\n */\nfunction shuffleArray(arr) {\n  return arr.sort(() => Math.random() - 0.5);\n}\nfunction toArray(input) {\n  return Array.isArray(input) ? input.slice(0) : [input];\n}\n\n/**\n * Split array with items into smaller arrays with items\n * @link https://stackoverflow.com/a/7273794/3443137\n */\nfunction batchArray(array, batchSize) {\n  array = array.slice(0);\n  var ret = [];\n  while (array.length) {\n    var batch = array.splice(0, batchSize);\n    ret.push(batch);\n  }\n  return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/15996017\n */\nfunction removeOneFromArrayIfMatches(ar, condition) {\n  ar = ar.slice();\n  var i = ar.length;\n  var done = false;\n  while (i-- && !done) {\n    if (condition(ar[i])) {\n      done = true;\n      ar.splice(i, 1);\n    }\n  }\n  return ar;\n}\n\n/**\n * returns true if the supplied argument is either an Array<T> or a Readonly<Array<T>>\n */\nfunction isMaybeReadonlyArray(x) {\n  // While this looks strange, it's a workaround for an issue in TypeScript:\n  // https://github.com/microsoft/TypeScript/issues/17002\n  //\n  // The problem is that `Array.isArray` as a type guard returns `false` for a readonly array,\n  // but at runtime the object is an array and the runtime call to `Array.isArray` would return `true`.\n  // The type predicate here allows for both `Array<T>` and `Readonly<Array<T>>` to pass a type check while\n  // still performing runtime type inspection.\n  return Array.isArray(x);\n}\n\n/**\n * Use this in array.filter() to remove all empty slots\n * and have the correct typings afterwards.\n * @link https://stackoverflow.com/a/46700791/3443137\n */\nfunction arrayFilterNotEmpty(value) {\n  if (value === null || value === undefined) {\n    return false;\n  }\n  return true;\n}\n//# sourceMappingURL=utils-array.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-array.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-document.js":
/*!*************************************************!*\
  !*** ./dist/es/plugins/utils/utils-document.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RX_META_LWT_MINIMUM\": () => (/* binding */ RX_META_LWT_MINIMUM),\n/* harmony export */   \"areRxDocumentArraysEqual\": () => (/* binding */ areRxDocumentArraysEqual),\n/* harmony export */   \"getDefaultRevision\": () => (/* binding */ getDefaultRevision),\n/* harmony export */   \"getDefaultRxDocumentMeta\": () => (/* binding */ getDefaultRxDocumentMeta),\n/* harmony export */   \"getSortDocumentsByLastWriteTimeComparator\": () => (/* binding */ getSortDocumentsByLastWriteTimeComparator),\n/* harmony export */   \"sortDocumentsByLastWriteTime\": () => (/* binding */ sortDocumentsByLastWriteTime),\n/* harmony export */   \"stripMetaDataFromDocument\": () => (/* binding */ stripMetaDataFromDocument)\n/* harmony export */ });\n/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nvar RX_META_LWT_MINIMUM = 1;\nfunction getDefaultRxDocumentMeta() {\n  return {\n    /**\n     * Set this to 1 to not waste performance\n     * while calling new Date()..\n     * The storage wrappers will anyway update\n     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n     */\n    lwt: RX_META_LWT_MINIMUM\n  };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nfunction getDefaultRevision() {\n  /**\n   * Use a non-valid revision format,\n   * to ensure that the RxStorage will throw\n   * when the revision is not replaced downstream.\n   */\n  return '';\n}\nfunction stripMetaDataFromDocument(docData) {\n  return Object.assign({}, docData, {\n    _meta: undefined,\n    _deleted: undefined,\n    _rev: undefined\n  });\n}\n\n/**\n * Faster way to check the equalness of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nfunction areRxDocumentArraysEqual(primaryPath, ar1, ar2) {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n  var i = 0;\n  var len = ar1.length;\n  while (i < len) {\n    var row1 = ar1[i];\n    var row2 = ar2[i];\n    i++;\n    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSortDocumentsByLastWriteTimeComparator(primaryPath) {\n  return (a, b) => {\n    if (a._meta.lwt === b._meta.lwt) {\n      if (b[primaryPath] < a[primaryPath]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else {\n      return a._meta.lwt - b._meta.lwt;\n    }\n  };\n}\nfunction sortDocumentsByLastWriteTime(primaryPath, docs) {\n  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}\n//# sourceMappingURL=utils-document.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-document.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-error.js":
/*!**********************************************!*\
  !*** ./dist/es/plugins/utils/utils-error.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"errorToPlainJson\": () => (/* binding */ errorToPlainJson),\n/* harmony export */   \"pluginMissing\": () => (/* binding */ pluginMissing)\n/* harmony export */ });\n/* harmony import */ var _utils_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-string */ \"./dist/es/plugins/utils/utils-string.js\");\n\n\n/**\n * Returns an error that indicates that a plugin is missing\n * We do not throw a RxError because this should not be handled\n * programmatically but by using the correct import\n */\nfunction pluginMissing(pluginKey) {\n  var keyParts = pluginKey.split('-');\n  var pluginName = 'RxDB';\n  keyParts.forEach(part => {\n    pluginName += (0,_utils_string__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(part);\n  });\n  pluginName += 'Plugin';\n  return new Error(\"You are using a function which must be overwritten by a plugin.\\n        You should either prevent the usage of this function or add the plugin via:\\n            import { \" + pluginName + \" } from 'rxdb/plugins/\" + pluginKey + \"';\\n            addRxPlugin(\" + pluginName + \");\\n        \");\n}\nfunction errorToPlainJson(err) {\n  var ret = {\n    name: err.name,\n    message: err.message,\n    rxdb: err.rxdb,\n    parameters: err.parameters,\n    code: err.code,\n    // stack must be last to make it easier to read the json in a console.\n    stack: err.stack\n  };\n  return ret;\n}\n//# sourceMappingURL=utils-error.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-error.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-hash.js":
/*!*********************************************!*\
  !*** ./dist/es/plugins/utils/utils-hash.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultHashSha256\": () => (/* binding */ defaultHashSha256)\n/* harmony export */ });\n/* harmony import */ var ohash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ohash */ \"./node_modules/ohash/dist/index.mjs\");\n\n/**\n * Default hash method used to hash\n * strings and do equal comparisons.\n *\n * IMPORTANT: Changing the default hashing method\n * requires a BREAKING change!\n */\nfunction defaultHashSha256(input) {\n  return (0,ohash__WEBPACK_IMPORTED_MODULE_0__.sha256)(input);\n}\n//# sourceMappingURL=utils-hash.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-hash.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-object-deep-equal.js":
/*!**********************************************************!*\
  !*** ./dist/es/plugins/utils/utils-object-deep-equal.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deepEqual\": () => (/* binding */ deepEqual)\n/* harmony export */ });\n/**\n * Copied from the fast-deep-equal package\n * because it does not support es modules and causes optimization bailouts.\n * TODO use the npm package again when this is merged:\n * @link https://github.com/epoberezkin/fast-deep-equal/pull/105\n */\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length;\n    var i;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    var keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a !== a && b !== b;\n}\n//# sourceMappingURL=utils-object-deep-equal.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-object-deep-equal.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-object-dot-prop.js":
/*!********************************************************!*\
  !*** ./dist/es/plugins/utils/utils-object-dot-prop.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deepKeys\": () => (/* binding */ deepKeys),\n/* harmony export */   \"deleteProperty\": () => (/* binding */ deleteProperty),\n/* harmony export */   \"getProperty\": () => (/* binding */ getProperty),\n/* harmony export */   \"hasProperty\": () => (/* binding */ hasProperty),\n/* harmony export */   \"setProperty\": () => (/* binding */ setProperty)\n/* harmony export */ });\n/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nvar isObject = value => {\n  var type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n};\nvar disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nvar digits = new Set('0123456789');\nfunction getPathSegments(path) {\n  var parts = [];\n  var currentSegment = '';\n  var currentPart = 'start';\n  var isIgnoring = false;\n  for (var character of path) {\n    switch (character) {\n      case '\\\\':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (isIgnoring) {\n            currentSegment += character;\n          }\n          currentPart = 'property';\n          isIgnoring = !isIgnoring;\n          break;\n        }\n      case '.':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'property';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (disallowedKeys.has(currentSegment)) {\n            return [];\n          }\n          parts.push(currentSegment);\n          currentSegment = '';\n          currentPart = 'property';\n          break;\n        }\n      case '[':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'index';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (currentPart === 'property') {\n            if (disallowedKeys.has(currentSegment)) {\n              return [];\n            }\n            parts.push(currentSegment);\n            currentSegment = '';\n          }\n          currentPart = 'index';\n          break;\n        }\n      case ']':\n        {\n          if (currentPart === 'index') {\n            parts.push(Number.parseInt(currentSegment, 10));\n            currentSegment = '';\n            currentPart = 'indexEnd';\n            break;\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n\n          // Falls through\n        }\n\n      default:\n        {\n          if (currentPart === 'index' && !digits.has(character)) {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (currentPart === 'start') {\n            currentPart = 'property';\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += '\\\\';\n          }\n          currentSegment += character;\n        }\n    }\n  }\n  if (isIgnoring) {\n    currentSegment += '\\\\';\n  }\n  switch (currentPart) {\n    case 'property':\n      {\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        break;\n      }\n    case 'index':\n      {\n        throw new Error('Index was not closed');\n      }\n    case 'start':\n      {\n        parts.push('');\n        break;\n      }\n    // No default\n  }\n\n  return parts;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    var index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\nfunction assertNotStringIndex(object, key) {\n  if (isStringIndex(object, key)) {\n    throw new Error('Cannot use string index');\n  }\n}\nfunction getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nfunction setProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return object;\n  }\n  var root = object;\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      object[key] = value;\n    } else if (!isObject(object[key])) {\n      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n    }\n    object = object[key];\n  }\n  return root;\n}\nfunction deleteProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      delete object[key];\n      return true;\n    }\n    object = object[key];\n    if (!isObject(object)) {\n      return false;\n    }\n  }\n}\nfunction hasProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return false;\n  }\n  for (var key of pathArray) {\n    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n      return false;\n    }\n    object = object[key];\n  }\n  return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n  if (Array.isArray(value)) {\n    return value.map((v, index) => [index, v]);\n  }\n  return Object.entries(value);\n}\nfunction stringifyPath(pathSegments) {\n  var result = '';\n\n  // eslint-disable-next-line prefer-const\n  for (var [index, segment] of entries(pathSegments)) {\n    if (typeof segment === 'number') {\n      result += \"[\" + segment + \"]\";\n    } else {\n      segment = escapePath(segment);\n      result += index === 0 ? segment : \".\" + segment;\n    }\n  }\n  return result;\n}\nfunction* deepKeysIterator(object, currentPath = []) {\n  if (!isObject(object)) {\n    if (currentPath.length > 0) {\n      yield stringifyPath(currentPath);\n    }\n    return;\n  }\n  for (var [key, value] of entries(object)) {\n    yield* deepKeysIterator(value, [...currentPath, key]);\n  }\n}\nfunction deepKeys(object) {\n  return [...deepKeysIterator(object)];\n}\n//# sourceMappingURL=utils-object-dot-prop.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-object-dot-prop.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-object.js":
/*!***********************************************!*\
  !*** ./dist/es/plugins/utils/utils-object.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"deepFreeze\": () => (/* binding */ deepFreeze),\n/* harmony export */   \"firstPropertyNameOfObject\": () => (/* binding */ firstPropertyNameOfObject),\n/* harmony export */   \"firstPropertyValueOfObject\": () => (/* binding */ firstPropertyValueOfObject),\n/* harmony export */   \"flatClone\": () => (/* binding */ flatClone),\n/* harmony export */   \"flattenObject\": () => (/* binding */ flattenObject),\n/* harmony export */   \"getFromObjectOrThrow\": () => (/* binding */ getFromObjectOrThrow),\n/* harmony export */   \"objectPathMonad\": () => (/* binding */ objectPathMonad),\n/* harmony export */   \"overwriteGetterForCaching\": () => (/* binding */ overwriteGetterForCaching),\n/* harmony export */   \"sortObject\": () => (/* binding */ sortObject),\n/* harmony export */   \"stringifyFilter\": () => (/* binding */ stringifyFilter)\n/* harmony export */ });\nfunction deepFreeze(o) {\n  Object.freeze(o);\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n}\n\n/**\n * To get specific nested path values from objects,\n * RxDB normally uses the 'dot-prop' npm module.\n * But when performance is really relevant, this is not fast enough.\n * Instead we use a monad that can prepare some stuff up front\n * and we can re-use the generated function.\n */\n\nfunction objectPathMonad(objectPath) {\n  var split = objectPath.split('.');\n\n  /**\n   * Performance shortcut,\n   * if no nested path is used,\n   * directly return the field of the object.\n   */\n  if (split.length === 1) {\n    return obj => obj[objectPath];\n  }\n  return obj => {\n    var currentVal = obj;\n    var t = 0;\n    while (t < split.length) {\n      var subPath = split[t];\n      currentVal = currentVal[subPath];\n      if (typeof currentVal === 'undefined') {\n        return currentVal;\n      }\n      t++;\n    }\n    return currentVal;\n  };\n}\nfunction getFromObjectOrThrow(obj, key) {\n  var val = obj[key];\n  if (!val) {\n    throw new Error('missing value from object ' + key);\n  }\n  return val;\n}\n\n/**\n * returns a flattened object\n * @link https://gist.github.com/penguinboy/762197\n */\nfunction flattenObject(ob) {\n  var toReturn = {};\n  for (var i in ob) {\n    if (!ob.hasOwnProperty(i)) continue;\n    if (typeof ob[i] === 'object') {\n      var flatObject = flattenObject(ob[i]);\n      for (var x in flatObject) {\n        if (!flatObject.hasOwnProperty(x)) continue;\n        toReturn[i + '.' + x] = flatObject[x];\n      }\n    } else {\n      toReturn[i] = ob[i];\n    }\n  }\n  return toReturn;\n}\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nfunction flatClone(obj) {\n  return Object.assign({}, obj);\n}\n\n/**\n * @link https://stackoverflow.com/a/11509718/3443137\n */\nfunction firstPropertyNameOfObject(obj) {\n  return Object.keys(obj)[0];\n}\nfunction firstPropertyValueOfObject(obj) {\n  var key = Object.keys(obj)[0];\n  return obj[key];\n}\n\n/**\n * deep-sort an object so its attributes are in lexical order.\n * Also sorts the arrays inside of the object if no-array-sort not set\n */\nfunction sortObject(obj, noArraySort = false) {\n  if (!obj) return obj; // do not sort null, false or undefined\n\n  // array\n  if (!noArraySort && Array.isArray(obj)) {\n    return obj.sort((a, b) => {\n      if (typeof a === 'string' && typeof b === 'string') return a.localeCompare(b);\n      if (typeof a === 'object') return 1;else return -1;\n    }).map(i => sortObject(i, noArraySort));\n  }\n\n  // object\n  // array is also of type object\n  if (typeof obj === 'object' && !Array.isArray(obj)) {\n    if (obj instanceof RegExp) {\n      return obj;\n    }\n    var out = {};\n    Object.keys(obj).sort((a, b) => a.localeCompare(b)).forEach(key => {\n      out[key] = sortObject(obj[key], noArraySort);\n    });\n    return out;\n  }\n\n  // everything else\n  return obj;\n}\n\n/**\n * Deep clone a plain json object.\n * Does not work with recursive stuff\n * or non-plain-json.\n * IMPORANT: Performance of this is very important,\n * do not change it without running performance tests!\n *\n * @link https://github.com/zxdong262/deep-copy/blob/master/src/index.ts\n */\nfunction deepClone(src) {\n  if (!src) {\n    return src;\n  }\n  if (src === null || typeof src !== 'object') {\n    return src;\n  }\n  if (Array.isArray(src)) {\n    var ret = new Array(src.length);\n    var i = ret.length;\n    while (i--) {\n      ret[i] = deepClone(src[i]);\n    }\n    return ret;\n  }\n  var dest = {};\n  // eslint-disable-next-line guard-for-in\n  for (var key in src) {\n    dest[key] = deepClone(src[key]);\n  }\n  return dest;\n}\nvar clone = deepClone;\n\n/**\n * overwrites the getter with the actual value\n * Mostly used for caching stuff on the first run\n */\nfunction overwriteGetterForCaching(obj, getterName, value) {\n  Object.defineProperty(obj, getterName, {\n    get: function () {\n      return value;\n    }\n  });\n  return value;\n}\n\n/**\n * used to JSON.stringify() objects that contain a regex\n * @link https://stackoverflow.com/a/33416684 thank you Fabian Jakobs!\n */\nfunction stringifyFilter(key, value) {\n  if (value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n//# sourceMappingURL=utils-object.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-object.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-other.js":
/*!**********************************************!*\
  !*** ./dist/es/plugins/utils/utils-other.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RXJS_SHARE_REPLAY_DEFAULTS\": () => (/* binding */ RXJS_SHARE_REPLAY_DEFAULTS),\n/* harmony export */   \"ensureInteger\": () => (/* binding */ ensureInteger),\n/* harmony export */   \"ensureNotFalsy\": () => (/* binding */ ensureNotFalsy),\n/* harmony export */   \"getFromMapOrFill\": () => (/* binding */ getFromMapOrFill),\n/* harmony export */   \"getFromMapOrThrow\": () => (/* binding */ getFromMapOrThrow),\n/* harmony export */   \"runXTimes\": () => (/* binding */ runXTimes)\n/* harmony export */ });\nfunction runXTimes(xTimes, fn) {\n  new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));\n}\nfunction ensureNotFalsy(obj) {\n  if (!obj) {\n    throw new Error('ensureNotFalsy() is falsy');\n  }\n  return obj;\n}\nfunction ensureInteger(obj) {\n  if (!Number.isInteger(obj)) {\n    throw new Error('ensureInteger() is falsy');\n  }\n  return obj;\n}\nfunction getFromMapOrThrow(map, key) {\n  var val = map.get(key);\n  if (typeof val === 'undefined') {\n    throw new Error('missing value from map ' + key);\n  }\n  return val;\n}\nfunction getFromMapOrFill(map, key, fillerFunction) {\n  var value = map.get(key);\n  if (!value) {\n    value = fillerFunction();\n    map.set(key, value);\n  }\n  return value;\n}\n\n/**\n * Using shareReplay() without settings will not unsubscribe\n * if there are no more subscribers.\n * So we use these defaults.\n * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n */\nvar RXJS_SHARE_REPLAY_DEFAULTS = {\n  bufferSize: 1,\n  refCount: true\n};\n//# sourceMappingURL=utils-other.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-other.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-promise.js":
/*!************************************************!*\
  !*** ./dist/es/plugins/utils/utils-promise.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PROMISE_RESOLVE_FALSE\": () => (/* binding */ PROMISE_RESOLVE_FALSE),\n/* harmony export */   \"PROMISE_RESOLVE_NULL\": () => (/* binding */ PROMISE_RESOLVE_NULL),\n/* harmony export */   \"PROMISE_RESOLVE_TRUE\": () => (/* binding */ PROMISE_RESOLVE_TRUE),\n/* harmony export */   \"PROMISE_RESOLVE_VOID\": () => (/* binding */ PROMISE_RESOLVE_VOID),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"promiseSeries\": () => (/* binding */ promiseSeries),\n/* harmony export */   \"promiseWait\": () => (/* binding */ promiseWait),\n/* harmony export */   \"requestIdleCallbackIfAvailable\": () => (/* binding */ requestIdleCallbackIfAvailable),\n/* harmony export */   \"requestIdlePromise\": () => (/* binding */ requestIdlePromise),\n/* harmony export */   \"toPromise\": () => (/* binding */ toPromise)\n/* harmony export */ });\n/**\n * returns a promise that resolves on the next tick\n */\nfunction nextTick() {\n  return new Promise(res => setTimeout(res, 0));\n}\nfunction promiseWait(ms = 0) {\n  return new Promise(res => setTimeout(res, ms));\n}\nfunction toPromise(maybePromise) {\n  if (maybePromise && typeof maybePromise.then === 'function') {\n    // is promise\n    return maybePromise;\n  } else {\n    return Promise.resolve(maybePromise);\n  }\n}\nvar PROMISE_RESOLVE_TRUE = Promise.resolve(true);\nvar PROMISE_RESOLVE_FALSE = Promise.resolve(false);\nvar PROMISE_RESOLVE_NULL = Promise.resolve(null);\nvar PROMISE_RESOLVE_VOID = Promise.resolve();\nfunction requestIdlePromise(timeout = null) {\n  if (typeof window === 'object' && window['requestIdleCallback']) {\n    return new Promise(res => window['requestIdleCallback'](res, {\n      timeout\n    }));\n  } else {\n    return promiseWait(0);\n  }\n}\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nfunction requestIdleCallbackIfAvailable(fun) {\n  if (typeof window === 'object' && window['requestIdleCallback']) window['requestIdleCallback'](fun);\n}\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nfunction promiseSeries(tasks, initial) {\n  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));\n}\n//# sourceMappingURL=utils-promise.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-promise.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-regex.js":
/*!**********************************************!*\
  !*** ./dist/es/plugins/utils/utils-regex.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"REGEX_ALL_DOTS\": () => (/* binding */ REGEX_ALL_DOTS),\n/* harmony export */   \"REGEX_ALL_PIPES\": () => (/* binding */ REGEX_ALL_PIPES),\n/* harmony export */   \"REGEX_PARSE_REGEX_EXPRESSION\": () => (/* binding */ REGEX_PARSE_REGEX_EXPRESSION),\n/* harmony export */   \"parseRegex\": () => (/* binding */ parseRegex)\n/* harmony export */ });\n/* harmony import */ var _utils_other__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-other */ \"./dist/es/plugins/utils/utils-other.js\");\n\nvar REGEX_ALL_DOTS = /\\./g;\nvar REGEX_ALL_PIPES = /\\|/g;\n/**\n * @link https://stackoverflow.com/a/26034888/3443137\n*/\nvar REGEX_PARSE_REGEX_EXPRESSION = /(\\/?)(.+)\\1([a-z]*)/i;\nfunction parseRegex(regex) {\n  var matches = (0,_utils_other__WEBPACK_IMPORTED_MODULE_0__.ensureNotFalsy)(regex.toString().match(REGEX_PARSE_REGEX_EXPRESSION));\n  return {\n    pattern: matches[2],\n    flags: matches[3]\n  };\n}\n//# sourceMappingURL=utils-regex.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-regex.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-revision.js":
/*!*************************************************!*\
  !*** ./dist/es/plugins/utils/utils-revision.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createRevision\": () => (/* binding */ createRevision),\n/* harmony export */   \"getHeightOfRevision\": () => (/* binding */ getHeightOfRevision),\n/* harmony export */   \"parseRevision\": () => (/* binding */ parseRevision)\n/* harmony export */ });\nfunction parseRevision(revision) {\n  var split = revision.split('-');\n  if (split.length !== 2) {\n    throw new Error('malformated revision: ' + revision);\n  }\n  return {\n    height: parseInt(split[0], 10),\n    hash: split[1]\n  };\n}\n\n/**\n * @hotPath\n */\nfunction getHeightOfRevision(revision) {\n  var ret = parseInt(revision.split('-')[0], 10);\n  return ret;\n}\n\n/**\n * Creates the next write revision for a given document.\n */\nfunction createRevision(databaseInstanceToken, previousDocData) {\n  var previousRevision = previousDocData ? previousDocData._rev : null;\n  var previousRevisionHeigth = previousRevision ? parseRevision(previousRevision).height : 0;\n  var newRevisionHeight = previousRevisionHeigth + 1;\n  return newRevisionHeight + '-' + databaseInstanceToken;\n}\n//# sourceMappingURL=utils-revision.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-revision.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-string.js":
/*!***********************************************!*\
  !*** ./dist/es/plugins/utils/utils-string.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RANDOM_STRING\": () => (/* binding */ RANDOM_STRING),\n/* harmony export */   \"arrayBufferToString\": () => (/* binding */ arrayBufferToString),\n/* harmony export */   \"isFolderPath\": () => (/* binding */ isFolderPath),\n/* harmony export */   \"randomCouchString\": () => (/* binding */ randomCouchString),\n/* harmony export */   \"stringToArrayBuffer\": () => (/* binding */ stringToArrayBuffer),\n/* harmony export */   \"trimDots\": () => (/* binding */ trimDots),\n/* harmony export */   \"ucfirst\": () => (/* binding */ ucfirst)\n/* harmony export */ });\n/**\n * get a random string which can be used with couchdb\n * @link http://stackoverflow.com/a/1349426/3443137\n */\nfunction randomCouchString(length = 10) {\n  var text = '';\n  var possible = 'abcdefghijklmnopqrstuvwxyz';\n  for (var i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n\n/**\n * A random string that is never inside of any storage\n */\nvar RANDOM_STRING = 'Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX';\n\n/**\n * uppercase first char\n */\nfunction ucfirst(str) {\n  str += '';\n  var f = str.charAt(0).toUpperCase();\n  return f + str.substr(1);\n}\n\n/**\n * removes trailing and ending dots from the string\n */\nfunction trimDots(str) {\n  // start\n  while (str.charAt(0) === '.') {\n    str = str.substr(1);\n  }\n\n  // end\n  while (str.slice(-1) === '.') {\n    str = str.slice(0, -1);\n  }\n  return str;\n}\n\n/**\n * returns true if the given name is likely a folder path\n */\nfunction isFolderPath(name) {\n  // do not check, if foldername is given\n  if (name.includes('/') ||\n  // unix\n  name.includes('\\\\') // windows\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * @link https://gist.github.com/andreburgaud/6f73fd2d690b629346b8\n */\nfunction arrayBufferToString(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\nfunction stringToArrayBuffer(str) {\n  var buf = new ArrayBuffer(str.length * 2);\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n//# sourceMappingURL=utils-string.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-string.js?");

/***/ }),

/***/ "./dist/es/plugins/utils/utils-time.js":
/*!*********************************************!*\
  !*** ./dist/es/plugins/utils/utils-time.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"now\": () => (/* binding */ now)\n/* harmony export */ });\n/**\n * Returns the current unix time in milliseconds (with two decmials!)\n * Because the accuracy of getTime() in javascript is bad,\n * and we cannot rely on performance.now() on all platforms,\n * this method implements a way to never return the same value twice.\n * This ensures that when now() is called often, we do not loose the information\n * about which call came first and which came after.\n *\n * We had to move from having no decimals, to having two decimal\n * because it turned out that some storages are such fast that\n * calling this method too often would return 'the future'.\n */\nvar _lastNow = 0;\n/**\n * Returns the current time in milliseconds,\n * also ensures to not return the same value twice.\n */\nfunction now() {\n  var ret = new Date().getTime();\n  ret = ret + 0.01;\n  if (ret <= _lastNow) {\n    ret = _lastNow + 0.01;\n  }\n\n  /**\n   * Strip the returned number to max two decimals.\n   * In theory we would not need this but\n   * in practice JavaScript has no such good number precision\n   * so rounding errors could add another decimal place.\n   */\n  var twoDecimals = parseFloat(ret.toFixed(2));\n  _lastNow = twoDecimals;\n  return twoDecimals;\n}\n//# sourceMappingURL=utils-time.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/plugins/utils/utils-time.js?");

/***/ }),

/***/ "./dist/es/query-cache.js":
/*!********************************!*\
  !*** ./dist/es/query-cache.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLLECTIONS_WITH_RUNNING_CLEANUP\": () => (/* binding */ COLLECTIONS_WITH_RUNNING_CLEANUP),\n/* harmony export */   \"DEFAULT_TRY_TO_KEEP_MAX\": () => (/* binding */ DEFAULT_TRY_TO_KEEP_MAX),\n/* harmony export */   \"DEFAULT_UNEXECUTED_LIFETME\": () => (/* binding */ DEFAULT_UNEXECUTED_LIFETME),\n/* harmony export */   \"QueryCache\": () => (/* binding */ QueryCache),\n/* harmony export */   \"countRxQuerySubscribers\": () => (/* binding */ countRxQuerySubscribers),\n/* harmony export */   \"createQueryCache\": () => (/* binding */ createQueryCache),\n/* harmony export */   \"defaultCacheReplacementPolicy\": () => (/* binding */ defaultCacheReplacementPolicy),\n/* harmony export */   \"defaultCacheReplacementPolicyMonad\": () => (/* binding */ defaultCacheReplacementPolicyMonad),\n/* harmony export */   \"triggerCacheReplacement\": () => (/* binding */ triggerCacheReplacement),\n/* harmony export */   \"uncacheRxQuery\": () => (/* binding */ uncacheRxQuery)\n/* harmony export */ });\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\n\nvar QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    if (!this._map.has(stringRep)) {\n      this._map.set(stringRep, rxQuery);\n    }\n    return this._map.get(stringRep);\n  };\n  return QueryCache;\n}();\nfunction createQueryCache() {\n  return new QueryCache();\n}\nfunction uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nfunction countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nvar DEFAULT_TRY_TO_KEEP_MAX = 100;\nvar DEFAULT_UNEXECUTED_LIFETME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nvar defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.now)() - unExecutedLifetime;\n  var maybeUncash = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older then unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncash.push(rxQuery);\n  }\n  var mustUncache = maybeUncash.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncash.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nvar defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETME);\nvar COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nfunction triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.nextTick)() // wait at least one tick\n  .then(() => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.requestIdlePromise)(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.destroyed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}\n//# sourceMappingURL=query-cache.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/query-cache.js?");

/***/ }),

/***/ "./dist/es/query-planner.js":
/*!**********************************!*\
  !*** ./dist/es/query-planner.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"INDEX_MAX\": () => (/* binding */ INDEX_MAX),\n/* harmony export */   \"INDEX_MIN\": () => (/* binding */ INDEX_MIN),\n/* harmony export */   \"LOGICAL_OPERATORS\": () => (/* binding */ LOGICAL_OPERATORS),\n/* harmony export */   \"LOWER_BOUND_LOGICAL_OPERATORS\": () => (/* binding */ LOWER_BOUND_LOGICAL_OPERATORS),\n/* harmony export */   \"UPPER_BOUND_LOGICAL_OPERATORS\": () => (/* binding */ UPPER_BOUND_LOGICAL_OPERATORS),\n/* harmony export */   \"getMatcherQueryOpts\": () => (/* binding */ getMatcherQueryOpts),\n/* harmony export */   \"getQueryPlan\": () => (/* binding */ getQueryPlan),\n/* harmony export */   \"isSelectorSatisfiedByIndex\": () => (/* binding */ isSelectorSatisfiedByIndex),\n/* harmony export */   \"rateQueryPlan\": () => (/* binding */ rateQueryPlan)\n/* harmony export */ });\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n\nvar INDEX_MAX = String.fromCharCode(65535);\nvar INDEX_MIN = -Infinity;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nfunction getQueryPlan(schema, query) {\n  var primaryPath = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);\n  var selector = query.selector;\n  var indexes = schema.indexes ? schema.indexes.slice(0) : [];\n  if (query.index) {\n    indexes = [query.index];\n  } else {\n    indexes.push([primaryPath]);\n  }\n  var optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n  var optimalSortIndexCompareString = optimalSortIndex.join(',');\n  /**\n   * Most storages do not support descending indexes\n   * so having a 'desc' in the sorting, means we always have to re-sort the results.\n   */\n  var hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n  var currentBestQuality = -1;\n  var currentBestQueryPlan;\n  indexes.forEach(index => {\n    var inclusiveEnd = true;\n    var inclusiveStart = true;\n    var opts = index.map(indexField => {\n      var matcher = selector[indexField];\n      var operators = matcher ? Object.keys(matcher) : [];\n      var matcherOpts = {};\n      if (!matcher || !operators.length) {\n        matcherOpts = {\n          startKey: inclusiveStart ? INDEX_MIN : INDEX_MAX,\n          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n          inclusiveStart: true,\n          inclusiveEnd: true\n        };\n      } else {\n        operators.forEach(operator => {\n          if (LOGICAL_OPERATORS.has(operator)) {\n            var operatorValue = matcher[operator];\n            var partialOpts = getMatcherQueryOpts(operator, operatorValue);\n            matcherOpts = Object.assign(matcherOpts, partialOpts);\n          }\n        });\n      }\n\n      // fill missing attributes\n      if (typeof matcherOpts.startKey === 'undefined') {\n        matcherOpts.startKey = INDEX_MIN;\n      }\n      if (typeof matcherOpts.endKey === 'undefined') {\n        matcherOpts.endKey = INDEX_MAX;\n      }\n      if (typeof matcherOpts.inclusiveStart === 'undefined') {\n        matcherOpts.inclusiveStart = true;\n      }\n      if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n        matcherOpts.inclusiveEnd = true;\n      }\n      if (inclusiveStart && !matcherOpts.inclusiveStart) {\n        inclusiveStart = false;\n      }\n      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n        inclusiveEnd = false;\n      }\n      return matcherOpts;\n    });\n    var queryPlan = {\n      index,\n      startKeys: opts.map(opt => opt.startKey),\n      endKeys: opts.map(opt => opt.endKey),\n      inclusiveEnd,\n      inclusiveStart,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(','),\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector)\n    };\n    var quality = rateQueryPlan(schema, query, queryPlan);\n    if (quality > 0 && quality > currentBestQuality || query.index) {\n      currentBestQuality = quality;\n      currentBestQueryPlan = queryPlan;\n    }\n  });\n\n  /**\n   * No index found, use the default index\n   */\n  if (!currentBestQueryPlan) {\n    currentBestQueryPlan = {\n      index: [primaryPath],\n      startKeys: [INDEX_MIN],\n      endKeys: [INDEX_MAX],\n      inclusiveEnd: true,\n      inclusiveStart: true,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)\n    };\n  }\n  return currentBestQueryPlan;\n}\nvar LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nvar LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nvar UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\nfunction isSelectorSatisfiedByIndex(index, selector) {\n  var selectorEntries = Object.entries(selector);\n  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {\n    if (!index.includes(fieldName)) {\n      return true;\n    }\n    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n    return hasNonLogicOperator;\n  });\n  if (hasNonMatchingOperator) {\n    return false;\n  }\n  var prevLowerBoundaryField;\n  var hasMoreThenOneLowerBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasLowerLogicOp = Object.keys(operation).find(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevLowerBoundaryField && hasLowerLogicOp) {\n      return true;\n    } else if (hasLowerLogicOp !== '$eq') {\n      prevLowerBoundaryField = hasLowerLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneLowerBoundaryField) {\n    return false;\n  }\n  var prevUpperBoundaryField;\n  var hasMoreThenOneUpperBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasUpperLogicOp = Object.keys(operation).find(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevUpperBoundaryField && hasUpperLogicOp) {\n      return true;\n    } else if (hasUpperLogicOp !== '$eq') {\n      prevUpperBoundaryField = hasUpperLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneUpperBoundaryField) {\n    return false;\n  }\n  return true;\n}\nfunction getMatcherQueryOpts(operator, operatorValue) {\n  switch (operator) {\n    case '$eq':\n      return {\n        startKey: operatorValue,\n        endKey: operatorValue\n      };\n    case '$lte':\n      return {\n        endKey: operatorValue\n      };\n    case '$gte':\n      return {\n        startKey: operatorValue\n      };\n    case '$lt':\n      return {\n        endKey: operatorValue,\n        inclusiveEnd: false\n      };\n    case '$gt':\n      return {\n        startKey: operatorValue,\n        inclusiveStart: false\n      };\n    default:\n      throw new Error('SNH');\n  }\n}\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nfunction rateQueryPlan(schema, query, queryPlan) {\n  var quality = 0;\n  var pointsPerMatchingKey = 10;\n  var idxOfFirstMinStartKey = queryPlan.startKeys.findIndex(keyValue => keyValue === INDEX_MIN);\n  if (idxOfFirstMinStartKey > 0) {\n    quality = quality + idxOfFirstMinStartKey * pointsPerMatchingKey;\n  }\n  var idxOfFirstMaxEndKey = queryPlan.endKeys.findIndex(keyValue => keyValue === INDEX_MAX);\n  if (idxOfFirstMaxEndKey > 0) {\n    quality = quality + idxOfFirstMaxEndKey * pointsPerMatchingKey;\n  }\n  var pointsIfNoReSortMustBeDone = 5;\n  if (queryPlan.sortFieldsSameAsIndexFields) {\n    quality = quality + pointsIfNoReSortMustBeDone;\n  }\n  return quality;\n}\n//# sourceMappingURL=query-planner.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/query-planner.js?");

/***/ }),

/***/ "./dist/es/replication-protocol/conflicts.js":
/*!***************************************************!*\
  !*** ./dist/es/replication-protocol/conflicts.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultConflictHandler\": () => (/* binding */ defaultConflictHandler),\n/* harmony export */   \"resolveConflictError\": () => (/* binding */ resolveConflictError)\n/* harmony export */ });\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../plugins/utils */ \"./dist/es/plugins/utils/utils-object-deep-equal.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/utils */ \"./dist/es/plugins/utils/utils-revision.js\");\n\nvar defaultConflictHandler = function (i, _context) {\n  /**\n   * If the documents are deep equal,\n   * we have no conflict.\n   * On your custom conflict handler you might only\n   * check some properties, like the updatedAt time,\n   * for better performance, because deepEqual is expensive.\n   */\n  if ((0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(i.newDocumentState, i.realMasterState)) {\n    return Promise.resolve({\n      isEqual: true\n    });\n  }\n\n  /**\n   * The default conflict handler will always\n   * drop the fork state and use the master state instead.\n   */\n  return Promise.resolve({\n    isEqual: false,\n    documentData: i.realMasterState\n  });\n};\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nasync function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\n  if (conflictHandlerOutput.isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.flatClone)(forkState._meta),\n      _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getDefaultRevision)(),\n      _attachments: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.flatClone)(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.now)();\n    resolvedDoc._rev = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.createRevision)(state.input.identifier, forkState);\n    return {\n      resolvedDoc,\n      output: conflictHandlerOutput\n    };\n  }\n}\n//# sourceMappingURL=conflicts.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/replication-protocol/conflicts.js?");

/***/ }),

/***/ "./dist/es/rx-change-event.js":
/*!************************************!*\
  !*** ./dist/es/rx-change-event.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flattenEvents\": () => (/* binding */ flattenEvents),\n/* harmony export */   \"getDocumentDataOfRxChangeEvent\": () => (/* binding */ getDocumentDataOfRxChangeEvent),\n/* harmony export */   \"rxChangeEventToEventReduceChangeEvent\": () => (/* binding */ rxChangeEventToEventReduceChangeEvent)\n/* harmony export */ });\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\n\nfunction getDocumentDataOfRxChangeEvent(rxChangeEvent) {\n  if (rxChangeEvent.documentData) {\n    return rxChangeEvent.documentData;\n  } else {\n    return rxChangeEvent.previousDocumentData;\n  }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nfunction rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {\n  switch (rxChangeEvent.operation) {\n    case 'INSERT':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: rxChangeEvent.documentData,\n        previous: null\n      };\n    case 'UPDATE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: _overwritable__WEBPACK_IMPORTED_MODULE_0__.overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),\n        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : 'UNKNOWN'\n      };\n    case 'DELETE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: null,\n        previous: rxChangeEvent.previousDocumentData\n      };\n  }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nfunction flattenEvents(input) {\n  var output = [];\n  if (Array.isArray(input)) {\n    input.forEach(inputItem => {\n      var add = flattenEvents(inputItem);\n      output = output.concat(add);\n    });\n  } else {\n    if (input.id && input.events) {\n      // is bulk\n      input.events.forEach(ev => output.push(ev));\n    } else {\n      output.push(input);\n    }\n  }\n  var usedIds = new Set();\n  var nonDuplicate = [];\n  output.forEach(ev => {\n    if (!usedIds.has(ev.eventId)) {\n      usedIds.add(ev.eventId);\n      nonDuplicate.push(ev);\n    }\n  });\n  return nonDuplicate;\n}\n//# sourceMappingURL=rx-change-event.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-change-event.js?");

/***/ }),

/***/ "./dist/es/rx-collection-helper.js":
/*!*****************************************!*\
  !*** ./dist/es/rx-collection-helper.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createRxCollectionStorageInstance\": () => (/* binding */ createRxCollectionStorageInstance),\n/* harmony export */   \"fillObjectDataBeforeInsert\": () => (/* binding */ fillObjectDataBeforeInsert),\n/* harmony export */   \"removeCollectionStorages\": () => (/* binding */ removeCollectionStorages)\n/* harmony export */ });\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-revision.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-database-internal-store */ \"./dist/es/rx-database-internal-store.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n\n\n\n\n\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nfunction fillObjectDataBeforeInsert(schema, data) {\n  data = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(data);\n  data = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.fillObjectWithDefaults)(schema, data);\n  data = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.fillPrimaryKey)(schema.primaryPath, schema.jsonSchema, data);\n  data._meta = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getDefaultRxDocumentMeta)();\n  if (!data.hasOwnProperty('_deleted')) {\n    data._deleted = false;\n  }\n  if (!data.hasOwnProperty('_attachments')) {\n    data._attachments = {};\n  }\n  if (!data.hasOwnProperty('_rev')) {\n    data._rev = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getDefaultRevision)();\n  }\n  return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nasync function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {\n  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);\n  return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nasync function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName,\n/**\n * If no hash function is provided,\n * we assume that the whole internal store is removed anyway\n * so we do not have to delete the meta documents.\n */\nhashFunction) {\n  var allCollectionMetaDocs = await (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_3__.getAllCollectionDocuments)(storage.statics, databaseInternalStorage);\n  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);\n  var removeStorages = [];\n  relevantCollectionMetaDocs.forEach(metaDoc => {\n    removeStorages.push({\n      collectionName: metaDoc.data.name,\n      schema: metaDoc.data.schema,\n      isCollection: true\n    });\n    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n      collectionName: row.collectionName,\n      isCollection: false,\n      schema: row.schema\n    }));\n  });\n\n  // ensure uniqueness\n  var alreadyAdded = new Set();\n  removeStorages = removeStorages.filter(row => {\n    var key = row.collectionName + '||' + row.schema.version;\n    if (alreadyAdded.has(key)) {\n      return false;\n    } else {\n      alreadyAdded.add(key);\n      return true;\n    }\n  });\n\n  // remove all the storages\n  await Promise.all(removeStorages.map(async row => {\n    var storageInstance = await storage.createStorageInstance({\n      collectionName: row.collectionName,\n      databaseInstanceToken,\n      databaseName,\n      multiInstance: false,\n      options: {},\n      schema: row.schema\n    });\n    await storageInstance.remove();\n    if (row.isCollection) {\n      await (0,_hooks__WEBPACK_IMPORTED_MODULE_4__.runAsyncPluginHooks)('postRemoveRxCollection', {\n        storage,\n        databaseName: databaseName,\n        collectionName\n      });\n    }\n  }));\n\n  // remove the meta documents\n  if (hashFunction) {\n    var writeRows = relevantCollectionMetaDocs.map(doc => {\n      var writeDoc = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__.flatCloneDocWithMeta)(doc);\n      writeDoc._deleted = true;\n      writeDoc._meta.lwt = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.now)();\n      writeDoc._rev = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_7__.createRevision)(databaseInstanceToken, doc);\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');\n  }\n}\n//# sourceMappingURL=rx-collection-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-collection-helper.js?");

/***/ }),

/***/ "./dist/es/rx-collection.js":
/*!**********************************!*\
  !*** ./dist/es/rx-collection.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxCollectionBase\": () => (/* binding */ RxCollectionBase),\n/* harmony export */   \"createRxCollection\": () => (/* binding */ createRxCollection),\n/* harmony export */   \"isRxCollection\": () => (/* binding */ isRxCollection)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rx-collection-helper */ \"./dist/es/rx-collection-helper.js\");\n/* harmony import */ var _rx_query__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./rx-query */ \"./dist/es/rx-query.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _doc_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./doc-cache */ \"./dist/es/doc-cache.js\");\n/* harmony import */ var _query_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query-cache */ \"./dist/es/query-cache.js\");\n/* harmony import */ var _change_event_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./change-event-buffer */ \"./dist/es/change-event-buffer.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _rx_document_prototype_merge__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rx-document-prototype-merge */ \"./dist/es/rx-document-prototype-merge.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _replication_protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./replication-protocol */ \"./dist/es/replication-protocol/conflicts.js\");\n/* harmony import */ var _incremental_write__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./incremental-write */ \"./dist/es/incremental-write.js\");\n/* harmony import */ var _rx_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-document */ \"./dist/es/rx-document.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nvar RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = _query_cache__WEBPACK_IMPORTED_MODULE_1__.defaultCacheReplacementPolicy, statics = {}, conflictHandler = _replication_protocol__WEBPACK_IMPORTED_MODULE_2__.defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = (0,_query_cache__WEBPACK_IMPORTED_MODULE_1__.createQueryCache)();\n    this.$ = {};\n    this._changeEventBuffer = {};\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    this.storageInstance = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_3__.getWrappedStorageInstance)(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new _incremental_write__WEBPACK_IMPORTED_MODULE_4__.IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => (0,_rx_document__WEBPACK_IMPORTED_MODULE_5__.beforeDocumentUpdateWrite)(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    this.$ = this.database.eventBulks$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.filter)(changeEventBulk => changeEventBulk.collectionName === this.name), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.mergeMap)(changeEventBulk => changeEventBulk.events));\n    this._changeEventBuffer = (0,_change_event_buffer__WEBPACK_IMPORTED_MODULE_8__.createChangeEventBuffer)(this.asRxCollection);\n    this._docCache = new _doc_cache__WEBPACK_IMPORTED_MODULE_9__.DocumentCache(this.schema.primaryPath, this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.filter)(cE => !cE.isLocal)), docData => (0,_rx_document_prototype_merge__WEBPACK_IMPORTED_MODULE_10__.createNewRxDocument)(this.asRxCollection, docData));\n\n    /**\n     * Instead of resolving the EventBulk array here and spit it into\n     * single events, we should fully work with event bulks internally\n     * to save performance.\n     */\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events.map(ev => (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_3__.storageChangeEventToRxChangeEvent)(false, ev, this)),\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n\n    /**\n     * Resolve the conflict tasks\n     * of the RxStorageInstance\n     */\n    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe(task => {\n      this.conflictHandler(task.input, task.context).then(output => {\n        this.storageInstance.resolveConflictResultionTask({\n          id: task.id,\n          output\n        });\n      });\n    }));\n    return _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID;\n  }\n\n  // overwritte by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.pluginMissing)('migration');\n  };\n  _proto.getDataMigrator = function getDataMigrator() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.pluginMissing)('migration');\n  };\n  _proto.migrate = function migrate(batchSize = 10) {\n    return this.getDataMigrator().migrate(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getDataMigrator().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_3__.throwIfIsStorageWriteError)(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.ensureNotFalsy)(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n    var useDocs = docsData.map(docData => {\n      var useDocData = (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__.fillObjectDataBeforeInsert)(this.schema, docData);\n      return useDocData;\n    });\n    var docs = this.hasHooks('pre', 'insert') ? await Promise.all(useDocs.map(doc => {\n      return this._runHooks('pre', 'insert', doc).then(() => {\n        return doc;\n      });\n    })) : useDocs;\n    var docsMap = new Map();\n    var insertRows = docs.map(doc => {\n      docsMap.set(doc[primaryPath], doc);\n      var row = {\n        document: doc\n      };\n      return row;\n    });\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    // create documents\n    var rxDocuments = Object.values(results.success).map(writtenDocData => this._docCache.getCachedRxDocument(writtenDocData));\n    if (this.hasHooks('post', 'insert')) {\n      await Promise.all(rxDocuments.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return {\n      success: rxDocuments,\n      error: Object.values(results.error)\n    };\n  };\n  _proto.bulkRemove = async function bulkRemove(ids) {\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (ids.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap = await this.findByIds(ids).exec();\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.flatClone)(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var successIds = Object.keys(results.success);\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    var rxDocuments = successIds.map(id => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.getFromMapOrThrow)(rxDocumentMap, id));\n    return {\n      success: rxDocuments,\n      error: Object.values(results.error)\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__.fillObjectDataBeforeInsert)(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var ret = insertResult.success.slice(0);\n    var updatedDocs = await Promise.all(insertResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('VD2', {\n          collection: this.name,\n          writeError: error\n        });\n      }\n      var id = error.documentId;\n      var writeData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.getFromMapOrThrow)(useJsonByDocId, id);\n      var docDataInDb = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.ensureNotFalsy)(error.documentInDb);\n      var doc = this._docCache.getCachedRxDocument(docDataInDb);\n      var newDoc = await doc.incrementalModify(() => writeData);\n      return newDoc;\n    }));\n    ret = ret.concat(updatedDocs);\n    return ret;\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = function upsert(json) {\n    return this.bulkUpsert([json]).then(result => result[0]);\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    var useJson = (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__.fillObjectDataBeforeInsert)(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('COL5', {\n        queryObj\n      });\n    }\n    if (!queryObj) {\n      queryObj = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__._getDefaultQuery)();\n    }\n    var query = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__.createRxQuery)('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n    if (typeof queryObj === 'string') {\n      query = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__.createRxQuery)('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__._getDefaultQuery)();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritte\n      if (queryObj.limit) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('QU6');\n      }\n      queryObj.limit = 1;\n      query = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__.createRxQuery)('findOne', queryObj, this);\n    }\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxTypeError)('COL6', {\n        queryObj\n      });\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    if (!queryObj) {\n      queryObj = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__._getDefaultQuery)();\n    }\n    var query = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__.createRxQuery)('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = (0,_rx_query__WEBPACK_IMPORTED_MODULE_17__.createRxQuery)('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.pluginMissing)('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.pluginMissing)('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.pluginMissing)('crdt');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxTypeError)('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxTypeError)('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_16__.newRxError)('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_11__.promiseSeries)(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is destroyed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.destroy = function destroy() {\n    if (this.destroyed) {\n      return _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * Settings destroyed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.destroyed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn()))).then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return (0,_hooks__WEBPACK_IMPORTED_MODULE_18__.runAsyncPluginHooks)('postDestroyRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.destroy();\n    await (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__.removeCollectionStorages)(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.filter)(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.filter)(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.filter)(cE => cE.operation === 'DELETE'));\n    }\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxCollectionBase;\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_19__.ucfirst)(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nfunction createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = _query_cache__WEBPACK_IMPORTED_MODULE_1__.defaultCacheReplacementPolicy,\n  conflictHandler = _replication_protocol__WEBPACK_IMPORTED_MODULE_2__.defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password\n  };\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_18__.runPluginHooks)('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_14__.createRxCollectionStorageInstance)(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      (0,_hooks__WEBPACK_IMPORTED_MODULE_18__.runPluginHooks)('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nfunction isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n//# sourceMappingURL=rx-collection.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-collection.js?");

/***/ }),

/***/ "./dist/es/rx-database-internal-store.js":
/*!***********************************************!*\
  !*** ./dist/es/rx-database-internal-store.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"INTERNAL_CONTEXT_COLLECTION\": () => (/* binding */ INTERNAL_CONTEXT_COLLECTION),\n/* harmony export */   \"INTERNAL_CONTEXT_STORAGE_TOKEN\": () => (/* binding */ INTERNAL_CONTEXT_STORAGE_TOKEN),\n/* harmony export */   \"INTERNAL_STORE_SCHEMA\": () => (/* binding */ INTERNAL_STORE_SCHEMA),\n/* harmony export */   \"INTERNAL_STORE_SCHEMA_TITLE\": () => (/* binding */ INTERNAL_STORE_SCHEMA_TITLE),\n/* harmony export */   \"STORAGE_TOKEN_DOCUMENT_ID\": () => (/* binding */ STORAGE_TOKEN_DOCUMENT_ID),\n/* harmony export */   \"STORAGE_TOKEN_DOCUMENT_KEY\": () => (/* binding */ STORAGE_TOKEN_DOCUMENT_KEY),\n/* harmony export */   \"_collectionNamePrimary\": () => (/* binding */ _collectionNamePrimary),\n/* harmony export */   \"addConnectedStorageToCollection\": () => (/* binding */ addConnectedStorageToCollection),\n/* harmony export */   \"ensureStorageTokenDocumentExists\": () => (/* binding */ ensureStorageTokenDocumentExists),\n/* harmony export */   \"getAllCollectionDocuments\": () => (/* binding */ getAllCollectionDocuments),\n/* harmony export */   \"getPrimaryKeyOfInternalDocument\": () => (/* binding */ getPrimaryKeyOfInternalDocument)\n/* harmony export */ });\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n\n\n\n\nvar INTERNAL_CONTEXT_COLLECTION = 'collection';\nvar INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nvar INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nvar INTERNAL_STORE_SCHEMA = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__.fillWithDefaultSettings)({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nfunction getPrimaryKeyOfInternalDocument(key, context) {\n  return (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__.getComposedPrimaryKeyOfDocumentData)(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nasync function getAllCollectionDocuments(storageStatics, storageInstance) {\n  var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nvar STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nvar STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nasync function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.randomCouchString)(10);\n  var passwordHash = rxDatabase.password ? rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getDefaultRxDocumentMeta)(),\n    _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getDefaultRevision)(),\n    _attachments: {}\n  };\n  var writeResult = await rxDatabase.internalStore.bulkWrite([{\n    document: docData\n  }], 'internal-add-storage-token');\n  if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {\n    return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);\n  if (error.isError && error.status === 409) {\n    var conflictError = error;\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_4__.newRxError)('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(storageTokenDocInDb);\n  }\n  throw error;\n}\nasync function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__.getSingleDocument)(collection.database.internalStore, collectionDocId);\n    var saveData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.clone)((0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(collectionDoc));\n    /**\n     * Add array if not exist for backwards compatibility\n     * TODO remove this in 2023\n     */\n    if (!saveData.data.connectedStorages) {\n      saveData.data.connectedStorages = [];\n    }\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_5__.writeSingle)(collection.database.internalStore, {\n        previous: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.ensureNotFalsy)(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!(0,_rx_error__WEBPACK_IMPORTED_MODULE_4__.isBulkWriteConflictError)(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nfunction _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n//# sourceMappingURL=rx-database-internal-store.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-database-internal-store.js?");

/***/ }),

/***/ "./dist/es/rx-database.js":
/*!********************************!*\
  !*** ./dist/es/rx-database.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxDatabaseBase\": () => (/* binding */ RxDatabaseBase),\n/* harmony export */   \"createRxDatabase\": () => (/* binding */ createRxDatabase),\n/* harmony export */   \"createRxDatabaseStorageInstance\": () => (/* binding */ createRxDatabaseStorageInstance),\n/* harmony export */   \"dbCount\": () => (/* binding */ dbCount),\n/* harmony export */   \"ensureNoStartupErrors\": () => (/* binding */ ensureNoStartupErrors),\n/* harmony export */   \"isRxDatabase\": () => (/* binding */ isRxDatabase),\n/* harmony export */   \"isRxDatabaseFirstTimeInstantiated\": () => (/* binding */ isRxDatabaseFirstTimeInstantiated),\n/* harmony export */   \"removeRxDatabase\": () => (/* binding */ removeRxDatabase)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var custom_idle_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! custom-idle-queue */ \"./node_modules/custom-idle-queue/dist/es/index.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-hash.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_schema__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rx-schema */ \"./dist/es/rx-schema.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _rx_collection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rx-collection */ \"./dist/es/rx-collection.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! oblivious-set */ \"./node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rx-database-internal-store */ \"./dist/es/rx-database-internal-store.js\");\n/* harmony import */ var _rx_collection_helper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./rx-collection-helper */ \"./dist/es/rx-collection-helper.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * stores the used database names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DB_COUNT = 0;\nvar RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount) {\n    this.idleQueue = new custom_idle_queue__WEBPACK_IMPORTED_MODULE_1__.IdleQueue();\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.collections = {};\n    this.eventBulks$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n    this.observable$ = this.eventBulks$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.mergeMap)(changeEventBulk => changeEventBulk.events));\n    this.storageToken = _plugins_utils__WEBPACK_IMPORTED_MODULE_4__.PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = _plugins_utils__WEBPACK_IMPORTED_MODULE_4__.PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new oblivious_set__WEBPACK_IMPORTED_MODULE_5__.ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_6__.getWrappedStorageInstance)(this.asRxDatabase, internalStore, _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.ensureStorageTokenDocumentExists)(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n\n    // emit into own stream\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_6__.getSingleDocument)(this.internalStore, (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.getPrimaryKeyOfInternalDocument)((0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__._collectionNamePrimary)(name, schema), _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_6__.flatCloneDocWithMeta)(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    Object.entries(collectionCreators).forEach(([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = (0,_rx_schema__WEBPACK_IMPORTED_MODULE_9__.createRxSchema)(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__._collectionNamePrimary)(name, rxJsonSchema);\n      var collectionDocData = {\n        id: (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.getPrimaryKeyOfInternalDocument)(collectionNameWithVersion, _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.getDefaultRxDocumentMeta)(),\n        _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.getDefaultRevision)(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_11__.flatClone)(args);\n      hookData.database = this;\n      hookData.name = name;\n      (0,_hooks__WEBPACK_IMPORTED_MODULE_12__.runPluginHooks)('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    });\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    Object.entries(putDocsResult.error).forEach(([_id, error]) => {\n      if (error.status !== 409) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.ensureNotFalsy)(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== schema.hash) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.ensureNotFalsy)(jsonSchemas[collectionName])\n        });\n      }\n    });\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await (0,_rx_collection__WEBPACK_IMPORTED_MODULE_14__.createRxCollection)(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_15__.pluginMissing)('migration');\n  }\n\n  /**\n   * destroys the database-instance and all collections\n   */;\n  _proto.destroy = async function destroy() {\n    if (this.destroyed) {\n      return _plugins_utils__WEBPACK_IMPORTED_MODULE_4__.PROMISE_RESOLVE_FALSE;\n    }\n\n    // settings destroyed = true must be the first thing to do.\n    this.destroyed = true;\n    await (0,_hooks__WEBPACK_IMPORTED_MODULE_12__.runAsyncPluginHooks)('preDestroyRxDatabase', this);\n    /**\n     * Complete the event stream\n     * to stop all subscribers who forgot to unsubscribe.\n     */\n    this.eventBulks$.complete();\n    DB_COUNT--;\n    this._subs.map(sub => sub.unsubscribe());\n\n    /**\n     * Destroying the pseudo instance will throw\n     * because stulff is missing\n     * TODO we should not need the pseudo instance on runtime.\n     * we should generate the property list on build time.\n     */\n    if (this.name === 'pseudoInstance') {\n      return _plugins_utils__WEBPACK_IMPORTED_MODULE_4__.PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * First wait until the database is idle\n     */\n    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn())))\n    // destroy all collections\n    .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.destroy())))\n    // destroy internal storage instances\n    .then(() => this.internalStore.close())\n    // remove combination from USED_COMBINATIONS-map\n    .then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxDatabaseBase;\n}();\n\n/**\n * checks if an instance with same name and adapter already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name) {\n  if (!USED_DATABASE_NAMES.has(name)) {\n    return;\n  } else {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DB8', {\n      name,\n      link: 'https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nasync function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: _rx_storage_helper__WEBPACK_IMPORTED_MODULE_6__.INTERNAL_STORAGE_NAME,\n    schema: _rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password\n  });\n  return internalStore;\n}\nfunction createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = false,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = _plugins_utils__WEBPACK_IMPORTED_MODULE_16__.defaultHashSha256\n}) {\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_12__.runPluginHooks)('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  // check if combination already used\n  if (!ignoreDuplicate) {\n    throwIfDatabaseNameUsed(name);\n  }\n  USED_DATABASE_NAMES.add(name);\n  var databaseInstanceToken = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_17__.randomCouchString)(10);\n  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password)\n  /**\n   * Creating the internal store might fail\n   * if some RxStorage wrapper is used that does some checks\n   * and then throw.\n   * In that case we have to properly clean up the database.\n   */.catch(err => {\n    USED_DATABASE_NAMES.delete(name);\n    throw err;\n  }).then(storageInstance => {\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);\n    return (0,_hooks__WEBPACK_IMPORTED_MODULE_12__.runAsyncPluginHooks)('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    }).then(() => rxDatabase);\n  });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nasync function removeRxDatabase(databaseName, storage) {\n  var databaseInstanceToken = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_17__.randomCouchString)(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);\n  var collectionDocs = await (0,_rx_database_internal_store__WEBPACK_IMPORTED_MODULE_7__.getAllCollectionDocuments)(storage.statics, dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => (0,_rx_collection_helper__WEBPACK_IMPORTED_MODULE_18__.removeCollectionStorages)(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));\n  await (0,_hooks__WEBPACK_IMPORTED_MODULE_12__.runAsyncPluginHooks)('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nfunction isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nfunction dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nasync function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nasync function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n//# sourceMappingURL=rx-database.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-database.js?");

/***/ }),

/***/ "./dist/es/rx-document-prototype-merge.js":
/*!************************************************!*\
  !*** ./dist/es/rx-document-prototype-merge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createNewRxDocument\": () => (/* binding */ createNewRxDocument),\n/* harmony export */   \"getDocumentOrmPrototype\": () => (/* binding */ getDocumentOrmPrototype),\n/* harmony export */   \"getDocumentPrototype\": () => (/* binding */ getDocumentPrototype),\n/* harmony export */   \"getRxDocumentConstructor\": () => (/* binding */ getRxDocumentConstructor)\n/* harmony export */ });\n/* harmony import */ var _rx_document__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-document */ \"./dist/es/rx-document.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\n\n\n\nvar constructorForCollection = new WeakMap();\nfunction getDocumentPrototype(rxCollection) {\n  var schemaProto = rxCollection.schema.getDocumentPrototype();\n  var ormProto = getDocumentOrmPrototype(rxCollection);\n  var baseProto = _rx_document__WEBPACK_IMPORTED_MODULE_0__.basePrototype;\n  var proto = {};\n  [schemaProto, ormProto, baseProto].forEach(obj => {\n    var props = Object.getOwnPropertyNames(obj);\n    props.forEach(key => {\n      var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n      /**\n       * When enumerable is true, it will show on console.dir(instance)\n       * To not pollute the output, only getters and methods are enumerable\n       */\n      var enumerable = true;\n      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n      if (typeof desc.value === 'function') {\n        // when getting a function, we automatically do a .bind(this)\n        Object.defineProperty(proto, key, {\n          get() {\n            return desc.value.bind(this);\n          },\n          enumerable,\n          configurable: false\n        });\n      } else {\n        desc.enumerable = enumerable;\n        desc.configurable = false;\n        if (desc.writable) desc.writable = false;\n        Object.defineProperty(proto, key, desc);\n      }\n    });\n  });\n  return proto;\n}\nfunction getRxDocumentConstructor(rxCollection) {\n  if (!constructorForCollection.has(rxCollection)) {\n    var ret = (0,_rx_document__WEBPACK_IMPORTED_MODULE_0__.createRxDocumentConstructor)(getDocumentPrototype(rxCollection));\n    constructorForCollection.set(rxCollection, ret);\n  }\n  return constructorForCollection.get(rxCollection);\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nfunction createNewRxDocument(rxCollection, docData) {\n  var doc = (0,_rx_document__WEBPACK_IMPORTED_MODULE_0__.createWithConstructor)(getRxDocumentConstructor(rxCollection), rxCollection, _overwritable__WEBPACK_IMPORTED_MODULE_1__.overwritable.deepFreezeWhenDevMode(docData));\n  rxCollection._runHooksSync('post', 'create', docData, doc);\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_2__.runPluginHooks)('postCreateRxDocument', doc);\n  return doc;\n}\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nfunction getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection.methods).forEach(([k, v]) => {\n    proto[k] = v;\n  });\n  return proto;\n}\n//# sourceMappingURL=rx-document-prototype-merge.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-document-prototype-merge.js?");

/***/ }),

/***/ "./dist/es/rx-document.js":
/*!********************************!*\
  !*** ./dist/es/rx-document.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"basePrototype\": () => (/* binding */ basePrototype),\n/* harmony export */   \"beforeDocumentUpdateWrite\": () => (/* binding */ beforeDocumentUpdateWrite),\n/* harmony export */   \"createRxDocumentConstructor\": () => (/* binding */ createRxDocumentConstructor),\n/* harmony export */   \"createWithConstructor\": () => (/* binding */ createWithConstructor),\n/* harmony export */   \"defineGetterSetter\": () => (/* binding */ defineGetterSetter),\n/* harmony export */   \"isRxDocument\": () => (/* binding */ isRxDocument)\n/* harmony export */ });\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/startWith.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object-dot-prop.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _rx_change_event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-change-event */ \"./dist/es/rx-change-event.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_storage_helper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rx-storage-helper */ \"./dist/es/rx-storage-helper.js\");\n/* harmony import */ var _incremental_write__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./incremental-write */ \"./dist/es/incremental-write.js\");\n\n\n\n\n\n\n\n\n\nvar basePrototype = {\n  get primaryPath() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.collection.schema.primaryPath;\n  },\n  get primary() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data[_this.primaryPath];\n  },\n  get revision() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._rev;\n  },\n  get deleted$() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(d => d._deleted));\n  },\n  get deleted() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._deleted;\n  },\n  getLatest() {\n    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n    return this.collection._docCache.getCachedRxDocument(latestDocData);\n  },\n  /**\n   * returns the observable which emits the plain-data of this document\n   */\n  get $() {\n    var _this = this;\n    return _this.collection.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(changeEvent => !changeEvent.isLocal), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(changeEvent => changeEvent.documentId === this.primary), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(changeEvent => (0,_rx_change_event__WEBPACK_IMPORTED_MODULE_2__.getDocumentDataOfRxChangeEvent)(changeEvent)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(_this.collection._docCache.getLatestDocumentData(this.primary)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(docData => this.collection._docCache.getCachedRxDocument(docData)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.shareReplay)(_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  /**\n   * returns observable of the value of the given path\n   */\n  get$(path) {\n    if (_overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable.isDevMode()) {\n      if (path.includes('.item.')) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC1', {\n          path\n        });\n      }\n      if (path === this.primaryPath) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC2');\n      }\n\n      // final fields cannot be modified and so also not observed\n      if (this.collection.schema.finalFields.includes(path)) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC3', {\n          path\n        });\n      }\n      var schemaObj = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_9__.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path);\n      if (!schemaObj) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC4', {\n          path\n        });\n      }\n    }\n    return this.$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_0__.map)(data => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.getProperty)(data, path)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.distinctUntilChanged)());\n  },\n  /**\n   * populate the given path\n   */\n  populate(path) {\n    var schemaObj = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_9__.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path);\n    var value = this.get(path);\n    if (!value) {\n      return _plugins_utils__WEBPACK_IMPORTED_MODULE_11__.PROMISE_RESOLVE_NULL;\n    }\n    if (!schemaObj) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC5', {\n        path\n      });\n    }\n    if (!schemaObj.ref) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC6', {\n        path,\n        schemaObj\n      });\n    }\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n    if (!refCollection) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC7', {\n        ref: schemaObj.ref,\n        path,\n        schemaObj\n      });\n    }\n    if (schemaObj.type === 'array') {\n      return refCollection.findByIds(value).exec().then(res => {\n        var valuesIterator = res.values();\n        return Array.from(valuesIterator);\n      });\n    } else {\n      return refCollection.findOne(value).exec();\n    }\n  },\n  /**\n   * get data by objectPath\n   */\n  get(objPath) {\n    if (!this._data) return undefined;\n    var valueObj = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.getProperty)(this._data, objPath);\n\n    // direct return if array or non-object\n    if (typeof valueObj !== 'object' || Array.isArray(valueObj)) {\n      return _overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(valueObj);\n    }\n\n    /**\n     * TODO find a way to deep-freeze together with defineGetterSetter\n     * so we do not have to do a deep clone here.\n     */\n    valueObj = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.clone)(valueObj);\n    defineGetterSetter(this.collection.schema, valueObj, objPath, this);\n    return valueObj;\n  },\n  toJSON(withMetaFields = false) {\n    if (!withMetaFields) {\n      var data = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.flatClone)(this._data);\n      delete data._rev;\n      delete data._attachments;\n      delete data._deleted;\n      delete data._meta;\n      return _overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(data);\n    } else {\n      return _overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable.deepFreezeWhenDevMode(this._data);\n    }\n  },\n  toMutableJSON(withMetaFields = false) {\n    return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.clone)(this.toJSON(withMetaFields));\n  },\n  /**\n   * updates document\n   * @overwritten by plugin (optional)\n   * @param updateObj mongodb-like syntax\n   */\n  update(_updateObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('update');\n  },\n  incrementalUpdate(_updateObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('update');\n  },\n  updateCRDT(_updateObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('crdt');\n  },\n  putAttachment() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');\n  },\n  getAttachment() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');\n  },\n  allAttachments() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');\n  },\n  get allAttachments$() {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_13__.pluginMissing)('attachments');\n  },\n  async modify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    var oldData = this._data;\n    var newData = await (0,_incremental_write__WEBPACK_IMPORTED_MODULE_14__.modifierFromPublicToInternal)(mutationFunction)(oldData);\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * runs an incremental update over the document\n   * @param function that takes the document-data and returns a new data-object\n   */\n  incrementalModify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    return this.collection.incrementalWriteQueue.addWrite(this._data, (0,_incremental_write__WEBPACK_IMPORTED_MODULE_14__.modifierFromPublicToInternal)(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));\n  },\n  patch(patch) {\n    var oldData = this._data;\n    var newData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.clone)(oldData);\n    Object.entries(patch).forEach(([k, v]) => {\n      newData[k] = v;\n    });\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * patches the given properties\n   */\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  /**\n   * saves the new document-data\n   * and handles the events\n   */\n  async _saveData(newData, oldData) {\n    newData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.flatClone)(newData);\n\n    // deleted documents cannot be changed\n    if (this._data._deleted) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    }\n    await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n    var writeResult = await this.collection.storageInstance.bulkWrite([{\n      previous: oldData,\n      document: newData\n    }], 'rx-document-save-data');\n    var isError = writeResult.error[this.primary];\n    (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_15__.throwIfIsStorageWriteError)(this.collection, this.primary, newData, isError);\n    await this.collection._runHooks('post', 'save', newData, this);\n    return this.collection._docCache.getCachedRxDocument((0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.getFromObjectOrThrow)(writeResult.success, this.primary));\n  },\n  /**\n   * Remove the document.\n   * Notice that there is no hard delete,\n   * instead deleted documents get flagged with _deleted=true.\n   */\n  remove() {\n    var collection = this.collection;\n    if (this.deleted) {\n      return Promise.reject((0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC13', {\n        document: this,\n        id: this.primary\n      }));\n    }\n    var deletedData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.flatClone)(this._data);\n    var removedDocData;\n    return collection._runHooks('pre', 'remove', deletedData, this).then(async () => {\n      deletedData._deleted = true;\n      var writeResult = await collection.storageInstance.bulkWrite([{\n        previous: this._data,\n        document: deletedData\n      }], 'rx-document-remove');\n      var isError = writeResult.error[this.primary];\n      (0,_rx_storage_helper__WEBPACK_IMPORTED_MODULE_15__.throwIfIsStorageWriteError)(collection, this.primary, deletedData, isError);\n      return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_12__.getFromObjectOrThrow)(writeResult.success, this.primary);\n    }).then(removed => {\n      removedDocData = removed;\n      return this.collection._runHooks('post', 'remove', deletedData, this);\n    }).then(() => {\n      return this.collection._docCache.getCachedRxDocument(removedDocData);\n    });\n  },\n  incrementalRemove() {\n    return this.incrementalModify(async docData => {\n      await this.collection._runHooks('pre', 'remove', docData, this);\n      docData._deleted = true;\n      return docData;\n    }).then(async newDoc => {\n      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n      return newDoc;\n    });\n  },\n  destroy() {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_8__.newRxError)('DOC14');\n  }\n};\nfunction createRxDocumentConstructor(proto = basePrototype) {\n  var constructor = function RxDocumentConstructor(collection, docData) {\n    this.collection = collection;\n\n    // assume that this is always equal to the doc-data in the database\n    this._data = docData;\n\n    /**\n     * because of the prototype-merge,\n     * we can not use the native instanceof operator\n     */\n    this.isInstanceOfRxDocument = true;\n  };\n  constructor.prototype = proto;\n  return constructor;\n}\nfunction defineGetterSetter(schema, valueObj, objPath = '', thisObj = false) {\n  if (valueObj === null) return;\n  var pathProperties = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_9__.getSchemaByObjectPath)(schema.jsonSchema, objPath);\n  if (typeof pathProperties === 'undefined') return;\n  if (pathProperties.properties) pathProperties = pathProperties.properties;\n  Object.keys(pathProperties).forEach(key => {\n    var fullPath = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_16__.trimDots)(objPath + '.' + key);\n\n    // getter - value\n    valueObj.__defineGetter__(key, function () {\n      var _this = thisObj ? thisObj : this;\n      if (!_this.get || typeof _this.get !== 'function') {\n        /**\n         * When an object gets added to the state of a vuejs-component,\n         * it happens that this getter is called with another scope.\n         * To prevent errors, we have to return undefined in this case\n         */\n        return undefined;\n      }\n      var ret = _this.get(fullPath);\n      return ret;\n    });\n    // getter - observable$\n    Object.defineProperty(valueObj, key + '$', {\n      get: function () {\n        var _this = thisObj ? thisObj : this;\n        return _this.get$(fullPath);\n      },\n      enumerable: false,\n      configurable: false\n    });\n    // getter - populate_\n    Object.defineProperty(valueObj, key + '_', {\n      get: function () {\n        var _this = thisObj ? thisObj : this;\n        return _this.populate(fullPath);\n      },\n      enumerable: false,\n      configurable: false\n    });\n    // setter - value\n    valueObj.__defineSetter__(key, function (val) {\n      var _this = thisObj ? thisObj : this;\n      return _this.set(fullPath, val);\n    });\n  });\n}\nfunction createWithConstructor(constructor, collection, jsonData) {\n  var doc = new constructor(collection, jsonData);\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_17__.runPluginHooks)('createRxDocument', doc);\n  return doc;\n}\nfunction isRxDocument(obj) {\n  if (typeof obj === 'undefined') return false;\n  return !!obj.isInstanceOfRxDocument;\n}\nfunction beforeDocumentUpdateWrite(collection, newData, oldData) {\n  /**\n   * Meta values must always be merged\n   * instead of overwritten.\n   * This ensures that different plugins do not overwrite\n   * each others meta properties.\n   */\n  newData._meta = Object.assign({}, oldData._meta, newData._meta);\n\n  // ensure modifications are ok\n  if (_overwritable__WEBPACK_IMPORTED_MODULE_7__.overwritable.isDevMode()) {\n    collection.schema.validateChange(oldData, newData);\n  }\n  return collection._runHooks('pre', 'save', newData);\n}\n//# sourceMappingURL=rx-document.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-document.js?");

/***/ }),

/***/ "./dist/es/rx-error.js":
/*!*****************************!*\
  !*** ./dist/es/rx-error.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxError\": () => (/* binding */ RxError),\n/* harmony export */   \"RxTypeError\": () => (/* binding */ RxTypeError),\n/* harmony export */   \"isBulkWriteConflictError\": () => (/* binding */ isBulkWriteConflictError),\n/* harmony export */   \"newRxError\": () => (/* binding */ newRxError),\n/* harmony export */   \"newRxTypeError\": () => (/* binding */ newRxTypeError),\n/* harmony export */   \"rxStorageWriteErrorToRxError\": () => (/* binding */ rxStorageWriteErrorToRxError)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n\n\n\n/**\n * here we use custom errors with the additional field 'parameters'\n */\n\n\n/**\n * transform an object of parameters to a presentable string\n */\nfunction parametersToString(parameters) {\n  var ret = '';\n  if (Object.keys(parameters).length === 0) return ret;\n  ret += 'Given parameters: {\\n';\n  ret += Object.keys(parameters).map(k => {\n    var paramStr = '[object Object]';\n    try {\n      paramStr = JSON.stringify(parameters[k], (_k, v) => v === undefined ? null : v, 2);\n    } catch (e) {}\n    return k + ':' + paramStr;\n  }).join('\\n');\n  ret += '}';\n  return ret;\n}\nfunction messageForError(message, code, parameters) {\n  return 'RxError (' + code + '):' + '\\n' + message + '\\n' + parametersToString(parameters);\n}\nvar RxError = /*#__PURE__*/function (_Error) {\n  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(RxError, _Error);\n  // always true, use this to detect if its an rxdb-error\n\n  function RxError(code, message, parameters = {}) {\n    var _this;\n    var mes = messageForError(message, code, parameters);\n    _this = _Error.call(this, mes) || this;\n    _this.code = code;\n    _this.message = mes;\n    _this.parameters = parameters;\n    _this.rxdb = true; // tag them as internal\n    return _this;\n  }\n  var _proto = RxError.prototype;\n  _proto.toString = function toString() {\n    return this.message;\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxError, [{\n    key: \"name\",\n    get: function () {\n      return 'RxError (' + this.code + ')';\n    }\n  }, {\n    key: \"typeError\",\n    get: function () {\n      return false;\n    }\n  }]);\n  return RxError;\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Error));\nvar RxTypeError = /*#__PURE__*/function (_TypeError) {\n  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(RxTypeError, _TypeError);\n  // always true, use this to detect if its an rxdb-error\n\n  function RxTypeError(code, message, parameters = {}) {\n    var _this2;\n    var mes = messageForError(message, code, parameters);\n    _this2 = _TypeError.call(this, mes) || this;\n    _this2.code = code;\n    _this2.message = mes;\n    _this2.parameters = parameters;\n    _this2.rxdb = true; // tag them as internal\n    return _this2;\n  }\n  var _proto2 = RxTypeError.prototype;\n  _proto2.toString = function toString() {\n    return this.message;\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxTypeError, [{\n    key: \"name\",\n    get: function () {\n      return 'RxTypeError (' + this.code + ')';\n    }\n  }, {\n    key: \"typeError\",\n    get: function () {\n      return true;\n    }\n  }]);\n  return RxTypeError;\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(TypeError));\nfunction newRxError(code, parameters) {\n  return new RxError(code, _overwritable__WEBPACK_IMPORTED_MODULE_3__.overwritable.tunnelErrorMessage(code), parameters);\n}\nfunction newRxTypeError(code, parameters) {\n  return new RxTypeError(code, _overwritable__WEBPACK_IMPORTED_MODULE_3__.overwritable.tunnelErrorMessage(code), parameters);\n}\n\n/**\n * Returns the error if it is a 409 conflict,\n * return false if it is another error.\n */\nfunction isBulkWriteConflictError(err) {\n  if (err && err.status === 409) {\n    return err;\n  } else {\n    return false;\n  }\n}\nvar STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {\n  409: 'document write conflict',\n  422: 'schema validation error',\n  510: 'attachment data missing'\n};\nfunction rxStorageWriteErrorToRxError(err) {\n  return newRxError('COL20', {\n    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],\n    document: err.documentId,\n    writeError: err\n  });\n}\n//# sourceMappingURL=rx-error.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-error.js?");

/***/ }),

/***/ "./dist/es/rx-query-helper.js":
/*!************************************!*\
  !*** ./dist/es/rx-query-helper.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"normalizeMangoQuery\": () => (/* binding */ normalizeMangoQuery),\n/* harmony export */   \"normalizeQueryRegex\": () => (/* binding */ normalizeQueryRegex)\n/* harmony export */ });\n/* harmony import */ var _query_planner__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query-planner */ \"./dist/es/query-planner.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-regex.js\");\n\n\n\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nfunction normalizeMangoQuery(schema, mangoQuery) {\n  var primaryKey = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_0__.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);\n  mangoQuery = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.flatClone)(mangoQuery);\n\n  // regex normalization must run before deep clone because deep clone cannot clone RegExp\n  if (mangoQuery.selector) {\n    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);\n  }\n  var normalizedMangoQuery = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.clone)(mangoQuery);\n  if (typeof normalizedMangoQuery.skip !== 'number') {\n    normalizedMangoQuery.skip = 0;\n  }\n  if (!normalizedMangoQuery.selector) {\n    normalizedMangoQuery.selector = {};\n  } else {\n    normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n    /**\n     * In mango query, it is possible to have an\n     * equals comparison by directly assigning a value\n     * to a property, without the '$eq' operator.\n     * Like:\n     * selector: {\n     *   foo: 'bar'\n     * }\n     * For normalization, we have to normalize this\n     * so our checks can perform properly.\n     *\n     *\n     * TODO this must work recursive with nested queries that\n     * contain multiple selectors via $and or $or etc.\n     */\n    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n      if (typeof matcher !== 'object' || matcher === null) {\n        normalizedMangoQuery.selector[field] = {\n          $eq: matcher\n        };\n      }\n    });\n  }\n\n  /**\n   * Ensure that if an index is specified,\n   * the primaryKey is inside of it.\n   */\n  if (normalizedMangoQuery.index) {\n    var indexAr = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.toArray)(normalizedMangoQuery.index);\n    if (!indexAr.includes(primaryKey)) {\n      indexAr.push(primaryKey);\n    }\n    normalizedMangoQuery.index = indexAr;\n  }\n\n  /**\n   * To ensure a deterministic sorting,\n   * we have to ensure the primary key is always part\n   * of the sort query.\n   * Primary sorting is added as last sort parameter,\n   * similar to how we add the primary key to indexes that do not have it.\n   *\n   */\n  if (!normalizedMangoQuery.sort) {\n    /**\n     * If no sort is given at all,\n     * we can assume that the user does not care about sort order at al.\n     *\n     * we cannot just use the primary key as sort parameter\n     * because it would likely cause the query to run over the primary key index\n     * which has a bad performance in most cases.\n     */\n    if (normalizedMangoQuery.index) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.index.map(field => {\n        return {\n          [field]: 'asc'\n        };\n      });\n    } else {\n      /**\n       * Find the index that best matches the fields with the logical operators\n       */\n      if (schema.indexes) {\n        var fieldsWithLogicalOperator = new Set();\n        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n          var hasLogical = false;\n          if (typeof matcher === 'object' && matcher !== null) {\n            hasLogical = !!Object.keys(matcher).find(operator => _query_planner__WEBPACK_IMPORTED_MODULE_3__.LOGICAL_OPERATORS.has(operator));\n          } else {\n            hasLogical = true;\n          }\n          if (hasLogical) {\n            fieldsWithLogicalOperator.add(field);\n          }\n        });\n        var currentFieldsAmount = -1;\n        var currentBestIndexForSort;\n        schema.indexes.forEach(index => {\n          var useIndex = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.isMaybeReadonlyArray)(index) ? index : [index];\n          var firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {\n            currentFieldsAmount = firstWrongIndex;\n            currentBestIndexForSort = useIndex;\n          }\n        });\n        if (currentBestIndexForSort) {\n          normalizedMangoQuery.sort = currentBestIndexForSort.map(field => {\n            return {\n              [field]: 'asc'\n            };\n          });\n        }\n      }\n\n      /**\n       * Fall back to the primary key as sort order\n       * if no better one has been found\n       */\n      if (!normalizedMangoQuery.sort) {\n        normalizedMangoQuery.sort = [{\n          [primaryKey]: 'asc'\n        }];\n      }\n    }\n  } else {\n    var isPrimaryInSort = normalizedMangoQuery.sort.find(p => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.firstPropertyNameOfObject)(p) === primaryKey);\n    if (!isPrimaryInSort) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n      normalizedMangoQuery.sort.push({\n        [primaryKey]: 'asc'\n      });\n    }\n  }\n  return normalizedMangoQuery;\n}\n\n/**\n * @recursive\n * @mutates the input so that we do not have to deep clone\n */\nfunction normalizeQueryRegex(selector) {\n  if (typeof selector !== 'object' || selector === null) {\n    return selector;\n  }\n  var keys = Object.keys(selector);\n  var ret = {};\n  keys.forEach(key => {\n    var value = selector[key];\n    if (key === '$regex' && value instanceof RegExp) {\n      var parsed = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.parseRegex)(value);\n      ret.$regex = parsed.pattern;\n      ret.$options = parsed.flags;\n    } else if (Array.isArray(value)) {\n      ret[key] = value.map(item => normalizeQueryRegex(item));\n    } else {\n      ret[key] = normalizeQueryRegex(value);\n    }\n  });\n  return ret;\n}\n//# sourceMappingURL=rx-query-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-query-helper.js?");

/***/ }),

/***/ "./dist/es/rx-query-mingo.js":
/*!***********************************!*\
  !*** ./dist/es/rx-query-mingo.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getMingoQuery\": () => (/* binding */ getMingoQuery)\n/* harmony export */ });\n/* harmony import */ var mingo_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mingo/core */ \"./node_modules/mingo/es/core.js\");\n/* harmony import */ var mingo_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mingo/query */ \"./node_modules/mingo/es/query.js\");\n/* harmony import */ var mingo_operators_pipeline_project__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mingo/operators/pipeline/project */ \"./node_modules/mingo/es/operators/pipeline/project.js\");\n/* harmony import */ var mingo_operators_pipeline_sort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mingo/operators/pipeline/sort */ \"./node_modules/mingo/es/operators/pipeline/sort.js\");\n/* harmony import */ var mingo_operators_query_logical_and__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mingo/operators/query/logical/and */ \"./node_modules/mingo/es/operators/query/logical/and.js\");\n/* harmony import */ var mingo_operators_query_logical_not__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mingo/operators/query/logical/not */ \"./node_modules/mingo/es/operators/query/logical/not.js\");\n/* harmony import */ var mingo_operators_query_logical_or__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mingo/operators/query/logical/or */ \"./node_modules/mingo/es/operators/query/logical/or.js\");\n/* harmony import */ var mingo_operators_query_logical_nor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! mingo/operators/query/logical/nor */ \"./node_modules/mingo/es/operators/query/logical/nor.js\");\n/* harmony import */ var mingo_operators_query_comparison_eq__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! mingo/operators/query/comparison/eq */ \"./node_modules/mingo/es/operators/query/comparison/eq.js\");\n/* harmony import */ var mingo_operators_query_comparison_ne__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! mingo/operators/query/comparison/ne */ \"./node_modules/mingo/es/operators/query/comparison/ne.js\");\n/* harmony import */ var mingo_operators_query_comparison_gt__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! mingo/operators/query/comparison/gt */ \"./node_modules/mingo/es/operators/query/comparison/gt.js\");\n/* harmony import */ var mingo_operators_query_comparison_gte__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! mingo/operators/query/comparison/gte */ \"./node_modules/mingo/es/operators/query/comparison/gte.js\");\n/* harmony import */ var mingo_operators_query_comparison_lt__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! mingo/operators/query/comparison/lt */ \"./node_modules/mingo/es/operators/query/comparison/lt.js\");\n/* harmony import */ var mingo_operators_query_comparison_lte__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! mingo/operators/query/comparison/lte */ \"./node_modules/mingo/es/operators/query/comparison/lte.js\");\n/* harmony import */ var mingo_operators_query_evaluation_regex__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! mingo/operators/query/evaluation/regex */ \"./node_modules/mingo/es/operators/query/evaluation/regex.js\");\n/* harmony import */ var mingo_operators_query_evaluation_mod__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! mingo/operators/query/evaluation/mod */ \"./node_modules/mingo/es/operators/query/evaluation/mod.js\");\n/* harmony import */ var mingo_operators_query_array_elemMatch__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! mingo/operators/query/array/elemMatch */ \"./node_modules/mingo/es/operators/query/array/elemMatch.js\");\n/* harmony import */ var mingo_operators_query_element_exists__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! mingo/operators/query/element/exists */ \"./node_modules/mingo/es/operators/query/element/exists.js\");\n/* harmony import */ var mingo_operators_query_comparison_nin__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! mingo/operators/query/comparison/nin */ \"./node_modules/mingo/es/operators/query/comparison/nin.js\");\n/* harmony import */ var mingo_operators_query_comparison_in__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! mingo/operators/query/comparison/in */ \"./node_modules/mingo/es/operators/query/comparison/in.js\");\n/* harmony import */ var mingo_operators_query_array_size__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! mingo/operators/query/array/size */ \"./node_modules/mingo/es/operators/query/array/size.js\");\n/* harmony import */ var mingo_operators_query_element_type__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! mingo/operators/query/element/type */ \"./node_modules/mingo/es/operators/query/element/type.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar mingoInitDone = false;\n\n/**\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nfunction getMingoQuery(selector) {\n  if (!mingoInitDone) {\n    (0,mingo_core__WEBPACK_IMPORTED_MODULE_0__.useOperators)(mingo_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.PIPELINE, {\n      $sort: mingo_operators_pipeline_sort__WEBPACK_IMPORTED_MODULE_3__.$sort,\n      $project: mingo_operators_pipeline_project__WEBPACK_IMPORTED_MODULE_2__.$project\n    });\n    (0,mingo_core__WEBPACK_IMPORTED_MODULE_0__.useOperators)(mingo_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.QUERY, {\n      $and: mingo_operators_query_logical_and__WEBPACK_IMPORTED_MODULE_4__.$and,\n      $eq: mingo_operators_query_comparison_eq__WEBPACK_IMPORTED_MODULE_8__.$eq,\n      $elemMatch: mingo_operators_query_array_elemMatch__WEBPACK_IMPORTED_MODULE_16__.$elemMatch,\n      $exists: mingo_operators_query_element_exists__WEBPACK_IMPORTED_MODULE_17__.$exists,\n      $gt: mingo_operators_query_comparison_gt__WEBPACK_IMPORTED_MODULE_10__.$gt,\n      $gte: mingo_operators_query_comparison_gte__WEBPACK_IMPORTED_MODULE_11__.$gte,\n      $in: mingo_operators_query_comparison_in__WEBPACK_IMPORTED_MODULE_19__.$in,\n      $lt: mingo_operators_query_comparison_lt__WEBPACK_IMPORTED_MODULE_12__.$lt,\n      $lte: mingo_operators_query_comparison_lte__WEBPACK_IMPORTED_MODULE_13__.$lte,\n      $ne: mingo_operators_query_comparison_ne__WEBPACK_IMPORTED_MODULE_9__.$ne,\n      $nin: mingo_operators_query_comparison_nin__WEBPACK_IMPORTED_MODULE_18__.$nin,\n      $mod: mingo_operators_query_evaluation_mod__WEBPACK_IMPORTED_MODULE_15__.$mod,\n      $nor: mingo_operators_query_logical_nor__WEBPACK_IMPORTED_MODULE_7__.$nor,\n      $not: mingo_operators_query_logical_not__WEBPACK_IMPORTED_MODULE_5__.$not,\n      $or: mingo_operators_query_logical_or__WEBPACK_IMPORTED_MODULE_6__.$or,\n      $regex: mingo_operators_query_evaluation_regex__WEBPACK_IMPORTED_MODULE_14__.$regex,\n      $size: mingo_operators_query_array_size__WEBPACK_IMPORTED_MODULE_20__.$size,\n      $type: mingo_operators_query_element_type__WEBPACK_IMPORTED_MODULE_21__.$type\n    });\n    mingoInitDone = true;\n  }\n  return new mingo_query__WEBPACK_IMPORTED_MODULE_1__.Query(selector);\n}\n//# sourceMappingURL=rx-query-mingo.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-query-mingo.js?");

/***/ }),

/***/ "./dist/es/rx-query.js":
/*!*****************************!*\
  !*** ./dist/es/rx-query.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxQueryBase\": () => (/* binding */ RxQueryBase),\n/* harmony export */   \"_getDefaultQuery\": () => (/* binding */ _getDefaultQuery),\n/* harmony export */   \"createRxQuery\": () => (/* binding */ createRxQuery),\n/* harmony export */   \"isFindOneByIdQuery\": () => (/* binding */ isFindOneByIdQuery),\n/* harmony export */   \"isRxQuery\": () => (/* binding */ isRxQuery),\n/* harmony export */   \"queryCollection\": () => (/* binding */ queryCollection),\n/* harmony export */   \"tunnelQueryCache\": () => (/* binding */ tunnelQueryCache)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/startWith.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-promise.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _event_reduce__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./event-reduce */ \"./dist/es/event-reduce.js\");\n/* harmony import */ var _query_cache__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./query-cache */ \"./dist/es/query-cache.js\");\n/* harmony import */ var _rx_query_helper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rx-query-helper */ \"./dist/es/rx-query-helper.js\");\n\n\n\n\n\n\n\n\n\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nvar RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used by some plugins\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)();\n    this._lastEnsureEqual = 0;\n    this.other = {};\n    this.uncached = false;\n    this.refCount$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._lastExecStart = 0;\n    this._lastExecEnd = 0;\n    this._ensureEqualQueue = _plugins_utils__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'number') {\n      this._result = {\n        docsData: [],\n        docsMap: new Map(),\n        docsDataMap: new Map(),\n        count: newResultData,\n        docs: [],\n        time: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)()\n      };\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var docsDataMap = new Map();\n    var docsMap = new Map();\n    var docs = newResultData.map(docData => this.collection._docCache.getCachedRxDocument(docData));\n\n    /**\n     * Instead of using the newResultData in the result cache,\n     * we directly use the objects that are stored in the RxDocument\n     * to ensure we do not store the same data twice and fill up the memory.\n     */\n    var docsData = docs.map(doc => {\n      docsDataMap.set(doc.primary, doc._data);\n      docsMap.set(doc.primary, doc);\n      return doc._data;\n    });\n    this._result = {\n      docsData,\n      docsMap,\n      docsDataMap,\n      count: docsData.length,\n      docs,\n      time: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)()\n    };\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = async function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    this._lastExecStart = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)();\n    if (this.op === 'count') {\n      var preparedQuery = this.getPreparedQuery();\n      var result = await this.collection.storageInstance.count(preparedQuery);\n      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU14', {\n          collection: this.collection,\n          queryObj: this.mangoQuery\n        });\n      } else {\n        return result.count;\n      }\n    }\n    if (this.op === 'findByIds') {\n      var ids = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n      var ret = new Map();\n      var mustBeQueried = [];\n      // first try to fill from docCache\n      ids.forEach(id => {\n        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n        if (docData) {\n          if (!docData._deleted) {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(id, doc);\n          }\n        } else {\n          mustBeQueried.push(id);\n        }\n      });\n      // everything which was not in docCache must be fetched from the storage\n      if (mustBeQueried.length > 0) {\n        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n        Object.values(docs).forEach(docData => {\n          var doc = this.collection._docCache.getCachedRxDocument(docData);\n          ret.set(doc.primary, doc);\n        });\n      }\n      return ret;\n    }\n    var docsPromise = queryCollection(this);\n    return docsPromise.then(docs => {\n      this._lastExecEnd = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)();\n      return docs;\n    });\n  }\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    return _ensureEqual(this).then(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.firstValueFrom)(this.$)).then(result => {\n      if (!result && throwIfMissing) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_4__.newRxError)('QU10', {\n          collection: this.collection.name,\n          query: this.mangoQuery,\n          op: this.op\n        });\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_7__.sortObject)({\n      op: this.op,\n      query: this.mangoQuery,\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj, _plugins_utils__WEBPACK_IMPORTED_MODULE_7__.stringifyFilter);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: (0,_rx_query_helper__WEBPACK_IMPORTED_MODULE_8__.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    (0,_hooks__WEBPACK_IMPORTED_MODULE_9__.runPluginHooks)('prePrepareQuery', hookInput);\n    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = function remove() {\n    return this.exec().then(docs => {\n      if (Array.isArray(docs)) {\n        // TODO use a bulk operation instead of running .remove() on each document\n        return Promise.all(docs.map(doc => doc.remove()));\n      } else {\n        return docs.remove();\n      }\n    });\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('update');\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n  _proto.where = function where(_queryObj) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_10__.pluginMissing)('query-builder');\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(changeEvent => !changeEvent.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.startWith)(null),\n        // ensure query results are up to date.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.mergeMap)(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.shareReplay)(_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.distinctUntilChanged)((prev, curr) => {\n          if (prev && prev.time === (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.map)(result => {\n          var useResult = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(result);\n          if (this.op === 'count') {\n            return useResult.count;\n          } else if (this.op === 'findOne') {\n            // findOne()-queries emit RxDocument or null\n            return useResult.docs.length === 0 ? null : useResult.docs[0];\n          } else if (this.op === 'findByIds') {\n            return useResult.docsMap;\n          } else {\n            // find()-queries emit RxDocument[]\n            // Flat copy the array so it won't matter if the user modifies it.\n            return useResult.docs.slice(0);\n          }\n        }));\n        this._$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_17__.merge)(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(() => false)));\n      }\n      return this._$;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n\n      /**\n       * Instead of calling this.getPreparedQuery(),\n       * we have to prepare the query for the query matcher\n       * so that it does not contain modifications from the hooks\n       * like the key compression.\n       */\n      var usePreparedQuery = this.collection.database.storage.statics.prepareQuery(schema, (0,_rx_query_helper__WEBPACK_IMPORTED_MODULE_8__.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery));\n      return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_7__.overwriteGetterForCaching)(this, 'queryMatcher', this.collection.database.storage.statics.getQueryMatcher(schema, usePreparedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxQueryBase;\n}();\nfunction _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nfunction tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nfunction createRxQuery(op, queryObj, collection) {\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_9__.runPluginHooks)('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection\n  });\n  var ret = new RxQueryBase(op, queryObj, collection);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  (0,_query_cache__WEBPACK_IMPORTED_MODULE_18__.triggerCacheReplacement)(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery) {\n  // Optimisation shortcut\n  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {\n    return _plugins_utils__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.now)();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.destroyed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return _plugins_utils__WEBPACK_IMPORTED_MODULE_3__.PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = (0,_event_reduce__WEBPACK_IMPORTED_MODULE_19__.calculateNewResults)(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(newResultData => {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !(0,_plugins_utils__WEBPACK_IMPORTED_MODULE_20__.areRxDocumentArraysEqual)(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensuer findById is used\n * when specific queries are used.\n */\nasync function queryCollection(rxQuery) {\n  var docs = [];\n  var collection = rxQuery.collection;\n\n  /**\n   * Optimizations shortcut.\n   * If query is find-one-document-by-id,\n   * then we do not have to use the slow query() method\n   * but instead can use findDocumentsById()\n   */\n  if (rxQuery.isFindOneByIdQuery) {\n    var docId = rxQuery.isFindOneByIdQuery;\n\n    // first try to fill from docCache\n    var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n    if (!docData) {\n      // otherwise get from storage\n      var docsMap = await collection.storageInstance.findDocumentsById([docId], false);\n      docData = docsMap[docId];\n    }\n    if (docData) {\n      docs.push(docData);\n    }\n  } else {\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var queryResult = await collection.storageInstance.query(preparedQuery);\n    docs = queryResult.documents;\n  }\n  return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nfunction isFindOneByIdQuery(primaryPath, query) {\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nfunction isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}\n//# sourceMappingURL=rx-query.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-query.js?");

/***/ }),

/***/ "./dist/es/rx-schema-helper.js":
/*!*************************************!*\
  !*** ./dist/es/rx-schema-helper.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_CHECKPOINT_SCHEMA\": () => (/* binding */ DEFAULT_CHECKPOINT_SCHEMA),\n/* harmony export */   \"RX_META_SCHEMA\": () => (/* binding */ RX_META_SCHEMA),\n/* harmony export */   \"fillObjectWithDefaults\": () => (/* binding */ fillObjectWithDefaults),\n/* harmony export */   \"fillPrimaryKey\": () => (/* binding */ fillPrimaryKey),\n/* harmony export */   \"fillWithDefaultSettings\": () => (/* binding */ fillWithDefaultSettings),\n/* harmony export */   \"getComposedPrimaryKeyOfDocumentData\": () => (/* binding */ getComposedPrimaryKeyOfDocumentData),\n/* harmony export */   \"getFinalFields\": () => (/* binding */ getFinalFields),\n/* harmony export */   \"getLengthOfPrimaryKey\": () => (/* binding */ getLengthOfPrimaryKey),\n/* harmony export */   \"getPrimaryFieldOfPrimaryKey\": () => (/* binding */ getPrimaryFieldOfPrimaryKey),\n/* harmony export */   \"getPseudoSchemaForVersion\": () => (/* binding */ getPseudoSchemaForVersion),\n/* harmony export */   \"getSchemaByObjectPath\": () => (/* binding */ getSchemaByObjectPath),\n/* harmony export */   \"normalizeRxJsonSchema\": () => (/* binding */ normalizeRxJsonSchema)\n/* harmony export */ });\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-regex.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object-dot-prop.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n\n\n/**\n * Helper function to create a valid RxJsonSchema\n * with a given version.\n */\nfunction getPseudoSchemaForVersion(version, primaryKey) {\n  var pseudoSchema = fillWithDefaultSettings({\n    version,\n    type: 'object',\n    primaryKey: primaryKey,\n    properties: {\n      [primaryKey]: {\n        type: 'string',\n        maxLength: 100\n      }\n    },\n    required: [primaryKey]\n  });\n  return pseudoSchema;\n}\n\n/**\n * Returns the sub-schema for a given path\n */\nfunction getSchemaByObjectPath(rxJsonSchema, path) {\n  var usePath = path;\n  usePath = usePath.replace(_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.REGEX_ALL_DOTS, '.properties.');\n  usePath = 'properties.' + usePath;\n  usePath = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_1__.trimDots)(usePath);\n  var ret = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getProperty)(rxJsonSchema, usePath);\n  return ret;\n}\nfunction fillPrimaryKey(primaryPath, jsonSchema, documentData) {\n  // optimization shortcut.\n  if (typeof jsonSchema.primaryKey === 'string') {\n    return documentData;\n  }\n  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);\n  var existingPrimary = documentData[primaryPath];\n  if (existingPrimary && existingPrimary !== newPrimary) {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DOC19', {\n      args: {\n        documentData,\n        existingPrimary,\n        newPrimary\n      },\n      schema: jsonSchema\n    });\n  }\n  documentData[primaryPath] = newPrimary;\n  return documentData;\n}\nfunction getPrimaryFieldOfPrimaryKey(primaryKey) {\n  if (typeof primaryKey === 'string') {\n    return primaryKey;\n  } else {\n    return primaryKey.key;\n  }\n}\nfunction getLengthOfPrimaryKey(schema) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  var schemaPart = getSchemaByObjectPath(schema, primaryPath);\n  return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.ensureNotFalsy)(schemaPart.maxLength);\n}\n\n/**\n * Returns the composed primaryKey of a document by its data.\n */\nfunction getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {\n  if (typeof jsonSchema.primaryKey === 'string') {\n    return documentData[jsonSchema.primaryKey];\n  }\n  var compositePrimary = jsonSchema.primaryKey;\n  return compositePrimary.fields.map(field => {\n    var value = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.getProperty)(documentData, field);\n    if (typeof value === 'undefined') {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DOC18', {\n        args: {\n          field,\n          documentData\n        }\n      });\n    }\n    return value;\n  }).join(compositePrimary.separator);\n}\n\n/**\n * Normalize the RxJsonSchema.\n * We need this to ensure everything is set up properly\n * and we have the same hash on schemas that represent the same value but\n * have different json.\n *\n * - Orders the schemas attributes by alphabetical order\n * - Adds the primaryKey to all indexes that do not contain the primaryKey\n * - We need this for deterministic sort order on all queries, which is required for event-reduce to work.\n *\n * @return RxJsonSchema - ordered and filled\n */\nfunction normalizeRxJsonSchema(jsonSchema) {\n  var normalizedSchema = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.sortObject)(jsonSchema, true);\n  return normalizedSchema;\n}\n\n/**\n * fills the schema-json with default-settings\n * @return cloned schemaObj\n */\nfunction fillWithDefaultSettings(schemaObj) {\n  schemaObj = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.flatClone)(schemaObj);\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);\n  schemaObj.properties = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.flatClone)(schemaObj.properties);\n\n  // additionalProperties is always false\n  schemaObj.additionalProperties = false;\n\n  // fill with key-compression-state ()\n  if (!schemaObj.hasOwnProperty('keyCompression')) {\n    schemaObj.keyCompression = false;\n  }\n\n  // indexes must be array\n  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];\n\n  // required must be array\n  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n\n  // encrypted must be array\n  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];\n\n  // add _rev\n  schemaObj.properties._rev = {\n    type: 'string',\n    minLength: 1\n  };\n\n  // add attachments\n  schemaObj.properties._attachments = {\n    type: 'object'\n  };\n\n  // add deleted flag\n  schemaObj.properties._deleted = {\n    type: 'boolean'\n  };\n\n  // add meta property\n  schemaObj.properties._meta = RX_META_SCHEMA;\n\n  /**\n   * meta fields are all required\n   */\n  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];\n  schemaObj.required.push('_deleted');\n  schemaObj.required.push('_rev');\n  schemaObj.required.push('_meta');\n  schemaObj.required.push('_attachments');\n\n  // final fields are always required\n  var finalFields = getFinalFields(schemaObj);\n  schemaObj.required = schemaObj.required.concat(finalFields).filter(field => !field.includes('.')).filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique;\n\n  // version is 0 by default\n  schemaObj.version = schemaObj.version || 0;\n\n  /**\n   * Append primary key to indexes that do not contain the primaryKey.\n   * All indexes must have the primaryKey to ensure a deterministic sort order.\n   */\n  if (schemaObj.indexes) {\n    schemaObj.indexes = schemaObj.indexes.map(index => {\n      var arIndex = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.isMaybeReadonlyArray)(index) ? index.slice(0) : [index];\n      if (!arIndex.includes(primaryPath)) {\n        var modifiedIndex = arIndex.slice(0);\n        modifiedIndex.push(primaryPath);\n        return modifiedIndex;\n      }\n      return arIndex;\n    });\n  }\n  return schemaObj;\n}\nvar RX_META_SCHEMA = {\n  type: 'object',\n  properties: {\n    /**\n     * The last-write time.\n     * Unix time in milliseconds.\n     */\n    lwt: {\n      type: 'number',\n      /**\n       * We use 1 as minimum so that the value is never falsy.\n       */\n      minimum: _plugins_utils__WEBPACK_IMPORTED_MODULE_7__.RX_META_LWT_MINIMUM,\n      maximum: 1000000000000000,\n      multipleOf: 0.01\n    }\n  },\n  /**\n   * Additional properties are allowed\n   * and can be used by plugins to set various flags.\n   */\n  additionalProperties: true,\n  required: ['lwt']\n};\n\n/**\n * returns the final-fields of the schema\n * @return field-names of the final-fields\n */\nfunction getFinalFields(jsonSchema) {\n  var ret = Object.keys(jsonSchema.properties).filter(key => jsonSchema.properties[key].final);\n\n  // primary is also final\n  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n  ret.push(primaryPath);\n\n  // fields of composite primary are final\n  if (typeof jsonSchema.primaryKey !== 'string') {\n    jsonSchema.primaryKey.fields.forEach(field => ret.push(field));\n  }\n  return ret;\n}\n\n/**\n * fills all unset fields with default-values if set\n * @hotPath\n */\nfunction fillObjectWithDefaults(rxSchema, obj) {\n  var defaultKeys = Object.keys(rxSchema.defaultValues);\n  for (var i = 0; i < defaultKeys.length; ++i) {\n    var key = defaultKeys[i];\n    if (!obj.hasOwnProperty(key) || typeof obj[key] === 'undefined') {\n      obj[key] = rxSchema.defaultValues[key];\n    }\n  }\n  return obj;\n}\nvar DEFAULT_CHECKPOINT_SCHEMA = {\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string'\n    },\n    lwt: {\n      type: 'number'\n    }\n  },\n  required: ['id', 'lwt'],\n  additionalProperties: false\n};\n//# sourceMappingURL=rx-schema-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-schema-helper.js?");

/***/ }),

/***/ "./dist/es/rx-schema.js":
/*!******************************!*\
  !*** ./dist/es/rx-schema.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxSchema\": () => (/* binding */ RxSchema),\n/* harmony export */   \"createRxSchema\": () => (/* binding */ createRxSchema),\n/* harmony export */   \"getIndexes\": () => (/* binding */ getIndexes),\n/* harmony export */   \"getPreviousVersions\": () => (/* binding */ getPreviousVersions),\n/* harmony export */   \"isRxSchema\": () => (/* binding */ isRxSchema),\n/* harmony export */   \"toTypedRxJsonSchema\": () => (/* binding */ toTypedRxJsonSchema)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object-deep-equal.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hooks */ \"./dist/es/hooks.js\");\n/* harmony import */ var _rx_document__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-document */ \"./dist/es/rx-document.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n\n\n\n\n\n\n\nvar RxSchema = /*#__PURE__*/function () {\n  function RxSchema(jsonSchema, hashFunction) {\n    this.jsonSchema = jsonSchema;\n    this.hashFunction = hashFunction;\n    this.indexes = getIndexes(this.jsonSchema);\n\n    // primary is always required\n    this.primaryPath = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.getPrimaryFieldOfPrimaryKey)(this.jsonSchema.primaryKey);\n    this.finalFields = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.getFinalFields)(this.jsonSchema);\n  }\n  var _proto = RxSchema.prototype;\n  /**\n   * checks if a given change on a document is allowed\n   * Ensures that:\n   * - final fields are not modified\n   * @throws {Error} if not valid\n   */\n  _proto.validateChange = function validateChange(dataBefore, dataAfter) {\n    this.finalFields.forEach(fieldName => {\n      if (!(0,_plugins_utils__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(dataBefore[fieldName], dataAfter[fieldName])) {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_3__.newRxError)('DOC9', {\n          dataBefore,\n          dataAfter,\n          fieldName,\n          schema: this.jsonSchema\n        });\n      }\n    });\n  }\n\n  /**\n   * creates the schema-based document-prototype,\n   * see RxCollection.getDocumentPrototype()\n   */;\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    var proto = {};\n    (0,_rx_document__WEBPACK_IMPORTED_MODULE_4__.defineGetterSetter)(this, proto, '');\n    (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.overwriteGetterForCaching)(this, 'getDocumentPrototype', () => proto);\n    return proto;\n  };\n  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {\n    return (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.getComposedPrimaryKeyOfDocumentData)(this.jsonSchema, documentData);\n  };\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RxSchema, [{\n    key: \"version\",\n    get: function () {\n      return this.jsonSchema.version;\n    }\n  }, {\n    key: \"defaultValues\",\n    get: function () {\n      var values = {};\n      Object.entries(this.jsonSchema.properties).filter(([, v]) => v.hasOwnProperty('default')).forEach(([k, v]) => values[k] = v.default);\n      return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.overwriteGetterForCaching)(this, 'defaultValues', values);\n    }\n\n    /**\n     * @overrides itself on the first call\n     *\n     * TODO this should be a pure function that\n     * caches the hash in a WeakMap.\n     */\n  }, {\n    key: \"hash\",\n    get: function () {\n      return (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.overwriteGetterForCaching)(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));\n    }\n  }]);\n  return RxSchema;\n}();\nfunction getIndexes(jsonSchema) {\n  return (jsonSchema.indexes || []).map(index => (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.isMaybeReadonlyArray)(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nfunction getPreviousVersions(schema) {\n  var version = schema.version ? schema.version : 0;\n  var c = 0;\n  return new Array(version).fill(0).map(() => c++);\n}\nfunction createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {\n  if (runPreCreateHooks) {\n    (0,_hooks__WEBPACK_IMPORTED_MODULE_7__.runPluginHooks)('preCreateRxSchema', jsonSchema);\n  }\n  var useJsonSchema = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.fillWithDefaultSettings)(jsonSchema);\n  useJsonSchema = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_1__.normalizeRxJsonSchema)(useJsonSchema);\n  _overwritable__WEBPACK_IMPORTED_MODULE_8__.overwritable.deepFreezeWhenDevMode(useJsonSchema);\n  var schema = new RxSchema(useJsonSchema, hashFunction);\n  (0,_hooks__WEBPACK_IMPORTED_MODULE_7__.runPluginHooks)('createRxSchema', schema);\n  return schema;\n}\nfunction isRxSchema(obj) {\n  return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nfunction toTypedRxJsonSchema(schema) {\n  return schema;\n}\n//# sourceMappingURL=rx-schema.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-schema.js?");

/***/ }),

/***/ "./dist/es/rx-storage-helper.js":
/*!**************************************!*\
  !*** ./dist/es/rx-storage-helper.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"INTERNAL_STORAGE_NAME\": () => (/* binding */ INTERNAL_STORAGE_NAME),\n/* harmony export */   \"RX_DATABASE_LOCAL_DOCS_STORAGE_NAME\": () => (/* binding */ RX_DATABASE_LOCAL_DOCS_STORAGE_NAME),\n/* harmony export */   \"attachmentWriteDataToNormalData\": () => (/* binding */ attachmentWriteDataToNormalData),\n/* harmony export */   \"categorizeBulkWriteRows\": () => (/* binding */ categorizeBulkWriteRows),\n/* harmony export */   \"ensureRxStorageInstanceParamsAreCorrect\": () => (/* binding */ ensureRxStorageInstanceParamsAreCorrect),\n/* harmony export */   \"flatCloneDocWithMeta\": () => (/* binding */ flatCloneDocWithMeta),\n/* harmony export */   \"getAttachmentSize\": () => (/* binding */ getAttachmentSize),\n/* harmony export */   \"getSingleDocument\": () => (/* binding */ getSingleDocument),\n/* harmony export */   \"getUniqueDeterministicEventKey\": () => (/* binding */ getUniqueDeterministicEventKey),\n/* harmony export */   \"getWrappedStorageInstance\": () => (/* binding */ getWrappedStorageInstance),\n/* harmony export */   \"hasEncryption\": () => (/* binding */ hasEncryption),\n/* harmony export */   \"stackCheckpoints\": () => (/* binding */ stackCheckpoints),\n/* harmony export */   \"storageChangeEventToRxChangeEvent\": () => (/* binding */ storageChangeEventToRxChangeEvent),\n/* harmony export */   \"stripAttachmentsDataFromDocument\": () => (/* binding */ stripAttachmentsDataFromDocument),\n/* harmony export */   \"stripAttachmentsDataFromRow\": () => (/* binding */ stripAttachmentsDataFromRow),\n/* harmony export */   \"throwIfIsStorageWriteError\": () => (/* binding */ throwIfIsStorageWriteError),\n/* harmony export */   \"writeSingle\": () => (/* binding */ writeSingle)\n/* harmony export */ });\n/* harmony import */ var _overwritable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overwritable */ \"./dist/es/overwritable.js\");\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-string.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-time.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-hash.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-revision.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-document.js\");\n/**\n * Helper functions for accessing the RxStorage instances.\n */\n\n\n\n\n\nvar INTERNAL_STORAGE_NAME = '_rxdb_internal';\nvar RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\nasync function getSingleDocument(storageInstance, documentId) {\n  var results = await storageInstance.findDocumentsById([documentId], false);\n  var doc = results[documentId];\n  if (doc) {\n    return doc;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nasync function writeSingle(instance, writeRow, context) {\n  var writeResult = await instance.bulkWrite([writeRow], context);\n  if (Object.keys(writeResult.error).length > 0) {\n    var error = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.firstPropertyValueOfObject)(writeResult.error);\n    throw error;\n  } else {\n    var ret = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.firstPropertyValueOfObject)(writeResult.success);\n    return ret;\n  }\n}\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nfunction stackCheckpoints(checkpoints) {\n  return Object.assign({}, ...checkpoints);\n}\nfunction storageChangeEventToRxChangeEvent(isLocal, rxStorageChangeEvent, rxCollection) {\n  var documentData = rxStorageChangeEvent.documentData;\n  var previousDocumentData = rxStorageChangeEvent.previousDocumentData;\n  var ret = {\n    eventId: rxStorageChangeEvent.eventId,\n    documentId: rxStorageChangeEvent.documentId,\n    collectionName: rxCollection ? rxCollection.name : undefined,\n    startTime: rxStorageChangeEvent.startTime,\n    endTime: rxStorageChangeEvent.endTime,\n    isLocal,\n    operation: rxStorageChangeEvent.operation,\n    documentData: _overwritable__WEBPACK_IMPORTED_MODULE_1__.overwritable.deepFreezeWhenDevMode(documentData),\n    previousDocumentData: _overwritable__WEBPACK_IMPORTED_MODULE_1__.overwritable.deepFreezeWhenDevMode(previousDocumentData)\n  };\n  return ret;\n}\nfunction throwIfIsStorageWriteError(collection, documentId, writeData, error) {\n  if (error) {\n    if (error.status === 409) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('CONFLICT', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else if (error.status === 422) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('VD2', {\n        collection: collection.name,\n        id: documentId,\n        writeError: error,\n        data: writeData\n      });\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n */\nfunction categorizeBulkWriteRows(storageInstance, primaryPath,\n/**\n * Current state of the documents\n * inside of the storage. Used to determine\n * which writes cause conflicts.\n * This can be a Map for better performance\n * but it can also be an object because some storages\n * need to work with something that is JSON-stringify-able\n * and we do not want to transform a big object into a Map\n * each time we use it.\n */\ndocsInDb,\n/**\n * The write rows that are passed to\n * RxStorageInstance().bulkWrite().\n */\nbulkWriteRows, context) {\n  var hasAttachments = !!storageInstance.schema.attachments;\n  var bulkInsertDocs = [];\n  var bulkUpdateDocs = [];\n  var errors = {};\n  var changedDocumentIds = [];\n  var eventBulk = {\n    id: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_3__.randomCouchString)(10),\n    events: [],\n    checkpoint: null,\n    context\n  };\n  var attachmentsAdd = [];\n  var attachmentsRemove = [];\n  var attachmentsUpdate = [];\n  var startTime = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.now)();\n  var docsByIdIsMap = typeof docsInDb.get === 'function';\n  var newestRow;\n  bulkWriteRows.forEach(writeRow => {\n    var id = writeRow.document[primaryPath];\n    var documentInDb = docsByIdIsMap ? docsInDb.get(id) : docsInDb[id];\n    var attachmentError;\n    if (!documentInDb) {\n      /**\n       * It is possible to insert already deleted documents,\n       * this can happen on replication.\n       */\n      var insertedIsDeleted = writeRow.document._deleted ? true : false;\n      if (hasAttachments) {\n        Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {\n          if (!attachmentData.data) {\n            attachmentError = {\n              documentId: id,\n              isError: true,\n              status: 510,\n              writeRow,\n              attachmentId\n            };\n            errors[id] = attachmentError;\n          } else {\n            attachmentsAdd.push({\n              documentId: id,\n              attachmentId,\n              attachmentData: attachmentData\n            });\n          }\n        });\n      }\n      if (!attachmentError) {\n        if (hasAttachments) {\n          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n        } else {\n          bulkInsertDocs.push(writeRow);\n        }\n        if (!newestRow || newestRow.document._meta.lwt < writeRow.document._meta.lwt) {\n          newestRow = writeRow;\n        }\n      }\n      if (!insertedIsDeleted) {\n        changedDocumentIds.push(id);\n        eventBulk.events.push({\n          eventId: getUniqueDeterministicEventKey(storageInstance, primaryPath, writeRow),\n          documentId: id,\n          operation: 'INSERT',\n          documentData: hasAttachments ? stripAttachmentsDataFromDocument(writeRow.document) : writeRow.document,\n          previousDocumentData: hasAttachments && writeRow.previous ? stripAttachmentsDataFromDocument(writeRow.previous) : writeRow.previous,\n          startTime,\n          endTime: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.now)()\n        });\n      }\n    } else {\n      // update existing document\n      var revInDb = documentInDb._rev;\n\n      /**\n       * Check for conflict\n       */\n      if (!writeRow.previous || !!writeRow.previous && revInDb !== writeRow.previous._rev) {\n        // is conflict error\n        var err = {\n          isError: true,\n          status: 409,\n          documentId: id,\n          writeRow: writeRow,\n          documentInDb\n        };\n        errors[id] = err;\n        return;\n      }\n\n      // handle attachments data\n\n      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;\n      if (hasAttachments) {\n        if (writeRow.document._deleted) {\n          /**\n           * Deleted documents must have cleared all their attachments.\n           */\n          if (writeRow.previous) {\n            Object.keys(writeRow.previous._attachments).forEach(attachmentId => {\n              attachmentsRemove.push({\n                documentId: id,\n                attachmentId\n              });\n            });\n          }\n        } else {\n          // first check for errors\n          Object.entries(writeRow.document._attachments).find(([attachmentId, attachmentData]) => {\n            var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : undefined;\n            if (!previousAttachmentData && !attachmentData.data) {\n              attachmentError = {\n                documentId: id,\n                documentInDb,\n                isError: true,\n                status: 510,\n                writeRow,\n                attachmentId\n              };\n            }\n            return true;\n          });\n          if (!attachmentError) {\n            Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {\n              var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : undefined;\n              if (!previousAttachmentData) {\n                attachmentsAdd.push({\n                  documentId: id,\n                  attachmentId,\n                  attachmentData: attachmentData\n                });\n              } else {\n                var newDigest = updatedRow.document._attachments[attachmentId].digest;\n                if (attachmentData.data &&\n                /**\n                 * Performance shortcut,\n                 * do not update the attachment data if it did not change.\n                 */\n                previousAttachmentData.digest !== newDigest) {\n                  attachmentsUpdate.push({\n                    documentId: id,\n                    attachmentId,\n                    attachmentData: attachmentData\n                  });\n                }\n              }\n            });\n          }\n        }\n      }\n      if (attachmentError) {\n        errors[id] = attachmentError;\n      } else {\n        bulkUpdateDocs.push(updatedRow);\n        if (!newestRow || newestRow.document._meta.lwt < updatedRow.document._meta.lwt) {\n          newestRow = updatedRow;\n        }\n      }\n      var writeDoc = writeRow.document;\n      var eventDocumentData = null;\n      var previousEventDocumentData = null;\n      var operation = null;\n      if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {\n        operation = 'INSERT';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;\n      } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {\n        operation = 'UPDATE';\n        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;\n        previousEventDocumentData = writeRow.previous;\n      } else if (writeDoc._deleted) {\n        operation = 'DELETE';\n        eventDocumentData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(writeRow.document);\n        previousEventDocumentData = writeRow.previous;\n      } else {\n        throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('SNH', {\n          args: {\n            writeRow\n          }\n        });\n      }\n      changedDocumentIds.push(id);\n      eventBulk.events.push({\n        eventId: getUniqueDeterministicEventKey(storageInstance, primaryPath, writeRow),\n        documentId: id,\n        documentData: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(eventDocumentData),\n        previousDocumentData: previousEventDocumentData,\n        operation: operation,\n        startTime,\n        endTime: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.now)()\n      });\n    }\n  });\n  return {\n    bulkInsertDocs,\n    bulkUpdateDocs,\n    newestRow,\n    errors,\n    changedDocumentIds,\n    eventBulk,\n    attachmentsAdd,\n    attachmentsRemove,\n    attachmentsUpdate\n  };\n}\nfunction stripAttachmentsDataFromRow(writeRow) {\n  return {\n    previous: writeRow.previous,\n    document: stripAttachmentsDataFromDocument(writeRow.document)\n  };\n}\nfunction getAttachmentSize(attachmentBase64String) {\n  return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nfunction attachmentWriteDataToNormalData(writeData) {\n  var data = writeData.data;\n  if (!data) {\n    return writeData;\n  }\n  var ret = {\n    digest: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_6__.defaultHashSha256)(data),\n    length: getAttachmentSize(data),\n    type: writeData.type\n  };\n  return ret;\n}\nfunction stripAttachmentsDataFromDocument(doc) {\n  var useDoc = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(doc);\n  useDoc._attachments = {};\n  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {\n    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n  });\n  return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nfunction flatCloneDocWithMeta(doc) {\n  var ret = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(doc);\n  ret._meta = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(doc._meta);\n  return ret;\n}\n\n/**\n * Each event is labeled with the id\n * to make it easy to filter out duplicates.\n */\nfunction getUniqueDeterministicEventKey(storageInstance, primaryPath, writeRow) {\n  var docId = writeRow.document[primaryPath];\n  var binaryValues = [!!writeRow.previous, writeRow.previous && writeRow.previous._deleted, !!writeRow.document._deleted];\n  var binary = binaryValues.map(v => v ? '1' : '0').join('');\n  var eventKey = storageInstance.databaseName + '|' + storageInstance.collectionName + '|' + docId + '|' + '|' + binary + '|' + writeRow.document._rev;\n  return eventKey;\n}\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nfunction getWrappedStorageInstance(database, storageInstance,\n/**\n * The original RxJsonSchema\n * before it was mutated by hooks.\n */\nrxJsonSchema) {\n  _overwritable__WEBPACK_IMPORTED_MODULE_1__.overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n  var primaryPath = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_7__.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);\n  function transformDocumentDataFromRxDBToRxStorage(writeRow) {\n    var data = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(writeRow.document);\n    data._meta = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(data._meta);\n\n    /**\n     * Do some checks in dev-mode\n     * that would be too performance expensive\n     * in production.\n     */\n    if (_overwritable__WEBPACK_IMPORTED_MODULE_1__.overwritable.isDevMode()) {\n      // ensure that the primary key has not been changed\n      data = (0,_rx_schema_helper__WEBPACK_IMPORTED_MODULE_7__.fillPrimaryKey)(primaryPath, rxJsonSchema, data);\n\n      /**\n       * Ensure that the new revision is higher\n       * then the previous one\n       */\n      if (writeRow.previous) {\n        // TODO run this in the dev-mode plugin\n        // const prev = parseRevision(writeRow.previous._rev);\n        // const current = parseRevision(writeRow.document._rev);\n        // if (current.height <= prev.height) {\n        //     throw newRxError('SNH', {\n        //         dataBefore: writeRow.previous,\n        //         dataAfter: writeRow.document,\n        //         args: {\n        //             prev,\n        //             current\n        //         }\n        //     });\n        // }\n      }\n\n      /**\n       * Ensure that _meta fields have been merged\n       * and not replaced.\n       * This is important so that when one plugin A\n       * sets a _meta field and another plugin B does a write\n       * to the document, it must be ensured that the\n       * field of plugin A was not removed.\n       */\n      if (writeRow.previous) {\n        Object.keys(writeRow.previous._meta).forEach(metaFieldName => {\n          if (!writeRow.document._meta.hasOwnProperty(metaFieldName)) {\n            throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('SNH', {\n              dataBefore: writeRow.previous,\n              dataAfter: writeRow.document\n            });\n          }\n        });\n      }\n    }\n    data._meta.lwt = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_4__.now)();\n\n    /**\n     * Yes we really want to set the revision here.\n     * If you make a plugin that relies on having its own revision\n     * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n     */\n    data._rev = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_8__.createRevision)(database.token, writeRow.previous);\n    return {\n      document: data,\n      previous: writeRow.previous\n    };\n  }\n  var ret = {\n    originalStorageInstance: storageInstance,\n    schema: storageInstance.schema,\n    internals: storageInstance.internals,\n    collectionName: storageInstance.collectionName,\n    databaseName: storageInstance.databaseName,\n    options: storageInstance.options,\n    bulkWrite(rows, context) {\n      var toStorageWriteRows = rows.map(row => transformDocumentDataFromRxDBToRxStorage(row));\n      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context))\n      /**\n       * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n       * without sending the previous document version.\n       * But for better developer experience, RxDB does allow to re-insert deleted documents.\n       * We do this by automatically fixing the conflict errors for that case\n       * by running another bulkWrite() and merging the results.\n       * @link https://github.com/pubkey/rxdb/pull/3839\n       */.then(writeResult => {\n        var reInsertErrors = Object.values(writeResult.error).filter(error => {\n          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(error.documentInDb)._deleted) {\n            return true;\n          }\n          return false;\n        });\n        if (reInsertErrors.length > 0) {\n          var useWriteResult = {\n            error: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(writeResult.error),\n            success: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(writeResult.success)\n          };\n          var reInserts = reInsertErrors.map(error => {\n            delete useWriteResult.error[error.documentId];\n            return {\n              previous: error.documentInDb,\n              document: Object.assign({}, error.writeRow.document, {\n                _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_8__.createRevision)(database.token, error.documentInDb)\n              })\n            };\n          });\n          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context)).then(subResult => {\n            useWriteResult.error = Object.assign(useWriteResult.error, subResult.error);\n            useWriteResult.success = Object.assign(useWriteResult.success, subResult.success);\n            return useWriteResult;\n          });\n        }\n        return writeResult;\n      });\n    },\n    query(preparedQuery) {\n      return database.lockedRun(() => storageInstance.query(preparedQuery));\n    },\n    count(preparedQuery) {\n      return database.lockedRun(() => storageInstance.count(preparedQuery));\n    },\n    findDocumentsById(ids, deleted) {\n      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));\n    },\n    getAttachmentData(documentId, attachmentId) {\n      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId));\n    },\n    getChangedDocumentsSince(limit, checkpoint) {\n      return database.lockedRun(() => storageInstance.getChangedDocumentsSince((0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.ensureNotFalsy)(limit), checkpoint));\n    },\n    cleanup(minDeletedTime) {\n      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));\n    },\n    remove() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.remove());\n    },\n    close() {\n      database.storageInstances.delete(ret);\n      return database.lockedRun(() => storageInstance.close());\n    },\n    changeStream() {\n      return storageInstance.changeStream();\n    },\n    conflictResultionTasks() {\n      return storageInstance.conflictResultionTasks();\n    },\n    resolveConflictResultionTask(taskSolution) {\n      if (taskSolution.output.isEqual) {\n        return storageInstance.resolveConflictResultionTask(taskSolution);\n      }\n      var doc = Object.assign({}, taskSolution.output.documentData, {\n        _meta: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_9__.getDefaultRxDocumentMeta)(),\n        _rev: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_9__.getDefaultRevision)(),\n        _attachments: {}\n      });\n      var documentData = (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_0__.flatClone)(doc);\n      delete documentData._meta;\n      delete documentData._rev;\n      delete documentData._attachments;\n      return storageInstance.resolveConflictResultionTask({\n        id: taskSolution.id,\n        output: {\n          isEqual: false,\n          documentData\n        }\n      });\n    }\n  };\n  database.storageInstances.add(ret);\n  return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nfunction ensureRxStorageInstanceParamsAreCorrect(params) {\n  if (params.schema.keyCompression) {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('UT5', {\n      args: {\n        params\n      }\n    });\n  }\n  if (hasEncryption(params.schema)) {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_2__.newRxError)('UT6', {\n      args: {\n        params\n      }\n    });\n  }\n}\nfunction hasEncryption(jsonSchema) {\n  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {\n    return true;\n  } else {\n    return false;\n  }\n}\n//# sourceMappingURL=rx-storage-helper.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-storage-helper.js?");

/***/ }),

/***/ "./dist/es/rx-storage-multiinstance.js":
/*!*********************************************!*\
  !*** ./dist/es/rx-storage-multiinstance.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BROADCAST_CHANNEL_BY_TOKEN\": () => (/* binding */ BROADCAST_CHANNEL_BY_TOKEN),\n/* harmony export */   \"addRxStorageMultiInstanceSupport\": () => (/* binding */ addRxStorageMultiInstanceSupport),\n/* harmony export */   \"getBroadcastChannelReference\": () => (/* binding */ getBroadcastChannelReference),\n/* harmony export */   \"removeBroadcastChannelReference\": () => (/* binding */ removeBroadcastChannelReference)\n/* harmony export */ });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js\");\n/* harmony import */ var broadcast_channel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! broadcast-channel */ \"./node_modules/broadcast-channel/dist/esbrowser/index.js\");\n/**\n * When a persistend RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intened to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\n\n\n\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n *\n * TODO at the end of the unit tests,\n * we should ensure that all channels are closed and cleaned up.\n * Otherwise we have forgot something.\n */\nvar BROADCAST_CHANNEL_BY_TOKEN = new Map();\nfunction getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    state = {\n      /**\n       * We have to use the databaseName instead of the databaseInstanceToken\n       * in the BroadcastChannel name because different instances must end with the same\n       * channel name to be able to broadcast messages between each other.\n       */\n      bc: new broadcast_channel__WEBPACK_IMPORTED_MODULE_0__.BroadcastChannel('RxDB:' + databaseName),\n      refs: new Set()\n    };\n    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n  }\n  state.refs.add(refObject);\n  return state.bc;\n}\nfunction removeBroadcastChannelReference(databaseInstanceToken, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    return;\n  }\n  state.refs.delete(refObject);\n  if (state.refs.size === 0) {\n    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n    return state.bc.close();\n  }\n}\nfunction addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance,\n/**\n * If provided, that channel will be used\n * instead of an own one.\n */\nprovidedBroadcastChannel) {\n  if (!instanceCreationParams.multiInstance) {\n    return;\n  }\n  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);\n  var changesFromOtherInstances$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n  var eventListener = msg => {\n    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {\n      changesFromOtherInstances$.next(msg.eventBulk);\n    }\n  };\n  broadcastChannel.addEventListener('message', eventListener);\n  var oldChangestream$ = instance.changeStream();\n  var closed = false;\n  var sub = oldChangestream$.subscribe(eventBulk => {\n    if (closed) {\n      return;\n    }\n    broadcastChannel.postMessage({\n      storageName: storageName,\n      databaseName: instanceCreationParams.databaseName,\n      collectionName: instanceCreationParams.collectionName,\n      version: instanceCreationParams.schema.version,\n      eventBulk\n    });\n  });\n  instance.changeStream = function () {\n    return changesFromOtherInstances$.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.mergeWith)(oldChangestream$));\n  };\n  var oldClose = instance.close.bind(instance);\n  instance.close = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldClose();\n  };\n  var oldRemove = instance.remove.bind(instance);\n  instance.remove = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldRemove();\n  };\n}\n//# sourceMappingURL=rx-storage-multiinstance.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-storage-multiinstance.js?");

/***/ }),

/***/ "./dist/es/rx-storage-statics.js":
/*!***************************************!*\
  !*** ./dist/es/rx-storage-statics.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RxStorageDefaultStatics\": () => (/* binding */ RxStorageDefaultStatics),\n/* harmony export */   \"getDefaultSortComparator\": () => (/* binding */ getDefaultSortComparator)\n/* harmony export */ });\n/* harmony import */ var _rx_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rx-error */ \"./dist/es/rx-error.js\");\n/* harmony import */ var _query_planner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query-planner */ \"./dist/es/query-planner.js\");\n/* harmony import */ var _rx_schema_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rx-schema-helper */ \"./dist/es/rx-schema-helper.js\");\n/* harmony import */ var _rx_query_mingo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rx-query-mingo */ \"./dist/es/rx-query-mingo.js\");\n/* harmony import */ var mingo_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mingo/util */ \"./node_modules/mingo/es/util.js\");\n/* harmony import */ var _plugins_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/utils */ \"./dist/es/plugins/utils/utils-object.js\");\n\n\n\n\n\n\n\n/**\n * Most RxStorage implementations use these static functions.\n * But you can use anything that implements the interface,\n * for example if your underlying database already has a query engine.\n */\nvar RxStorageDefaultStatics = {\n  prepareQuery(schema, mutateableQuery) {\n    if (!mutateableQuery.sort) {\n      throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_1__.newRxError)('SNH', {\n        query: mutateableQuery\n      });\n    }\n\n    /**\n     * Store the query plan together with the\n     * prepared query to save performance.\n     */\n    var queryPlan = (0,_query_planner__WEBPACK_IMPORTED_MODULE_2__.getQueryPlan)(schema, mutateableQuery);\n    return {\n      query: mutateableQuery,\n      queryPlan\n    };\n  },\n  getSortComparator(schema, preparedQuery) {\n    return getDefaultSortComparator(schema, preparedQuery.query);\n  },\n  getQueryMatcher(_schema, preparedQuery) {\n    var query = preparedQuery.query;\n    var mingoQuery = (0,_rx_query_mingo__WEBPACK_IMPORTED_MODULE_3__.getMingoQuery)(query.selector);\n    var fun = doc => {\n      if (doc._deleted) {\n        return false;\n      }\n      var cursor = mingoQuery.find([doc]);\n      var next = cursor.next();\n      if (next) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n    return fun;\n  },\n  checkpointSchema: _rx_schema_helper__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_CHECKPOINT_SCHEMA\n};\n\n/**\n * Default mango query sort comparator.\n * @hotPath\n */\nfunction getDefaultSortComparator(_schema, query) {\n  if (!query.sort) {\n    throw (0,_rx_error__WEBPACK_IMPORTED_MODULE_1__.newRxError)('SNH', {\n      query\n    });\n  }\n  var sortParts = [];\n  query.sort.forEach(sortBlock => {\n    var key = Object.keys(sortBlock)[0];\n    var direction = Object.values(sortBlock)[0];\n    sortParts.push({\n      key,\n      direction,\n      getValueFn: (0,_plugins_utils__WEBPACK_IMPORTED_MODULE_5__.objectPathMonad)(key)\n    });\n  });\n  var fun = (a, b) => {\n    for (var i = 0; i < sortParts.length; ++i) {\n      var sortPart = sortParts[i];\n      var valueA = sortPart.getValueFn(a);\n      var valueB = sortPart.getValueFn(b);\n      if (valueA !== valueB) {\n        var ret = sortPart.direction === 'asc' ? (0,mingo_util__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COMPARATOR)(valueA, valueB) : (0,mingo_util__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COMPARATOR)(valueB, valueA);\n        return ret;\n      }\n    }\n  };\n  return fun;\n}\n//# sourceMappingURL=rx-storage-statics.js.map\n\n//# sourceURL=webpack://rxdb/./dist/es/rx-storage-statics.js?");

/***/ }),

/***/ "./node_modules/array-push-at-sort-position/dist/es/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/array-push-at-sort-position/dist/es/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pushAtSortPosition\": () => (/* binding */ pushAtSortPosition)\n/* harmony export */ });\n/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nfunction pushAtSortPosition(array, item, compareFunction, noCopy) {\n  var ret = noCopy ? array : array.slice(0);\n  var high = ret.length - 1;\n  var low = 0;\n  var mid = 0;\n  /**\n   * Optimization shortcut.\n   */\n\n  if (ret.length === 0) {\n    ret.push(item);\n    return [ret, 0];\n  }\n  /**\n   * So we do not have to ghet the ret[mid] doc again\n   * at the last we store it here.\n   */\n\n\n  var lastMidDoc;\n\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = ret[mid];\n\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n  /**\n   * Insert at correct position\n   */\n\n\n  ret.splice(mid, 0, item);\n  return [ret, mid];\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/array-push-at-sort-position/dist/es/index.js?");

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/es/minimal-string/minimal-string-to-simple-bdd.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/es/minimal-string/minimal-string-to-simple-bdd.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"minimalStringToSimpleBdd\": () => (/* binding */ minimalStringToSimpleBdd)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/binary-decision-diagram/dist/es/util.js\");\n/* harmony import */ var _string_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string-format */ \"./node_modules/binary-decision-diagram/dist/es/minimal-string/string-format.js\");\n\n\nfunction minimalStringToSimpleBdd(str) {\n    const nodesById = new Map();\n    // parse leaf nodes\n    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n    const lastLeafNodeChar = (2 + leafNodeAmount * 2);\n    const leafNodeChars = str.substring(2, lastLeafNodeChar);\n    const leafNodeChunks = (0,_util__WEBPACK_IMPORTED_MODULE_0__.splitStringToChunks)(leafNodeChars, 2);\n    for (let i = 0; i < leafNodeChunks.length; i++) {\n        const chunk = leafNodeChunks[i];\n        const id = chunk.charAt(0);\n        const value = (0,_string_format__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(chunk.charAt(1));\n        nodesById.set(id, value);\n    }\n    // parse internal nodes\n    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n    const internalNodeChunks = (0,_util__WEBPACK_IMPORTED_MODULE_0__.splitStringToChunks)(internalNodeChars, 4);\n    for (let i = 0; i < internalNodeChunks.length; i++) {\n        const chunk = internalNodeChunks[i];\n        const id = chunk.charAt(0);\n        const idOf0Branch = chunk.charAt(1);\n        const idOf1Branch = chunk.charAt(2);\n        const level = (0,_string_format__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(chunk.charAt(3));\n        if (!nodesById.has(idOf0Branch)) {\n            throw new Error('missing node with id ' + idOf0Branch);\n        }\n        if (!nodesById.has(idOf1Branch)) {\n            throw new Error('missing node with id ' + idOf1Branch);\n        }\n        const node0 = nodesById.get(idOf0Branch);\n        const node1 = nodesById.get(idOf1Branch);\n        const node = {\n            l: level,\n            0: node0,\n            1: node1\n        };\n        nodesById.set(id, node);\n    }\n    // parse root node\n    const last3 = str.slice(-3);\n    const idOf0 = last3.charAt(0);\n    const idOf1 = last3.charAt(1);\n    const levelOfRoot = (0,_string_format__WEBPACK_IMPORTED_MODULE_1__.getNumberOfChar)(last3.charAt(2));\n    const nodeOf0 = nodesById.get(idOf0);\n    const nodeOf1 = nodesById.get(idOf1);\n    const rootNode = {\n        l: levelOfRoot,\n        0: nodeOf0,\n        1: nodeOf1,\n    };\n    return rootNode;\n}\n//# sourceMappingURL=minimal-string-to-simple-bdd.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/binary-decision-diagram/dist/es/minimal-string/minimal-string-to-simple-bdd.js?");

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/es/minimal-string/resolve-with-simple-bdd.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/es/minimal-string/resolve-with-simple-bdd.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveWithSimpleBdd\": () => (/* binding */ resolveWithSimpleBdd)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/binary-decision-diagram/dist/es/util.js\");\n\nfunction resolveWithSimpleBdd(simpleBdd, fns, input) {\n    let currentNode = simpleBdd;\n    let currentLevel = simpleBdd.l;\n    while (true) {\n        const booleanResult = fns[currentLevel](input);\n        const branchKey = (0,_util__WEBPACK_IMPORTED_MODULE_0__.booleanToBooleanString)(booleanResult);\n        currentNode = currentNode[branchKey];\n        if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n            return currentNode;\n        }\n        else {\n            currentLevel = currentNode.l;\n        }\n    }\n}\n//# sourceMappingURL=resolve-with-simple-bdd.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/binary-decision-diagram/dist/es/minimal-string/resolve-with-simple-bdd.js?");

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/es/minimal-string/string-format.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/es/minimal-string/string-format.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CHAR_CODE_OFFSET\": () => (/* binding */ CHAR_CODE_OFFSET),\n/* harmony export */   \"FIRST_CHAR_CODE_FOR_ID\": () => (/* binding */ FIRST_CHAR_CODE_FOR_ID),\n/* harmony export */   \"getCharOfLevel\": () => (/* binding */ getCharOfLevel),\n/* harmony export */   \"getCharOfValue\": () => (/* binding */ getCharOfValue),\n/* harmony export */   \"getNextCharId\": () => (/* binding */ getNextCharId),\n/* harmony export */   \"getNumberOfChar\": () => (/* binding */ getNumberOfChar)\n/* harmony export */ });\n/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nconst CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nfunction getCharOfLevel(level) {\n    const charCode = CHAR_CODE_OFFSET + level;\n    return String.fromCharCode(charCode);\n}\nfunction getNumberOfChar(char) {\n    const charCode = char.charCodeAt(0);\n    return charCode - CHAR_CODE_OFFSET;\n}\nfunction getCharOfValue(value) {\n    const charCode = CHAR_CODE_OFFSET + value;\n    return String.fromCharCode(charCode);\n}\nconst FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nfunction getNextCharId(lastCode) {\n    // jump these codes because they look strange\n    if (lastCode >= 128 && lastCode <= 160) {\n        lastCode = 161;\n    }\n    const char = String.fromCharCode(lastCode);\n    return {\n        char,\n        nextCode: lastCode + 1\n    };\n}\n//# sourceMappingURL=string-format.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/binary-decision-diagram/dist/es/minimal-string/string-format.js?");

/***/ }),

/***/ "./node_modules/binary-decision-diagram/dist/es/util.js":
/*!**************************************************************!*\
  !*** ./node_modules/binary-decision-diagram/dist/es/util.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"binaryToDecimal\": () => (/* binding */ binaryToDecimal),\n/* harmony export */   \"booleanStringToBoolean\": () => (/* binding */ booleanStringToBoolean),\n/* harmony export */   \"booleanToBooleanString\": () => (/* binding */ booleanToBooleanString),\n/* harmony export */   \"decimalToPaddedBinary\": () => (/* binding */ decimalToPaddedBinary),\n/* harmony export */   \"firstKeyOfMap\": () => (/* binding */ firstKeyOfMap),\n/* harmony export */   \"getNextStateSet\": () => (/* binding */ getNextStateSet),\n/* harmony export */   \"lastChar\": () => (/* binding */ lastChar),\n/* harmony export */   \"lastOfArray\": () => (/* binding */ lastOfArray),\n/* harmony export */   \"maxBinaryWithLength\": () => (/* binding */ maxBinaryWithLength),\n/* harmony export */   \"minBinaryWithLength\": () => (/* binding */ minBinaryWithLength),\n/* harmony export */   \"nextNodeId\": () => (/* binding */ nextNodeId),\n/* harmony export */   \"oppositeBinary\": () => (/* binding */ oppositeBinary),\n/* harmony export */   \"oppositeBoolean\": () => (/* binding */ oppositeBoolean),\n/* harmony export */   \"shuffleArray\": () => (/* binding */ shuffleArray),\n/* harmony export */   \"splitStringToChunks\": () => (/* binding */ splitStringToChunks)\n/* harmony export */ });\nfunction booleanStringToBoolean(str) {\n    if (str === '1') {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction booleanToBooleanString(b) {\n    if (b) {\n        return '1';\n    }\n    else {\n        return '0';\n    }\n}\nfunction oppositeBoolean(input) {\n    if (input === '1') {\n        return '0';\n    }\n    else {\n        return '1';\n    }\n}\nfunction lastChar(str) {\n    return str.slice(-1);\n}\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length = 6) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nfunction nextNodeId() {\n    const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n    lastIdGen++;\n    return ret;\n}\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nfunction decimalToPaddedBinary(decimal, padding) {\n    const binary = (decimal >>> 0).toString(2);\n    const padded = binary.padStart(padding, '0');\n    return padded;\n}\nfunction oppositeBinary(i) {\n    if (i === '1') {\n        return '0';\n    }\n    else if (i === '0') {\n        return '1';\n    }\n    else {\n        throw new Error('non-binary given');\n    }\n}\nfunction binaryToDecimal(binary) {\n    return parseInt(binary, 2);\n}\nfunction minBinaryWithLength(length) {\n    return new Array(length).fill(0).map(() => '0').join('');\n}\nfunction maxBinaryWithLength(length) {\n    return new Array(length).fill(0).map(() => '1').join('');\n}\nfunction getNextStateSet(stateSet) {\n    const decimal = binaryToDecimal(stateSet);\n    const increase = decimal + 1;\n    const binary = decimalToPaddedBinary(increase, stateSet.length);\n    return binary;\n}\nfunction firstKeyOfMap(map) {\n    const iterator1 = map.keys();\n    return iterator1.next().value;\n}\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nfunction shuffleArray(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nfunction lastOfArray(ar) {\n    return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nfunction splitStringToChunks(str, chunkSize) {\n    const chunks = [];\n    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n        chunks.push(str.substring(i, i + chunkSize));\n    }\n    return chunks;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/binary-decision-diagram/dist/es/util.js?");

/***/ }),

/***/ "./node_modules/custom-idle-queue/dist/es/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/custom-idle-queue/dist/es/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IdleQueue\": () => (/* binding */ IdleQueue)\n/* harmony export */ });\n/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nvar IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/custom-idle-queue/dist/es/index.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/actions/action-functions.js":
/*!**************************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/actions/action-functions.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alwaysWrong\": () => (/* binding */ alwaysWrong),\n/* harmony export */   \"doNothing\": () => (/* binding */ doNothing),\n/* harmony export */   \"insertAtSortPosition\": () => (/* binding */ insertAtSortPosition),\n/* harmony export */   \"insertFirst\": () => (/* binding */ insertFirst),\n/* harmony export */   \"insertLast\": () => (/* binding */ insertLast),\n/* harmony export */   \"removeExisting\": () => (/* binding */ removeExisting),\n/* harmony export */   \"removeExistingAndInsertAtSortPosition\": () => (/* binding */ removeExistingAndInsertAtSortPosition),\n/* harmony export */   \"removeFirstInsertFirst\": () => (/* binding */ removeFirstInsertFirst),\n/* harmony export */   \"removeFirstInsertLast\": () => (/* binding */ removeFirstInsertLast),\n/* harmony export */   \"removeFirstItem\": () => (/* binding */ removeFirstItem),\n/* harmony export */   \"removeLastInsertFirst\": () => (/* binding */ removeLastInsertFirst),\n/* harmony export */   \"removeLastInsertLast\": () => (/* binding */ removeLastInsertLast),\n/* harmony export */   \"removeLastItem\": () => (/* binding */ removeLastItem),\n/* harmony export */   \"replaceExisting\": () => (/* binding */ replaceExisting),\n/* harmony export */   \"runFullQueryAgain\": () => (/* binding */ runFullQueryAgain),\n/* harmony export */   \"unknownAction\": () => (/* binding */ unknownAction)\n/* harmony export */ });\n/* harmony import */ var array_push_at_sort_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! array-push-at-sort-position */ \"./node_modules/array-push-at-sort-position/dist/es/index.js\");\n\nconst doNothing = (_input) => { };\nconst insertFirst = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nconst insertLast = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nconst removeFirstItem = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n    }\n};\nconst removeLastItem = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n    }\n};\nconst removeFirstInsertLast = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\nconst removeLastInsertFirst = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\nconst removeFirstInsertFirst = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\nconst removeLastInsertLast = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\nconst removeExisting = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(input.changeEvent.id);\n    }\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        // console.dir(item);\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\nconst replaceExisting = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(input.changeEvent.id, doc);\n            }\n            break;\n        }\n    }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nconst alwaysWrong = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n    }\n};\nconst insertAtSortPosition = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n        input.keyDocumentMap.set(docId, doc);\n    }\n    else {\n        const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n    (0,array_push_at_sort_position__WEBPACK_IMPORTED_MODULE_0__.pushAtSortPosition)(input.previousResults, doc, input.queryParams.sortComparator, true);\n};\nconst removeExistingAndInsertAtSortPosition = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\nconst runFullQueryAgain = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nconst unknownAction = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n//# sourceMappingURL=action-functions.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/actions/action-functions.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/actions/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/actions/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"actionFunctions\": () => (/* binding */ actionFunctions),\n/* harmony export */   \"orderedActionList\": () => (/* binding */ orderedActionList)\n/* harmony export */ });\n/* harmony import */ var _action_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./action-functions */ \"./node_modules/event-reduce-js/dist/es/actions/action-functions.js\");\n\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nconst orderedActionList = [\n    'doNothing',\n    'insertFirst',\n    'insertLast',\n    'removeFirstItem',\n    'removeLastItem',\n    'removeFirstInsertLast',\n    'removeLastInsertFirst',\n    'removeFirstInsertFirst',\n    'removeLastInsertLast',\n    'removeExisting',\n    'replaceExisting',\n    'alwaysWrong',\n    'insertAtSortPosition',\n    'removeExistingAndInsertAtSortPosition',\n    'runFullQueryAgain',\n    'unknownAction'\n];\nconst actionFunctions = {\n    doNothing: _action_functions__WEBPACK_IMPORTED_MODULE_0__.doNothing,\n    insertFirst: _action_functions__WEBPACK_IMPORTED_MODULE_0__.insertFirst,\n    insertLast: _action_functions__WEBPACK_IMPORTED_MODULE_0__.insertLast,\n    removeFirstItem: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeFirstItem,\n    removeLastItem: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeLastItem,\n    removeFirstInsertLast: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertLast,\n    removeLastInsertFirst: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertFirst,\n    removeFirstInsertFirst: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeFirstInsertFirst,\n    removeLastInsertLast: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeLastInsertLast,\n    removeExisting: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeExisting,\n    replaceExisting: _action_functions__WEBPACK_IMPORTED_MODULE_0__.replaceExisting,\n    alwaysWrong: _action_functions__WEBPACK_IMPORTED_MODULE_0__.alwaysWrong,\n    insertAtSortPosition: _action_functions__WEBPACK_IMPORTED_MODULE_0__.insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition: _action_functions__WEBPACK_IMPORTED_MODULE_0__.removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain: _action_functions__WEBPACK_IMPORTED_MODULE_0__.runFullQueryAgain,\n    unknownAction: _action_functions__WEBPACK_IMPORTED_MODULE_0__.unknownAction\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/actions/index.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/bdd/bdd.generated.js":
/*!*******************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/bdd/bdd.generated.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSimpleBdd\": () => (/* binding */ getSimpleBdd),\n/* harmony export */   \"minimalBddString\": () => (/* binding */ minimalBddString),\n/* harmony export */   \"resolveInput\": () => (/* binding */ resolveInput)\n/* harmony export */ });\n/* harmony import */ var binary_decision_diagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! binary-decision-diagram */ \"./node_modules/binary-decision-diagram/dist/es/minimal-string/minimal-string-to-simple-bdd.js\");\n/* harmony import */ var binary_decision_diagram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! binary-decision-diagram */ \"./node_modules/binary-decision-diagram/dist/es/minimal-string/resolve-with-simple-bdd.js\");\n/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../states */ \"./node_modules/event-reduce-js/dist/es/states/index.js\");\n\n\nconst minimalBddString = '14a2b0c/d1e,f+g5h.i4j*k-l)m(n6ohk1pdf1qef1rin-sjn-ton-ugn-vmn-whn-xkn-yln-zdf5{ef5|wx5}df7~dz7ef7¡bk7¢e{7£g|7¤ry7¥dp7¦gk7§eq7¨gt7©ac7ªmv7«gu7¬nm7­iy7®nw7¯¤s8°«¦8±¬k8²ªm8³®v8´«n8µ¬n8¶vm8·xv8¸mn8¹­j8º®m8»xm8¼­¹3½}~3¾©°3¿¢3À¡£3Ám±3Â®º3Ãmº3Ä©´3Åb®3Æmµ3Çm»3Èx»3Ékn3Êm¸3Ë¼j6ÌÂm6ÍÆÃ6ÎÈm6Ïnm6ÐÊÇ6ÑÌÎ,ÒÍÐ,ÓÅÉ,Ô²¶,Õ³·,Ö®n,×º»,Ømf9ÙËÁ9Úym9ÛmÏ9ÜÑÒ9Ýz{2Þpq2ß½¿2à¾À2á¥§2â°¨2ãÄÓ2ä´Ö2åÝn0æÞn0çØÛ0èÙÜ0éßn0êàã0ë²Ô0ì¯Õ0íán0îâä0ï¹×0ðçv/ñåæ/òçë/óèì/ôéí/õêî/öÚy/÷òm(øóï(ùöy(ú÷ø:ûôõ:ümù:ýðñ4þúû4ÿþý*Āüm*ÿĀ.';\nlet simpleBdd;\nfunction getSimpleBdd() {\n    if (!simpleBdd) {\n        simpleBdd = (0,binary_decision_diagram__WEBPACK_IMPORTED_MODULE_0__.minimalStringToSimpleBdd)(minimalBddString);\n    }\n    return simpleBdd;\n}\nconst resolveInput = (input) => {\n    return (0,binary_decision_diagram__WEBPACK_IMPORTED_MODULE_1__.resolveWithSimpleBdd)(getSimpleBdd(), _states__WEBPACK_IMPORTED_MODULE_2__.stateResolveFunctionByIndex, input);\n};\n//# sourceMappingURL=bdd.generated.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/bdd/bdd.generated.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UNKNOWN_VALUE\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.UNKNOWN_VALUE),\n/* harmony export */   \"calculateActionFromMap\": () => (/* binding */ calculateActionFromMap),\n/* harmony export */   \"calculateActionFunction\": () => (/* binding */ calculateActionFunction),\n/* harmony export */   \"calculateActionName\": () => (/* binding */ calculateActionName),\n/* harmony export */   \"cloneMap\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.cloneMap),\n/* harmony export */   \"doesMatchNow\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow),\n/* harmony export */   \"ensureNotFalsy\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy),\n/* harmony export */   \"flatClone\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.flatClone),\n/* harmony export */   \"getProperty\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.getProperty),\n/* harmony export */   \"getSortFieldsOfQuery\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.getSortFieldsOfQuery),\n/* harmony export */   \"getStateSet\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.getStateSet),\n/* harmony export */   \"hasLimit\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.hasLimit),\n/* harmony export */   \"hasSkip\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.hasSkip),\n/* harmony export */   \"isDelete\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isDelete),\n/* harmony export */   \"isFindOne\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isFindOne),\n/* harmony export */   \"isInsert\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isInsert),\n/* harmony export */   \"isObject\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.isObject),\n/* harmony export */   \"isSortedAfterLast\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast),\n/* harmony export */   \"isSortedBeforeFirst\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst),\n/* harmony export */   \"isUpdate\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.isUpdate),\n/* harmony export */   \"lastOfArray\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.lastOfArray),\n/* harmony export */   \"logStateSet\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.logStateSet),\n/* harmony export */   \"mapToObject\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.mapToObject),\n/* harmony export */   \"mergeSets\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.mergeSets),\n/* harmony export */   \"normalizeSortField\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.normalizeSortField),\n/* harmony export */   \"objectToMap\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.objectToMap),\n/* harmony export */   \"orderedStateList\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.orderedStateList),\n/* harmony export */   \"previousUnknown\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.previousUnknown),\n/* harmony export */   \"randomOfArray\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.randomOfArray),\n/* harmony export */   \"replaceCharAt\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.replaceCharAt),\n/* harmony export */   \"resolveState\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.resolveState),\n/* harmony export */   \"roundToTwoDecimals\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.roundToTwoDecimals),\n/* harmony export */   \"runAction\": () => (/* binding */ runAction),\n/* harmony export */   \"shuffleArray\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.shuffleArray),\n/* harmony export */   \"sortParamsChanged\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged),\n/* harmony export */   \"stateResolveFunctionByIndex\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.stateResolveFunctionByIndex),\n/* harmony export */   \"stateResolveFunctions\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.stateResolveFunctions),\n/* harmony export */   \"tryToFillPreviousDoc\": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_1__.tryToFillPreviousDoc),\n/* harmony export */   \"wasFirst\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasFirst),\n/* harmony export */   \"wasInResult\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasInResult),\n/* harmony export */   \"wasLast\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasLast),\n/* harmony export */   \"wasLimitReached\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached),\n/* harmony export */   \"wasMatching\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasMatching),\n/* harmony export */   \"wasResultsEmpty\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty),\n/* harmony export */   \"wasSortedAfterLast\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast),\n/* harmony export */   \"wasSortedBeforeFirst\": () => (/* reexport safe */ _states__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst)\n/* harmony export */ });\n/* harmony import */ var _states__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./states */ \"./node_modules/event-reduce-js/dist/es/states/index.js\");\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions */ \"./node_modules/event-reduce-js/dist/es/actions/index.js\");\n/* harmony import */ var _bdd_bdd_generated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bdd/bdd.generated */ \"./node_modules/event-reduce-js/dist/es/bdd/bdd.generated.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/event-reduce-js/dist/es/util.js\");\n\n\n\n\n\nfunction calculateActionFromMap(stateSetToActionMap, input) {\n    const stateSet = (0,_states__WEBPACK_IMPORTED_MODULE_0__.getStateSet)(input);\n    const actionName = stateSetToActionMap.get(stateSet);\n    if (!actionName) {\n        return {\n            action: 'runFullQueryAgain',\n            stateSet\n        };\n    }\n    else {\n        return {\n            action: actionName,\n            stateSet\n        };\n    }\n}\nfunction calculateActionName(input) {\n    const resolvedActionId = (0,_bdd_bdd_generated__WEBPACK_IMPORTED_MODULE_2__.resolveInput)(input);\n    return _actions__WEBPACK_IMPORTED_MODULE_3__.orderedActionList[resolvedActionId];\n}\nfunction calculateActionFunction(input) {\n    const actionName = calculateActionName(input);\n    return _actions__WEBPACK_IMPORTED_MODULE_3__.actionFunctions[actionName];\n}\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nfunction runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {\n    const fn = _actions__WEBPACK_IMPORTED_MODULE_3__.actionFunctions[action];\n    fn({\n        queryParams,\n        changeEvent,\n        previousResults,\n        keyDocumentMap\n    });\n    return previousResults;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/index.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/states/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/states/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doesMatchNow\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow),\n/* harmony export */   \"getStateSet\": () => (/* binding */ getStateSet),\n/* harmony export */   \"hasLimit\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasLimit),\n/* harmony export */   \"hasSkip\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasSkip),\n/* harmony export */   \"isDelete\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isDelete),\n/* harmony export */   \"isFindOne\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isFindOne),\n/* harmony export */   \"isInsert\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isInsert),\n/* harmony export */   \"isSortedAfterLast\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast),\n/* harmony export */   \"isSortedBeforeFirst\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst),\n/* harmony export */   \"isUpdate\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isUpdate),\n/* harmony export */   \"logStateSet\": () => (/* binding */ logStateSet),\n/* harmony export */   \"orderedStateList\": () => (/* binding */ orderedStateList),\n/* harmony export */   \"previousUnknown\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.previousUnknown),\n/* harmony export */   \"resolveState\": () => (/* binding */ resolveState),\n/* harmony export */   \"sortParamsChanged\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged),\n/* harmony export */   \"stateResolveFunctionByIndex\": () => (/* binding */ stateResolveFunctionByIndex),\n/* harmony export */   \"stateResolveFunctions\": () => (/* binding */ stateResolveFunctions),\n/* harmony export */   \"wasFirst\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasFirst),\n/* harmony export */   \"wasInResult\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasInResult),\n/* harmony export */   \"wasLast\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLast),\n/* harmony export */   \"wasLimitReached\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached),\n/* harmony export */   \"wasMatching\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasMatching),\n/* harmony export */   \"wasResultsEmpty\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty),\n/* harmony export */   \"wasSortedAfterLast\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast),\n/* harmony export */   \"wasSortedBeforeFirst\": () => (/* reexport safe */ _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst)\n/* harmony export */ });\n/* harmony import */ var _state_resolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-resolver */ \"./node_modules/event-reduce-js/dist/es/states/state-resolver.js\");\n\n\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nconst orderedStateList = [\n    'isInsert',\n    'isUpdate',\n    'isDelete',\n    'hasLimit',\n    'isFindOne',\n    'hasSkip',\n    'wasResultsEmpty',\n    'previousUnknown',\n    'wasLimitReached',\n    'wasFirst',\n    'wasLast',\n    'sortParamsChanged',\n    'wasInResult',\n    'wasSortedBeforeFirst',\n    'wasSortedAfterLast',\n    'isSortedBeforeFirst',\n    'isSortedAfterLast',\n    'wasMatching',\n    'doesMatchNow'\n];\nconst stateResolveFunctions = {\n    isInsert: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isInsert,\n    isUpdate: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isUpdate,\n    isDelete: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isDelete,\n    hasLimit: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasLimit,\n    isFindOne: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isFindOne,\n    hasSkip: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasSkip,\n    wasResultsEmpty: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty,\n    previousUnknown: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.previousUnknown,\n    wasLimitReached: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached,\n    wasFirst: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasFirst,\n    wasLast: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLast,\n    sortParamsChanged: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged,\n    wasInResult: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasInResult,\n    wasSortedBeforeFirst: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst,\n    wasSortedAfterLast: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast,\n    isSortedBeforeFirst: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst,\n    isSortedAfterLast: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast,\n    wasMatching: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasMatching,\n    doesMatchNow: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow\n};\nconst stateResolveFunctionByIndex = {\n    0: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isInsert,\n    1: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isUpdate,\n    2: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isDelete,\n    3: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasLimit,\n    4: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isFindOne,\n    5: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.hasSkip,\n    6: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasResultsEmpty,\n    7: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.previousUnknown,\n    8: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLimitReached,\n    9: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasFirst,\n    10: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasLast,\n    11: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.sortParamsChanged,\n    12: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasInResult,\n    13: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedBeforeFirst,\n    14: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasSortedAfterLast,\n    15: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedBeforeFirst,\n    16: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.isSortedAfterLast,\n    17: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.wasMatching,\n    18: _state_resolver__WEBPACK_IMPORTED_MODULE_0__.doesMatchNow\n};\nfunction resolveState(stateName, input) {\n    const fn = stateResolveFunctions[stateName];\n    if (!fn) {\n        throw new Error('resolveState() has no function for ' + stateName);\n    }\n    return fn(input);\n}\nfunction getStateSet(input) {\n    let set = '';\n    for (let i = 0; i < orderedStateList.length; i++) {\n        const name = orderedStateList[i];\n        const value = resolveState(name, input);\n        const add = value ? '1' : '0';\n        set += add;\n    }\n    return set;\n}\nfunction logStateSet(stateSet) {\n    orderedStateList.forEach((state, index) => {\n        console.log('state: ' + state + ' : ' + stateSet[index]);\n    });\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/states/index.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/states/state-resolver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/states/state-resolver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doesMatchNow\": () => (/* binding */ doesMatchNow),\n/* harmony export */   \"hasLimit\": () => (/* binding */ hasLimit),\n/* harmony export */   \"hasSkip\": () => (/* binding */ hasSkip),\n/* harmony export */   \"isDelete\": () => (/* binding */ isDelete),\n/* harmony export */   \"isFindOne\": () => (/* binding */ isFindOne),\n/* harmony export */   \"isInsert\": () => (/* binding */ isInsert),\n/* harmony export */   \"isSortedAfterLast\": () => (/* binding */ isSortedAfterLast),\n/* harmony export */   \"isSortedBeforeFirst\": () => (/* binding */ isSortedBeforeFirst),\n/* harmony export */   \"isUpdate\": () => (/* binding */ isUpdate),\n/* harmony export */   \"previousUnknown\": () => (/* binding */ previousUnknown),\n/* harmony export */   \"sortParamsChanged\": () => (/* binding */ sortParamsChanged),\n/* harmony export */   \"wasFirst\": () => (/* binding */ wasFirst),\n/* harmony export */   \"wasInResult\": () => (/* binding */ wasInResult),\n/* harmony export */   \"wasLast\": () => (/* binding */ wasLast),\n/* harmony export */   \"wasLimitReached\": () => (/* binding */ wasLimitReached),\n/* harmony export */   \"wasMatching\": () => (/* binding */ wasMatching),\n/* harmony export */   \"wasResultsEmpty\": () => (/* binding */ wasResultsEmpty),\n/* harmony export */   \"wasSortedAfterLast\": () => (/* binding */ wasSortedAfterLast),\n/* harmony export */   \"wasSortedBeforeFirst\": () => (/* binding */ wasSortedBeforeFirst)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/event-reduce-js/dist/es/util.js\");\n\nconst hasLimit = (input) => {\n    return !!input.queryParams.limit;\n};\nconst isFindOne = (input) => {\n    return input.queryParams.limit === 1;\n};\nconst hasSkip = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nconst isDelete = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\nconst isInsert = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\nconst isUpdate = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\nconst previousUnknown = (input) => {\n    return input.changeEvent.previous === _util__WEBPACK_IMPORTED_MODULE_0__.UNKNOWN_VALUE;\n};\nconst wasLimitReached = (input) => {\n    return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nconst sortParamsChanged = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev || prev === _util__WEBPACK_IMPORTED_MODULE_0__.UNKNOWN_VALUE) {\n        return true;\n    }\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getProperty)(prev, field);\n        const afterData = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getProperty)(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\nconst wasInResult = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    }\n    else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\nconst wasFirst = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nconst wasLast = (input) => {\n    const last = (0,_util__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nconst wasSortedBeforeFirst = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === _util__WEBPACK_IMPORTED_MODULE_0__.UNKNOWN_VALUE) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, first);\n    return comp < 0;\n};\nconst wasSortedAfterLast = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === _util__WEBPACK_IMPORTED_MODULE_0__.UNKNOWN_VALUE) {\n        return false;\n    }\n    const last = (0,_util__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, last);\n    return comp > 0;\n};\nconst isSortedBeforeFirst = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, first);\n    return comp < 0;\n};\nconst isSortedAfterLast = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const last = (0,_util__WEBPACK_IMPORTED_MODULE_0__.lastOfArray)(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, last);\n    return comp > 0;\n};\nconst wasMatching = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === _util__WEBPACK_IMPORTED_MODULE_0__.UNKNOWN_VALUE) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(prev);\n};\nconst doesMatchNow = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(doc);\n    return ret;\n};\nconst wasResultsEmpty = (input) => {\n    return input.previousResults.length === 0;\n};\n//# sourceMappingURL=state-resolver.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/states/state-resolver.js?");

/***/ }),

/***/ "./node_modules/event-reduce-js/dist/es/util.js":
/*!******************************************************!*\
  !*** ./node_modules/event-reduce-js/dist/es/util.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UNKNOWN_VALUE\": () => (/* binding */ UNKNOWN_VALUE),\n/* harmony export */   \"cloneMap\": () => (/* binding */ cloneMap),\n/* harmony export */   \"ensureNotFalsy\": () => (/* binding */ ensureNotFalsy),\n/* harmony export */   \"flatClone\": () => (/* binding */ flatClone),\n/* harmony export */   \"getProperty\": () => (/* binding */ getProperty),\n/* harmony export */   \"getSortFieldsOfQuery\": () => (/* binding */ getSortFieldsOfQuery),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"lastOfArray\": () => (/* binding */ lastOfArray),\n/* harmony export */   \"mapToObject\": () => (/* binding */ mapToObject),\n/* harmony export */   \"mergeSets\": () => (/* binding */ mergeSets),\n/* harmony export */   \"normalizeSortField\": () => (/* binding */ normalizeSortField),\n/* harmony export */   \"objectToMap\": () => (/* binding */ objectToMap),\n/* harmony export */   \"randomOfArray\": () => (/* binding */ randomOfArray),\n/* harmony export */   \"replaceCharAt\": () => (/* binding */ replaceCharAt),\n/* harmony export */   \"roundToTwoDecimals\": () => (/* binding */ roundToTwoDecimals),\n/* harmony export */   \"shuffleArray\": () => (/* binding */ shuffleArray),\n/* harmony export */   \"tryToFillPreviousDoc\": () => (/* binding */ tryToFillPreviousDoc)\n/* harmony export */ });\nconst UNKNOWN_VALUE = 'UNKNOWN';\nfunction lastOfArray(ar) {\n    return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nfunction randomOfArray(items) {\n    return items[Math.floor(Math.random() * items.length)];\n}\nfunction shuffleArray(arr) {\n    return arr.slice().sort(() => (Math.random() - 0.5));\n}\n/**\n * if the previous doc-data is unknown,\n * try to get it from previous results\n * @mutate the changeEvent of input\n */\nfunction tryToFillPreviousDoc(input) {\n    const prev = input.changeEvent.previous;\n    if (prev === UNKNOWN_VALUE) {\n        const id = input.changeEvent.id;\n        const primary = input.queryParams.primaryKey;\n        if (input.keyDocumentMap) {\n            const doc = input.keyDocumentMap.get(id);\n            if (doc) {\n                input.changeEvent.previous = doc;\n            }\n        }\n        else {\n            const found = input.previousResults.find(item => item[primary] === id);\n            if (found) {\n                input.changeEvent.previous = found;\n            }\n        }\n    }\n}\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nfunction normalizeSortField(field) {\n    if (field.startsWith('-')) {\n        return field.substr(1);\n    }\n    else {\n        return field;\n    }\n}\nfunction getSortFieldsOfQuery(query) {\n    if (!query.sort) {\n        // if no sort-order is set, use the primary key\n        return ['_id'];\n    }\n    return query.sort.map(maybeArray => {\n        if (Array.isArray(maybeArray)) {\n            return maybeArray[0].map(field => normalizeSortField(field));\n        }\n        else {\n            return normalizeSortField(maybeArray);\n        }\n    });\n}\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nfunction replaceCharAt(str, index, replacement) {\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\nfunction mapToObject(map) {\n    const ret = {};\n    map.forEach((value, key) => {\n        ret[key] = value;\n    });\n    return ret;\n}\nfunction objectToMap(object) {\n    const ret = new Map();\n    Object.entries(object).forEach(([k, v]) => {\n        ret.set(k, v);\n    });\n    return ret;\n}\nfunction cloneMap(map) {\n    const ret = new Map();\n    map.forEach((value, key) => {\n        ret[key] = value;\n    });\n    return ret;\n}\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nfunction flatClone(obj) {\n    return Object.assign({}, obj);\n}\nfunction ensureNotFalsy(obj) {\n    if (!obj) {\n        throw new Error('ensureNotFalsy() is falsy');\n    }\n    return obj;\n}\nfunction mergeSets(sets) {\n    let ret = new Set();\n    sets.forEach(set => {\n        ret = new Set([...ret, ...set]);\n    });\n    return ret;\n}\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nfunction roundToTwoDecimals(num) {\n    return parseFloat(num.toFixed(2));\n}\nfunction isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nfunction getProperty(object, path, value) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n    if (!isObject(object) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n    const pathArray = path.split('.');\n    if (pathArray.length === 0) {\n        return value;\n    }\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n        if (isStringIndex(object, key)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        }\n        else {\n            object = object[key];\n        }\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n            break;\n        }\n    }\n    return object === undefined ? value : object;\n}\nfunction isStringIndex(object, key) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key];\n    }\n    return false;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/event-reduce-js/dist/es/util.js?");

/***/ }),

/***/ "./node_modules/mingo/es/aggregator.js":
/*!*********************************************!*\
  !*** ./node_modules/mingo/es/aggregator.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Aggregator\": () => (/* binding */ Aggregator)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/mingo/es/core.js\");\n/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy */ \"./node_modules/mingo/es/lazy.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/mingo/es/util.js\");\n\n\n\n/**\n * Provides functionality for the mongoDB aggregation pipeline\n *\n * @param pipeline an Array of pipeline operators\n * @param options An optional Options to pass the aggregator\n * @constructor\n */\nclass Aggregator {\n    pipeline;\n    options;\n    constructor(pipeline, options) {\n        this.pipeline = pipeline;\n        this.options = options;\n        this.options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);\n    }\n    /**\n     * Returns an `Lazy` iterator for processing results of pipeline\n     *\n     * @param {*} collection An array or iterator object\n     * @param {Query} query the `Query` object to use as context\n     * @returns {Iterator} an iterator object\n     */\n    stream(collection) {\n        let iterator = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(collection);\n        const mode = this.options.processingMode;\n        if (mode == _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_ALL ||\n            mode == _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_INPUT) {\n            iterator.map(_util__WEBPACK_IMPORTED_MODULE_2__.cloneDeep);\n        }\n        const pipelineOperators = [];\n        if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.pipeline)) {\n            // run aggregation pipeline\n            for (const operator of this.pipeline) {\n                const operatorKeys = Object.keys(operator);\n                const op = operatorKeys[0];\n                const call = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)(_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.PIPELINE, op);\n                (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(operatorKeys.length === 1 && !!call, `invalid aggregation operator ${op}`);\n                pipelineOperators.push(op);\n                iterator = call(iterator, operator[op], this.options);\n            }\n        }\n        // operators that may share object graphs of inputs.\n        // we only need to clone the output for these since the objects will already be distinct for other operators.\n        if (mode == _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_OUTPUT ||\n            (mode == _core__WEBPACK_IMPORTED_MODULE_0__.ProcessingMode.CLONE_ALL &&\n                !!(0,_util__WEBPACK_IMPORTED_MODULE_2__.intersection)([[\"$group\", \"$unwind\"], pipelineOperators]).length)) {\n            iterator.map(_util__WEBPACK_IMPORTED_MODULE_2__.cloneDeep);\n        }\n        return iterator;\n    }\n    /**\n     * Return the results of the aggregation as an array.\n     *\n     * @param {*} collection\n     * @param {*} query\n     */\n    run(collection) {\n        return this.stream(collection).value();\n    }\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/aggregator.js?");

/***/ }),

/***/ "./node_modules/mingo/es/core.js":
/*!***************************************!*\
  !*** ./node_modules/mingo/es/core.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComputeOptions\": () => (/* binding */ ComputeOptions),\n/* harmony export */   \"OperatorType\": () => (/* binding */ OperatorType),\n/* harmony export */   \"ProcessingMode\": () => (/* binding */ ProcessingMode),\n/* harmony export */   \"computeValue\": () => (/* binding */ computeValue),\n/* harmony export */   \"getOperator\": () => (/* binding */ getOperator),\n/* harmony export */   \"initOptions\": () => (/* binding */ initOptions),\n/* harmony export */   \"redact\": () => (/* binding */ redact),\n/* harmony export */   \"useOperators\": () => (/* binding */ useOperators)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/mingo/es/util.js\");\n\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nvar ProcessingMode;\n(function (ProcessingMode) {\n    /**\n     * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n     * Use this option to keep input collection immutable and to get distinct output objects.\n     *\n     * Note: This option is expensive and reduces performance.\n     */\n    ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n    /**\n     * Clones inputs prior to processing.\n     * This option will return output objects with shared graphs in their path if specific operators are used.\n     * Use this option to keep the input collection immutable.\n     *\n     */\n    ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n    /**\n     * Clones the output to return distinct objects with no shared paths.\n     * This option modifies the input collection and during processing.\n     */\n    ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n    /**\n     * Turn off cloning and modifies the input collection as needed.\n     * This option will also return output objects with shared paths in their graph when specific operators are used.\n     *\n     * This option provides the greatest speedup for the biggest tradeoff. When using the aggregation pipeline, you can use\n     * the \"$out\" operator to collect immutable intermediate results.\n     *\n     * @default\n     */\n    ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nclass ComputeOptions {\n    options;\n    _root;\n    _local;\n    timestamp;\n    constructor(options, \n    /** Reference to the root object when processing subgraphs of the object. */\n    _root, _local, \n    /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n    timestamp = Date.now()) {\n        this.options = options;\n        this._root = _root;\n        this._local = _local;\n        this.timestamp = timestamp;\n        this.options = options;\n        this.update(_root, _local);\n    }\n    /**\n     * Initialize new ComputeOptions. Returns the same object modified when the 'options' argument is a ComputeOptions.\n     * @param options\n     * @param root\n     * @param local\n     * @returns\n     */\n    static init(options, root, local) {\n        return options instanceof ComputeOptions\n            ? options.update(\n            // value can be '0' or 'false'\n            (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(options.root) ? root : options.root, Object.assign({}, options.local, local))\n            : new ComputeOptions(options || initOptions(), root, local);\n    }\n    /** Updates the internal mutable state. */\n    update(root, local) {\n        // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n        this._root = root;\n        this._local = local;\n        return this;\n    }\n    get root() {\n        return this._root;\n    }\n    get local() {\n        return this._local;\n    }\n    get idKey() {\n        return this.options?.idKey;\n    }\n    get collation() {\n        return this.options?.collation;\n    }\n    get processingMode() {\n        return this.options?.processingMode || ProcessingMode.CLONE_OFF;\n    }\n    get useStrictMode() {\n        return this.options?.useStrictMode;\n    }\n    get scriptEnabled() {\n        return this.options?.scriptEnabled;\n    }\n    get hashFunction() {\n        return this.options?.hashFunction;\n    }\n    get collectionResolver() {\n        return this.options?.collectionResolver;\n    }\n    get jsonSchemaValidator() {\n        return this.options?.jsonSchemaValidator;\n    }\n    get variables() {\n        return this.options?.variables;\n    }\n}\n/**\n * Creates an Option from another required keys are initialized\n * @param options Options\n */\nfunction initOptions(options) {\n    return Object.freeze({\n        idKey: \"_id\",\n        scriptEnabled: true,\n        useStrictMode: true,\n        processingMode: ProcessingMode.CLONE_OFF,\n        ...options,\n    });\n}\n/**\n * The different groups of operators\n */\nvar OperatorType;\n(function (OperatorType) {\n    OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n    OperatorType[\"EXPRESSION\"] = \"expression\";\n    OperatorType[\"PIPELINE\"] = \"pipeline\";\n    OperatorType[\"PROJECTION\"] = \"projection\";\n    OperatorType[\"QUERY\"] = \"query\";\n    OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\n// operator definitions\nconst OPERATORS = {\n    [OperatorType.ACCUMULATOR]: {},\n    [OperatorType.EXPRESSION]: {},\n    [OperatorType.PIPELINE]: {},\n    [OperatorType.PROJECTION]: {},\n    [OperatorType.QUERY]: {},\n    [OperatorType.WINDOW]: {},\n};\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nfunction useOperators(type, operators) {\n    for (const [name, fn] of Object.entries(operators)) {\n        (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(fn instanceof Function && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isOperator)(name), `'${name}' is not a valid operator`);\n        const currentFn = getOperator(type, name);\n        (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n    }\n    // toss the operator salad :)\n    (0,_util__WEBPACK_IMPORTED_MODULE_0__.into)(OPERATORS[type], operators);\n}\n/**\n * Returns the operator function or null if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nfunction getOperator(type, operator) {\n    return OPERATORS[type][operator];\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n    $$ROOT(obj, expr, options) {\n        return options.root;\n    },\n    $$CURRENT(obj, expr, options) {\n        return obj;\n    },\n    $$REMOVE(obj, expr, options) {\n        return undefined;\n    },\n    $$NOW(obj, expr, options) {\n        return new Date(options.timestamp);\n    },\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n    $$KEEP(obj, expr, options) {\n        return obj;\n    },\n    $$PRUNE(obj, expr, options) {\n        return undefined;\n    },\n    $$DESCEND(obj, expr, options) {\n        // traverse nested documents iff there is a $cond\n        if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(expr, \"$cond\"))\n            return obj;\n        let result;\n        for (const [key, current] of Object.entries(obj)) {\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(current)) {\n                if (current instanceof Array) {\n                    const array = [];\n                    for (let elem of current) {\n                        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(elem)) {\n                            elem = redact(elem, expr, options.update(elem));\n                        }\n                        if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(elem)) {\n                            array.push(elem);\n                        }\n                    }\n                    result = array;\n                }\n                else {\n                    result = redact(current, expr, options.update(current));\n                }\n                if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNil)(result)) {\n                    delete obj[key]; // pruned result\n                }\n                else {\n                    obj[key] = result;\n                }\n            }\n        }\n        return obj;\n    },\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nfunction computeValue(obj, expr, operator, options) {\n    // ensure valid options exist on first invocation\n    const copts = ComputeOptions.init(options, obj);\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isOperator)(operator)) {\n        // if the field of the object is a valid operator\n        const callExpression = getOperator(OperatorType.EXPRESSION, operator);\n        if (callExpression)\n            return callExpression(obj, expr, copts);\n        // we also handle $group accumulator operators\n        const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator);\n        if (callAccumulator) {\n            // if object is not an array, first try to compute using the expression\n            if (!(obj instanceof Array)) {\n                obj = computeValue(obj, expr, null, copts);\n                expr = null;\n            }\n            // validate that we have an array\n            (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(obj instanceof Array, `'${operator}' target must be an array.`);\n            // for accumulators, we use the global options since the root is specific to each element within array.\n            return callAccumulator(obj, expr, \n            // reset the root object for accumulators.\n            copts.update(null, copts.local));\n        }\n        // operator was not found\n        throw new Error(`operator '${operator}' is not registered`);\n    }\n    // if expr is a string and begins with \"$$\", then we have a variable.\n    //  this can be one of; redact variable, system variable, user-defined variable.\n    //  we check and process them in that order.\n    //\n    // if expr begins only a single \"$\", then it is a path to a field on the object.\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) && expr.length > 0 && expr[0] === \"$\") {\n        // we return redact variables as literals\n        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(redactVariables, expr)) {\n            return expr;\n        }\n        // default to root for resolving path.\n        let context = copts.root;\n        // handle selectors with explicit prefix\n        const arr = expr.split(\".\");\n        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(systemVariables, arr[0])) {\n            // set 'root' only the first time it is required to be used for all subsequent calls\n            // if it already available on the options, it will be used\n            context = systemVariables[arr[0]](obj, null, copts);\n            expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n        }\n        else if (arr[0].slice(0, 2) === \"$$\") {\n            // handle user-defined variables\n            context = Object.assign({}, copts.variables, // global vars\n            // current item is added before local variables because the binding may be changed.\n            { this: obj }, copts.local?.variables // local vars\n            );\n            const prefix = arr[0].slice(2);\n            (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(context, prefix), `Use of undefined variable: ${prefix}`);\n            expr = expr.slice(2);\n        }\n        else {\n            // 'expr' is a path to a field on the object.\n            expr = expr.slice(1);\n        }\n        if (expr === \"\")\n            return context;\n        return (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(context, expr);\n    }\n    // check and return value if already in a resolved state\n    if (expr instanceof Array) {\n        return expr.map((item) => computeValue(obj, item, null, copts));\n    }\n    else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(expr)) {\n        const result = {};\n        for (const [key, val] of Object.entries(expr)) {\n            result[key] = computeValue(obj, val, key, copts);\n            // must run ONLY one aggregate operator per expression\n            // if so, return result of the computed value\n            if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((c) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(OPERATORS[c], key))) {\n                // there should be only one operator\n                (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n                return result[key];\n            }\n        }\n        return result;\n    }\n    return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nfunction redact(obj, expr, options) {\n    const result = computeValue(obj, expr, null, options);\n    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.has)(redactVariables, result)\n        ? redactVariables[result](obj, expr, options)\n        : result;\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/core.js?");

/***/ }),

/***/ "./node_modules/mingo/es/cursor.js":
/*!*****************************************!*\
  !*** ./node_modules/mingo/es/cursor.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cursor\": () => (/* binding */ Cursor)\n/* harmony export */ });\n/* harmony import */ var _aggregator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aggregator */ \"./node_modules/mingo/es/aggregator.js\");\n/* harmony import */ var _lazy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lazy */ \"./node_modules/mingo/es/lazy.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/mingo/es/util.js\");\n\n\n\n/**\n * Cursor to iterate and perform filtering on matched objects.\n * This object must not be used directly. A cursor may be obtaine from calling `find()` on an instance of `Query`.\n *\n * @param collection The input source of the collection\n * @param predicate A predicate function to test documents\n * @param projection A projection criteria\n * @param options Options\n * @constructor\n */\nclass Cursor {\n    source;\n    predicate;\n    projection;\n    options;\n    operators = [];\n    result = null;\n    buffer = [];\n    constructor(source, predicate, projection, options) {\n        this.source = source;\n        this.predicate = predicate;\n        this.projection = projection;\n        this.options = options;\n    }\n    /** Returns the iterator from running the query */\n    fetch() {\n        if (this.result)\n            return this.result;\n        // add projection operator\n        if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(this.projection)) {\n            this.operators.push({ $project: this.projection });\n        }\n        // filter collection\n        this.result = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)(this.source).filter(this.predicate);\n        if (this.operators.length > 0) {\n            this.result = new _aggregator__WEBPACK_IMPORTED_MODULE_0__.Aggregator(this.operators, this.options).stream(this.result);\n        }\n        return this.result;\n    }\n    /** Returns an iterator with the buffered data included */\n    fetchAll() {\n        const buffered = (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.Lazy)([...this.buffer]);\n        this.buffer = [];\n        return (0,_lazy__WEBPACK_IMPORTED_MODULE_1__.compose)(buffered, this.fetch());\n    }\n    /**\n     * Return remaining objects in the cursor as an array. This method exhausts the cursor\n     * @returns {Array}\n     */\n    all() {\n        return this.fetchAll().value();\n    }\n    /**\n     * Returns the number of objects return in the cursor. This method exhausts the cursor\n     * @returns {Number}\n     */\n    count() {\n        return this.all().length;\n    }\n    /**\n     * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n     * @param {Number} n the number of results to skip.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    skip(n) {\n        this.operators.push({ $skip: n });\n        return this;\n    }\n    /**\n     * Constrains the size of a cursor's result set.\n     * @param {Number} n the number of results to limit to.\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    limit(n) {\n        this.operators.push({ $limit: n });\n        return this;\n    }\n    /**\n     * Returns results ordered according to a sort specification.\n     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n     * @return {Cursor} Returns the cursor, so you can chain this call.\n     */\n    sort(modifier) {\n        this.operators.push({ $sort: modifier });\n        return this;\n    }\n    /**\n     * Specifies the collation for the cursor returned by the `mingo.Query.find`\n     * @param {*} spec\n     */\n    collation(spec) {\n        this.options = { ...this.options, collation: spec };\n        return this;\n    }\n    /**\n     * Returns the next document in a cursor.\n     * @returns {Object | Boolean}\n     */\n    next() {\n        // yield value obtains in hasNext()\n        if (this.buffer.length > 0) {\n            return this.buffer.pop();\n        }\n        const o = this.fetch().next();\n        if (o.done)\n            return;\n        return o.value;\n    }\n    /**\n     * Returns true if the cursor has documents and can be iterated.\n     * @returns {boolean}\n     */\n    hasNext() {\n        // there is a value in the buffer\n        if (this.buffer.length > 0)\n            return true;\n        const o = this.fetch().next();\n        if (o.done)\n            return false;\n        this.buffer.push(o.value);\n        return true;\n    }\n    /**\n     * Applies a function to each document in a cursor and collects the return values in an array.\n     * @param callback\n     * @returns {Array}\n     */\n    map(callback) {\n        return this.all().map(callback);\n    }\n    /**\n     * Applies a JavaScript function for every document in a cursor.\n     * @param callback\n     */\n    forEach(callback) {\n        this.all().forEach(callback);\n    }\n    [Symbol.iterator]() {\n        return this.fetchAll();\n    }\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/cursor.js?");

/***/ }),

/***/ "./node_modules/mingo/es/lazy.js":
/*!***************************************!*\
  !*** ./node_modules/mingo/es/lazy.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Iterator\": () => (/* binding */ Iterator),\n/* harmony export */   \"Lazy\": () => (/* binding */ Lazy),\n/* harmony export */   \"compose\": () => (/* binding */ compose)\n/* harmony export */ });\n/**\n * Returns an iterator\n * @param {*} source An iterable source (Array, Function, Generator, or Iterator)\n */\nfunction Lazy(source) {\n    return source instanceof Iterator ? source : new Iterator(source);\n}\nfunction compose(...iterators) {\n    let index = 0;\n    return Lazy(() => {\n        while (index < iterators.length) {\n            const o = iterators[index].next();\n            if (!o.done)\n                return o;\n            index++;\n        }\n        return { done: true };\n    });\n}\n/**\n * Checks whether the given object is compatible with a generator i.e Object{next:Function}\n * @param {*} o An object\n */\nfunction isGenerator(o) {\n    return (!!o && typeof o === \"object\" && o?.next instanceof Function);\n}\nfunction dropItem(array, i) {\n    const rest = array.slice(i + 1);\n    array.splice(i);\n    Array.prototype.push.apply(array, rest);\n}\n// stop iteration error\nconst DONE = new Error();\n// Lazy function actions\nvar Action;\n(function (Action) {\n    Action[Action[\"MAP\"] = 0] = \"MAP\";\n    Action[Action[\"FILTER\"] = 1] = \"FILTER\";\n    Action[Action[\"TAKE\"] = 2] = \"TAKE\";\n    Action[Action[\"DROP\"] = 3] = \"DROP\";\n})(Action || (Action = {}));\nfunction createCallback(nextFn, iteratees, buffer) {\n    let done = false;\n    let index = -1;\n    let bufferIndex = 0; // index for the buffer\n    return function (storeResult) {\n        // special hack to collect all values into buffer\n        try {\n            outer: while (!done) {\n                let o = nextFn();\n                index++;\n                let i = -1;\n                const size = iteratees.length;\n                let innerDone = false;\n                while (++i < size) {\n                    const r = iteratees[i];\n                    switch (r.action) {\n                        case Action.MAP:\n                            o = r.func(o, index);\n                            break;\n                        case Action.FILTER:\n                            if (!r.func(o, index))\n                                continue outer;\n                            break;\n                        case Action.TAKE:\n                            --r.count;\n                            if (!r.count)\n                                innerDone = true;\n                            break;\n                        case Action.DROP:\n                            --r.count;\n                            if (!r.count)\n                                dropItem(iteratees, i);\n                            continue outer;\n                        default:\n                            break outer;\n                    }\n                }\n                done = innerDone;\n                if (storeResult) {\n                    buffer[bufferIndex++] = o;\n                }\n                else {\n                    return { value: o, done: false };\n                }\n            }\n        }\n        catch (e) {\n            if (e !== DONE)\n                throw e;\n        }\n        done = true;\n        return { done };\n    };\n}\n/**\n * A lazy collection iterator yields a single value at time upon request\n */\nclass Iterator {\n    iteratees = [];\n    yieldedValues = [];\n    getNext;\n    isDone = false;\n    /**\n     * @param {*} source An iterable object or function.\n     *    Array - return one element per cycle\n     *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n     *    Function - call to return the next value\n     * @param {Function} fn An optional transformation function\n     */\n    constructor(source) {\n        let nextVal;\n        if (source instanceof Function) {\n            // make iterable\n            source = { next: source };\n        }\n        if (isGenerator(source)) {\n            const src = source;\n            nextVal = () => {\n                const o = src.next();\n                if (o.done)\n                    throw DONE;\n                return o.value;\n            };\n        }\n        else if (source instanceof Array) {\n            const data = source;\n            const size = data.length;\n            let index = 0;\n            nextVal = () => {\n                if (index < size)\n                    return data[index++];\n                throw DONE;\n            };\n        }\n        else if (!(source instanceof Function)) {\n            throw new Error(`Source is of type '${typeof source}'. Must be Array, Function, or Generator`);\n        }\n        // create next function\n        this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);\n    }\n    /**\n     * Add an iteratee to this lazy sequence\n     */\n    push(action, value) {\n        if (typeof value === \"function\") {\n            this.iteratees.push({ action, func: value });\n        }\n        else if (typeof value === \"number\") {\n            this.iteratees.push({ action, count: value });\n        }\n        return this;\n    }\n    next() {\n        return this.getNext();\n    }\n    // Iteratees methods\n    /**\n     * Transform each item in the sequence to a new value\n     * @param {Function} f\n     */\n    map(f) {\n        return this.push(Action.MAP, f);\n    }\n    /**\n     * Select only items matching the given predicate\n     * @param {Function} pred\n     */\n    filter(predicate) {\n        return this.push(Action.FILTER, predicate);\n    }\n    /**\n     * Take given numbe for values from sequence\n     * @param {Number} n A number greater than 0\n     */\n    take(n) {\n        return n > 0 ? this.push(Action.TAKE, n) : this;\n    }\n    /**\n     * Drop a number of values from the sequence\n     * @param {Number} n Number of items to drop greater than 0\n     */\n    drop(n) {\n        return n > 0 ? this.push(Action.DROP, n) : this;\n    }\n    // Transformations\n    /**\n     * Returns a new lazy object with results of the transformation\n     * The entire sequence is realized.\n     *\n     * @param {Function} fn Tranform function of type (Array) => (Any)\n     */\n    transform(fn) {\n        const self = this;\n        let iter;\n        return Lazy(() => {\n            if (!iter) {\n                iter = Lazy(fn(self.value()));\n            }\n            return iter.next();\n        });\n    }\n    // Terminal methods\n    /**\n     * Returns the fully realized values of the iterators.\n     * The return value will be an array unless `lazy.first()` was used.\n     * The realized values are cached for subsequent calls\n     */\n    value() {\n        if (!this.isDone) {\n            this.isDone = this.getNext(true).done;\n        }\n        return this.yieldedValues;\n    }\n    /**\n     * Execute the funcion for each value. Will stop when an execution returns false.\n     * @param {Function} f\n     * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n     */\n    each(f) {\n        for (;;) {\n            const o = this.next();\n            if (o.done)\n                break;\n            if (f(o.value) === false)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Returns the reduction of sequence according the reducing function\n     *\n     * @param {*} f a reducing function\n     * @param {*} init\n     */\n    reduce(f, initialValue) {\n        let o = this.next();\n        let i = 0;\n        if (initialValue === undefined && !o.done) {\n            initialValue = o.value;\n            o = this.next();\n            i++;\n        }\n        while (!o.done) {\n            initialValue = f(initialValue, o.value);\n            o = this.next();\n        }\n        return initialValue;\n    }\n    /**\n     * Returns the number of matched items in the sequence\n     */\n    size() {\n        return this.reduce((acc, _) => ++acc, 0);\n    }\n    [Symbol.iterator]() {\n        /* eslint-disable @typescript-eslint/no-unsafe-return */\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/lazy.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/_predicates.js":
/*!********************************************************!*\
  !*** ./node_modules/mingo/es/operators/_predicates.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$all\": () => (/* binding */ $all),\n/* harmony export */   \"$elemMatch\": () => (/* binding */ $elemMatch),\n/* harmony export */   \"$eq\": () => (/* binding */ $eq),\n/* harmony export */   \"$exists\": () => (/* binding */ $exists),\n/* harmony export */   \"$gt\": () => (/* binding */ $gt),\n/* harmony export */   \"$gte\": () => (/* binding */ $gte),\n/* harmony export */   \"$in\": () => (/* binding */ $in),\n/* harmony export */   \"$lt\": () => (/* binding */ $lt),\n/* harmony export */   \"$lte\": () => (/* binding */ $lte),\n/* harmony export */   \"$mod\": () => (/* binding */ $mod),\n/* harmony export */   \"$ne\": () => (/* binding */ $ne),\n/* harmony export */   \"$nin\": () => (/* binding */ $nin),\n/* harmony export */   \"$regex\": () => (/* binding */ $regex),\n/* harmony export */   \"$size\": () => (/* binding */ $size),\n/* harmony export */   \"$type\": () => (/* binding */ $type),\n/* harmony export */   \"createExpressionOperator\": () => (/* binding */ createExpressionOperator),\n/* harmony export */   \"createQueryOperator\": () => (/* binding */ createQueryOperator)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ \"./node_modules/mingo/es/core.js\");\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../query */ \"./node_modules/mingo/es/query.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ \"./node_modules/mingo/es/util.js\");\n/**\n * Predicates used for Query and Expression operators.\n */\n\n\n\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nfunction createQueryOperator(predicate) {\n    return (selector, value, options) => {\n        const opts = { unwrapArray: true };\n        const depth = Math.max(1, selector.split(\".\").length - 1);\n        return (obj) => {\n            // value of field must be fully resolved.\n            const lhs = (0,_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(obj, selector, opts);\n            return predicate(lhs, value, { ...options, depth });\n        };\n    };\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nfunction createExpressionOperator(predicate) {\n    return (obj, expr, options) => {\n        const args = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, expr, null, options);\n        return predicate(...args);\n    };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nfunction $eq(a, b, options) {\n    // start with simple equality check\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(a, b))\n        return true;\n    // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(a) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(b))\n        return true;\n    // check\n    if (a instanceof Array) {\n        const eq = _util__WEBPACK_IMPORTED_MODULE_2__.isEqual.bind(null, b);\n        return a.some(eq) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(a, options?.depth).some(eq);\n    }\n    return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $ne(a, b, options) {\n    return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nfunction $in(a, b, options) {\n    // queries for null should be able to find undefined fields\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNil)(a))\n        return b.some((v) => v === null);\n    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.intersection)([(0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a), b], options?.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nfunction $nin(a, b, options) {\n    return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $lt(a, b, options) {\n    return compare(a, b, (x, y) => x < y);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $lte(a, b, options) {\n    return compare(a, b, (x, y) => x <= y);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $gt(a, b, options) {\n    return compare(a, b, (x, y) => x > y);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $gte(a, b, options) {\n    return compare(a, b, (x, y) => x >= y);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $mod(a, b, options) {\n    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a).some((x) => b.length === 2 && x % b[0] === b[1]);\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $regex(a, b, options) {\n    const lhs = (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a);\n    const match = (x) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isString)(x) && !!b.exec(x);\n    return lhs.some(match) || (0,_util__WEBPACK_IMPORTED_MODULE_2__.flatten)(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $exists(a, b, options) {\n    return (((b === false || b === 0) && a === undefined) ||\n        ((b === true || b === 1) && a !== undefined));\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nfunction $all(values, queries, options) {\n    if (!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(values) ||\n        !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(queries) ||\n        !values.length ||\n        !queries.length) {\n        return false;\n    }\n    let matched = true;\n    for (const query of queries) {\n        // no need to check all the queries.\n        if (!matched)\n            break;\n        if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(query) && (0,_util__WEBPACK_IMPORTED_MODULE_2__.inArray)(Object.keys(query), \"$elemMatch\")) {\n            matched = $elemMatch(values, query[\"$elemMatch\"], options);\n        }\n        else if (query instanceof RegExp) {\n            matched = values.some((s) => typeof s === \"string\" && query.test(s));\n        }\n        else {\n            matched = values.some((v) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isEqual)(query, v));\n        }\n    }\n    return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nfunction $size(a, b, options) {\n    return a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.isOperator)(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nfunction $elemMatch(a, b, options) {\n    // should return false for non-matching input\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(a) && !(0,_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(a)) {\n        let format = (x) => x;\n        let criteria = b;\n        // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n        // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n        // like $and/$or/$nor; as otherwise, this faking will break our query.\n        if (Object.keys(b).every(isNonBooleanOperator)) {\n            criteria = { temp: b };\n            format = (x) => ({ temp: x });\n        }\n        const query = new _query__WEBPACK_IMPORTED_MODULE_1__.Query(criteria, options);\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (query.test(format(a[i]))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// helper functions\nconst isNull = (a) => a === null;\nconst isInt = (a) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(a) &&\n    a >= _util__WEBPACK_IMPORTED_MODULE_2__.MIN_INT &&\n    a <= _util__WEBPACK_IMPORTED_MODULE_2__.MAX_INT &&\n    a.toString().indexOf(\".\") === -1;\nconst isLong = (a) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(a) &&\n    a >= _util__WEBPACK_IMPORTED_MODULE_2__.MIN_LONG &&\n    a <= _util__WEBPACK_IMPORTED_MODULE_2__.MAX_LONG &&\n    a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n    array: _util__WEBPACK_IMPORTED_MODULE_2__.isArray,\n    bool: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,\n    boolean: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,\n    date: _util__WEBPACK_IMPORTED_MODULE_2__.isDate,\n    decimal: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,\n    double: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,\n    int: isInt,\n    long: isLong,\n    number: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,\n    null: isNull,\n    object: _util__WEBPACK_IMPORTED_MODULE_2__.isObject,\n    regex: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,\n    regexp: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,\n    string: _util__WEBPACK_IMPORTED_MODULE_2__.isString,\n    // added for completeness\n    undefined: _util__WEBPACK_IMPORTED_MODULE_2__.isNil,\n    function: (_) => {\n        throw new Error(\"unsupported type key `function`.\");\n    },\n    // Mongo identifiers\n    1: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber,\n    2: _util__WEBPACK_IMPORTED_MODULE_2__.isString,\n    3: _util__WEBPACK_IMPORTED_MODULE_2__.isObject,\n    4: _util__WEBPACK_IMPORTED_MODULE_2__.isArray,\n    6: _util__WEBPACK_IMPORTED_MODULE_2__.isNil,\n    8: _util__WEBPACK_IMPORTED_MODULE_2__.isBoolean,\n    9: _util__WEBPACK_IMPORTED_MODULE_2__.isDate,\n    10: isNull,\n    11: _util__WEBPACK_IMPORTED_MODULE_2__.isRegExp,\n    16: isInt,\n    18: isLong,\n    19: _util__WEBPACK_IMPORTED_MODULE_2__.isNumber, //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n    const f = compareFuncs[b];\n    return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction $type(a, b, options) {\n    return Array.isArray(b)\n        ? b.findIndex((t) => compareType(a, t, options)) >= 0\n        : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.ensureArray)(a).some((x) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.getType)(x) === (0,_util__WEBPACK_IMPORTED_MODULE_2__.getType)(b) && f(x, b));\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/_predicates.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/pipeline/project.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/es/operators/pipeline/project.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$project\": () => (/* binding */ $project)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core */ \"./node_modules/mingo/es/core.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ \"./node_modules/mingo/es/util.js\");\n\n\n/**\n * Reshapes a document stream.\n * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n *\n * @param collection\n * @param expr\n * @param opt\n * @returns {Array}\n */\nfunction $project(collection, expr, options) {\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(expr))\n        return collection;\n    // result collection\n    let expressionKeys = Object.keys(expr);\n    let idOnlyExcluded = false;\n    // validate inclusion and exclusion\n    validateExpression(expr, options);\n    const ID_KEY = options.idKey;\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.inArray)(expressionKeys, ID_KEY)) {\n        const id = expr[ID_KEY];\n        if (id === 0 || id === false) {\n            expressionKeys = expressionKeys.filter(_util__WEBPACK_IMPORTED_MODULE_1__.notInArray.bind(null, [ID_KEY]));\n            idOnlyExcluded = expressionKeys.length == 0;\n        }\n    }\n    else {\n        // if not specified the add the ID field\n        expressionKeys.push(ID_KEY);\n    }\n    const copts = _core__WEBPACK_IMPORTED_MODULE_0__.ComputeOptions.init(options);\n    return collection.map((obj) => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));\n}\n/**\n * Process the expression value for $project operators\n *\n * @param {Object} obj The object to use as options\n * @param {Object} expr The experssion object of $project operator\n * @param {Array} expressionKeys The key in the 'expr' object\n * @param {Boolean} idOnlyExcluded Boolean value indicating whether only the ID key is excluded\n */\nfunction processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {\n    let newObj = {};\n    let foundSlice = false;\n    let foundExclusion = false;\n    const dropKeys = [];\n    if (idOnlyExcluded) {\n        dropKeys.push(options.idKey);\n    }\n    for (const key of expressionKeys) {\n        // final computed value of the key\n        let value = undefined;\n        // expression to associate with key\n        const subExpr = expr[key];\n        if (key !== options.idKey && (0,_util__WEBPACK_IMPORTED_MODULE_1__.inArray)([0, false], subExpr)) {\n            foundExclusion = true;\n        }\n        if (key === options.idKey && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(subExpr)) {\n            // tiny optimization here to skip over id\n            value = obj[key];\n        }\n        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(subExpr)) {\n            value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, subExpr, key, options);\n        }\n        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.inArray)([1, true], subExpr)) {\n            // For direct projections, we use the resolved object value\n        }\n        else if (subExpr instanceof Array) {\n            value = subExpr.map((v) => {\n                const r = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, v, null, options);\n                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNil)(r))\n                    return null;\n                return r;\n            });\n        }\n        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(subExpr)) {\n            const subExprObj = subExpr;\n            const subExprKeys = Object.keys(subExpr);\n            const operator = subExprKeys.length == 1 ? subExprKeys[0] : null;\n            // first try a projection operator\n            const call = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)(_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.PROJECTION, operator);\n            if (call) {\n                // apply the projection operator on the operator expression for the key\n                if (operator === \"$slice\") {\n                    // $slice is handled differently for aggregation and projection operations\n                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.ensureArray)(subExprObj[operator]).every(_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)) {\n                        // $slice for projection operation\n                        value = call(obj, subExprObj[operator], key);\n                        foundSlice = true;\n                    }\n                    else {\n                        // $slice for aggregation operation\n                        value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, subExprObj, key, options);\n                    }\n                }\n                else {\n                    value = call(obj, subExprObj[operator], key, options);\n                }\n            }\n            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isOperator)(operator)) {\n                // compute if operator key\n                value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, subExprObj[operator], operator, options);\n            }\n            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.has)(obj, key)) {\n                // compute the value for the sub expression for the key\n                validateExpression(subExprObj, options);\n                let target = obj[key];\n                if (target instanceof Array) {\n                    value = target.map((o) => processObject(o, subExprObj, options, subExprKeys, false));\n                }\n                else {\n                    target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(target) ? target : obj;\n                    value = processObject(target, subExprObj, options, subExprKeys, false);\n                }\n            }\n            else {\n                // compute the value for the sub expression for the key\n                value = (0,_core__WEBPACK_IMPORTED_MODULE_0__.computeValue)(obj, subExpr, null, options);\n            }\n        }\n        else {\n            dropKeys.push(key);\n            continue;\n        }\n        // get value with object graph\n        const objPathGraph = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolveGraph)(obj, key, {\n            preserveMissing: true,\n        });\n        // add the value at the path\n        if (objPathGraph !== undefined) {\n            (0,_util__WEBPACK_IMPORTED_MODULE_1__.merge)(newObj, objPathGraph, {\n                flatten: true,\n            });\n        }\n        // if computed add/or remove accordingly\n        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.notInArray)([0, 1, false, true], subExpr)) {\n            if (value === undefined) {\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(newObj, key, { descendArray: true });\n            }\n            else {\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.setValue)(newObj, key, value);\n            }\n        }\n    }\n    // filter out all missing values preserved to support correct merging\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.filterMissing)(newObj);\n    // For the following cases we include all keys on the object that were not explicitly excluded.\n    //\n    // 1. projection included $slice operator\n    // 2. some fields were explicitly excluded\n    // 3. only the id field was excluded\n    if (foundSlice || foundExclusion || idOnlyExcluded) {\n        newObj = (0,_util__WEBPACK_IMPORTED_MODULE_1__.into)({}, obj, newObj);\n        if (dropKeys.length > 0) {\n            for (const k of dropKeys) {\n                (0,_util__WEBPACK_IMPORTED_MODULE_1__.removeValue)(newObj, k, { descendArray: true });\n            }\n        }\n    }\n    return newObj;\n}\n/**\n * Validate inclusion and exclusion values in expression\n *\n * @param {Object} expr The expression given for the projection\n */\nfunction validateExpression(expr, options) {\n    const check = [false, false];\n    for (const [k, v] of Object.entries(expr)) {\n        if (k === options.idKey)\n            return;\n        if (v === 0 || v === false) {\n            check[0] = true;\n        }\n        else if (v === 1 || v === true) {\n            check[1] = true;\n        }\n        (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)(!(check[0] && check[1]), \"Projection cannot have a mix of inclusion and exclusion.\");\n    }\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/pipeline/project.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/pipeline/sort.js":
/*!**********************************************************!*\
  !*** ./node_modules/mingo/es/operators/pipeline/sort.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$sort\": () => (/* binding */ $sort)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ \"./node_modules/mingo/es/util.js\");\n\n/**\n * Takes all input documents and returns them in a stream of sorted documents.\n *\n * @param collection\n * @param sortKeys\n * @param  {Object} options\n * @returns {*}\n */\nfunction $sort(collection, sortKeys, options) {\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(sortKeys) || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sortKeys))\n        return collection;\n    let cmp = _util__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COMPARATOR;\n    // check for collation spec on the options\n    const collationSpec = options.collation;\n    // use collation comparator if provided\n    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(collationSpec) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(collationSpec.locale)) {\n        cmp = collationComparator(collationSpec);\n    }\n    return collection.transform((coll) => {\n        const modifiers = Object.keys(sortKeys);\n        for (const key of modifiers.reverse()) {\n            const grouped = (0,_util__WEBPACK_IMPORTED_MODULE_0__.groupBy)(coll, (obj) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(obj, key), options?.hashFunction);\n            const sortedIndex = {};\n            const indexKeys = (0,_util__WEBPACK_IMPORTED_MODULE_0__.sortBy)(grouped.keys, (k, i) => {\n                sortedIndex[k] = i;\n                return k;\n            }, cmp);\n            if (sortKeys[key] === -1)\n                indexKeys.reverse();\n            coll = [];\n            for (const k of indexKeys) {\n                (0,_util__WEBPACK_IMPORTED_MODULE_0__.into)(coll, grouped.groups[sortedIndex[k]]);\n            }\n        }\n        return coll;\n    });\n}\n// MongoDB collation strength to JS localeCompare sensitivity mapping.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\nconst COLLATION_STRENGTH = {\n    // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.\n    1: \"base\",\n    //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n    // Examples: a ≠ b, a ≠ á, a = A.\n    2: \"accent\",\n    // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n    // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A\n    3: \"variant\",\n    // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.\n};\n/**\n * Creates a comparator function for the given collation spec. See https://docs.mongodb.com/manual/reference/collation/\n *\n * @param spec {Object} The MongoDB collation spec.\n * {\n *   locale: string,\n *   caseLevel: boolean,\n *   caseFirst: string,\n *   strength: int,\n *   numericOrdering: boolean,\n *   alternate: string,\n *   maxVariable: string, // unsupported\n *   backwards: boolean // unsupported\n * }\n */\nfunction collationComparator(spec) {\n    const localeOpt = {\n        sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n        caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n        numeric: spec.numericOrdering || false,\n        ignorePunctuation: spec.alternate === \"shifted\",\n    };\n    // when caseLevel is true for strength  1:base and 2:accent, bump sensitivity to the nearest that supports case comparison\n    if ((spec.caseLevel || false) === true) {\n        if (localeOpt.sensitivity === \"base\")\n            localeOpt.sensitivity = \"case\";\n        if (localeOpt.sensitivity === \"accent\")\n            localeOpt.sensitivity = \"variant\";\n    }\n    const collator = new Intl.Collator(spec.locale, localeOpt);\n    return (a, b) => {\n        // non strings\n        if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(a) || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(b))\n            return (0,_util__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COMPARATOR)(a, b);\n        // only for strings\n        const i = collator.compare(a, b);\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            return 1;\n        return 0;\n    };\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/pipeline/sort.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/array/elemMatch.js":
/*!******************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/array/elemMatch.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$elemMatch\": () => (/* binding */ $elemMatch)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Array Operators: https://docs.mongodb.com/manual/reference/operator/query-array/\n\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch conditions.\n */\nconst $elemMatch = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$elemMatch);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/array/elemMatch.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/array/size.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/array/size.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$size\": () => (/* binding */ $size)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Array Operators: https://docs.mongodb.com/manual/reference/operator/query-array/\n\n/**\n * Selects documents if the array field is a specified size.\n */\nconst $size = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$size);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/array/size.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/eq.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/eq.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$eq\": () => (/* binding */ $eq)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches values that are equal to a specified value.\n */\nconst $eq = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$eq);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/eq.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/gt.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/gt.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$gt\": () => (/* binding */ $gt)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches values that are greater than a specified value.\n */\nconst $gt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gt);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/gt.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/gte.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/gte.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$gte\": () => (/* binding */ $gte)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * \tMatches values that are greater than or equal to a specified value.\n */\nconst $gte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$gte);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/gte.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/in.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/in.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$in\": () => (/* binding */ $in)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches any of the values that exist in an array specified in the query.\n */\nconst $in = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$in);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/in.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/lt.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/lt.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$lt\": () => (/* binding */ $lt)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches values that are less than the value specified in the query.\n */\nconst $lt = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lt);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/lt.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/lte.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/lte.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$lte\": () => (/* binding */ $lte)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches values that are less than or equal to the value specified in the query.\n */\nconst $lte = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$lte);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/lte.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/ne.js":
/*!****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/ne.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$ne\": () => (/* binding */ $ne)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches all values that are not equal to the value specified in the query.\n */\nconst $ne = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$ne);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/ne.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/comparison/nin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/comparison/nin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$nin\": () => (/* binding */ $nin)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Comparison Operators: https://docs.mongodb.com/manual/reference/operator/query-comparison/\n\n/**\n * Matches values that do not exist in an array specified to the query.\n */\nconst $nin = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$nin);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/comparison/nin.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/element/exists.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/element/exists.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$exists\": () => (/* binding */ $exists)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Element Operators: https://docs.mongodb.com/manual/reference/operator/query-element/\n\n/**\n * Matches documents that have the specified field.\n */\nconst $exists = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$exists);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/element/exists.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/element/type.js":
/*!***************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/element/type.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$type\": () => (/* binding */ $type)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Element Operators: https://docs.mongodb.com/manual/reference/operator/query-element/\n\n/**\n * Selects documents if a field is of the specified type.\n */\nconst $type = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$type);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/element/type.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/evaluation/mod.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/evaluation/mod.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$mod\": () => (/* binding */ $mod)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Evaluation Operators: https://docs.mongodb.com/manual/reference/operator/query-evaluation/\n\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n */\nconst $mod = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$mod);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/evaluation/mod.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/evaluation/regex.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/evaluation/regex.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$regex\": () => (/* binding */ $regex)\n/* harmony export */ });\n/* harmony import */ var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_predicates */ \"./node_modules/mingo/es/operators/_predicates.js\");\n// Query Evaluation Operators: https://docs.mongodb.com/manual/reference/operator/query-evaluation/\n\n/**\n * Selects documents where values match a specified regular expression.\n */\nconst $regex = (0,_predicates__WEBPACK_IMPORTED_MODULE_0__.createQueryOperator)(_predicates__WEBPACK_IMPORTED_MODULE_0__.$regex);\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/evaluation/regex.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/logical/and.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/logical/and.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$and\": () => (/* binding */ $and)\n/* harmony export */ });\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ \"./node_modules/mingo/es/query.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ \"./node_modules/mingo/es/util.js\");\n// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\n\n\n/**\n * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nfunction $and(selector, value, options) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(value), \"Invalid expression: $and expects value to be an Array\");\n    const queries = new Array();\n    value.forEach((expr) => queries.push(new _query__WEBPACK_IMPORTED_MODULE_0__.Query(expr, options)));\n    return (obj) => {\n        for (let i = 0; i < queries.length; i++) {\n            if (!queries[i].test(obj)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/logical/and.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/logical/nor.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/logical/nor.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$nor\": () => (/* binding */ $nor)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ \"./node_modules/mingo/es/util.js\");\n/* harmony import */ var _or__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./or */ \"./node_modules/mingo/es/operators/query/logical/or.js\");\n// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\n\n\n/**\n * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nfunction $nor(selector, value, options) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_0__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value), \"Invalid expression. $nor expects value to be an Array\");\n    const f = (0,_or__WEBPACK_IMPORTED_MODULE_1__.$or)(\"$or\", value, options);\n    return (obj) => !f(obj);\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/logical/nor.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/logical/not.js":
/*!**************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/logical/not.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$not\": () => (/* binding */ $not)\n/* harmony export */ });\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ \"./node_modules/mingo/es/query.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ \"./node_modules/mingo/es/util.js\");\n// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\n\n\n/**\n * Inverts the effect of a query expression and returns documents that do not match the query expression.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nfunction $not(selector, value, options) {\n    const criteria = {};\n    criteria[selector] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(value);\n    const query = new _query__WEBPACK_IMPORTED_MODULE_0__.Query(criteria, options);\n    return (obj) => !query.test(obj);\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/logical/not.js?");

/***/ }),

/***/ "./node_modules/mingo/es/operators/query/logical/or.js":
/*!*************************************************************!*\
  !*** ./node_modules/mingo/es/operators/query/logical/or.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$or\": () => (/* binding */ $or)\n/* harmony export */ });\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../query */ \"./node_modules/mingo/es/query.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util */ \"./node_modules/mingo/es/util.js\");\n// Query Logical Operators: https://docs.mongodb.com/manual/reference/operator/query-logical/\n\n\n/**\n * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.\n *\n * @param selector\n * @param value\n * @returns {Function}\n */\nfunction $or(selector, value, options) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(value), \"Invalid expression. $or expects value to be an Array\");\n    const queries = value.map((expr) => new _query__WEBPACK_IMPORTED_MODULE_0__.Query(expr, options));\n    return (obj) => {\n        for (let i = 0; i < queries.length; i++) {\n            if (queries[i].test(obj)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/operators/query/logical/or.js?");

/***/ }),

/***/ "./node_modules/mingo/es/query.js":
/*!****************************************!*\
  !*** ./node_modules/mingo/es/query.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Query\": () => (/* binding */ Query)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./node_modules/mingo/es/core.js\");\n/* harmony import */ var _cursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cursor */ \"./node_modules/mingo/es/cursor.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/mingo/es/util.js\");\n\n\n\n/**\n * An object used to filter input documents\n *\n * @param {Object} criteria The criteria for constructing predicates\n * @param {Options} options Options for use by operators\n * @constructor\n */\nclass Query {\n    criteria;\n    options;\n    compiled;\n    constructor(criteria, options) {\n        this.criteria = criteria;\n        this.options = options;\n        this.options = (0,_core__WEBPACK_IMPORTED_MODULE_0__.initOptions)(options);\n        this.compiled = [];\n        this.compile();\n    }\n    compile() {\n        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(this.criteria), \"query criteria must be an object\");\n        let whereOperator;\n        for (const [field, expr] of Object.entries(this.criteria)) {\n            if (\"$where\" === field) {\n                whereOperator = { field: field, expr: expr };\n            }\n            else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.inArray)([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"], field)) {\n                this.processOperator(field, field, expr);\n            }\n            else {\n                // normalize expression\n                (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!(0,_util__WEBPACK_IMPORTED_MODULE_2__.isOperator)(field), `unknown top level operator: ${field}`);\n                for (const [operator, val] of Object.entries((0,_util__WEBPACK_IMPORTED_MODULE_2__.normalize)(expr))) {\n                    this.processOperator(field, operator, val);\n                }\n            }\n            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(whereOperator)) {\n                this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);\n            }\n        }\n    }\n    processOperator(field, operator, value) {\n        const call = (0,_core__WEBPACK_IMPORTED_MODULE_0__.getOperator)(_core__WEBPACK_IMPORTED_MODULE_0__.OperatorType.QUERY, operator);\n        (0,_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!!call, `unknown operator ${operator}`);\n        const fn = call(field, value, this.options);\n        this.compiled.push(fn);\n    }\n    /**\n     * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n     *\n     * @param obj The object to test\n     * @returns {boolean} True or false\n     */\n    test(obj) {\n        for (let i = 0, len = this.compiled.length; i < len; i++) {\n            if (!this.compiled[i](obj)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a cursor to select matching documents from the input source.\n     *\n     * @param source A source providing a sequence of documents\n     * @param projection An optional projection criteria\n     * @returns {Cursor} A Cursor for iterating over the results\n     */\n    find(collection, projection) {\n        return new _cursor__WEBPACK_IMPORTED_MODULE_1__.Cursor(collection, (x) => this.test(x), projection || {}, this.options);\n    }\n    /**\n     * Remove matched documents from the collection returning the remainder\n     *\n     * @param collection An array of documents\n     * @returns {Array} A new array with matching elements removed\n     */\n    remove(collection) {\n        return collection.reduce((acc, obj) => {\n            if (!this.test(obj))\n                acc.push(obj);\n            return acc;\n        }, []);\n    }\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/query.js?");

/***/ }),

/***/ "./node_modules/mingo/es/util.js":
/*!***************************************!*\
  !*** ./node_modules/mingo/es/util.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEFAULT_COMPARATOR\": () => (/* binding */ DEFAULT_COMPARATOR),\n/* harmony export */   \"MAX_INT\": () => (/* binding */ MAX_INT),\n/* harmony export */   \"MAX_LONG\": () => (/* binding */ MAX_LONG),\n/* harmony export */   \"MIN_INT\": () => (/* binding */ MIN_INT),\n/* harmony export */   \"MIN_LONG\": () => (/* binding */ MIN_LONG),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"cloneDeep\": () => (/* binding */ cloneDeep),\n/* harmony export */   \"ensureArray\": () => (/* binding */ ensureArray),\n/* harmony export */   \"filterMissing\": () => (/* binding */ filterMissing),\n/* harmony export */   \"flatten\": () => (/* binding */ flatten),\n/* harmony export */   \"getType\": () => (/* binding */ getType),\n/* harmony export */   \"groupBy\": () => (/* binding */ groupBy),\n/* harmony export */   \"has\": () => (/* binding */ has),\n/* harmony export */   \"hashCode\": () => (/* binding */ hashCode),\n/* harmony export */   \"inArray\": () => (/* binding */ inArray),\n/* harmony export */   \"intersection\": () => (/* binding */ intersection),\n/* harmony export */   \"into\": () => (/* binding */ into),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBoolean\": () => (/* binding */ isBoolean),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isEqual\": () => (/* binding */ isEqual),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isMissing\": () => (/* binding */ isMissing),\n/* harmony export */   \"isNil\": () => (/* binding */ isNil),\n/* harmony export */   \"isNumber\": () => (/* binding */ isNumber),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isObjectLike\": () => (/* binding */ isObjectLike),\n/* harmony export */   \"isOperator\": () => (/* binding */ isOperator),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"memoize\": () => (/* binding */ memoize),\n/* harmony export */   \"merge\": () => (/* binding */ merge),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"notInArray\": () => (/* binding */ notInArray),\n/* harmony export */   \"objectMap\": () => (/* binding */ objectMap),\n/* harmony export */   \"removeValue\": () => (/* binding */ removeValue),\n/* harmony export */   \"resolve\": () => (/* binding */ resolve),\n/* harmony export */   \"resolveGraph\": () => (/* binding */ resolveGraph),\n/* harmony export */   \"setValue\": () => (/* binding */ setValue),\n/* harmony export */   \"sortBy\": () => (/* binding */ sortBy),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify),\n/* harmony export */   \"truthy\": () => (/* binding */ truthy),\n/* harmony export */   \"unique\": () => (/* binding */ unique)\n/* harmony export */ });\n/**\n * Utility constants and functions\n */\nconst MAX_INT = 2147483647;\nconst MIN_INT = -2147483648;\nconst MAX_LONG = Number.MAX_SAFE_INTEGER;\nconst MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = (value) => {\n    const s = stringify(value);\n    let hash = 0;\n    let i = s.length;\n    while (i)\n        hash = ((hash << 5) - hash) ^ s.charCodeAt(--i);\n    return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\n    \"null\",\n    \"undefined\",\n    \"boolean\",\n    \"number\",\n    \"string\",\n    \"date\",\n    \"regexp\",\n]);\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n    null: 0,\n    undefined: 0,\n    number: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    boolean: 5,\n    date: 6,\n    regexp: 7,\n    function: 8,\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nconst DEFAULT_COMPARATOR = (a, b) => {\n    if (a === MISSING)\n        a = undefined;\n    if (b === MISSING)\n        b = undefined;\n    const u = SORT_ORDER_BY_TYPE[getType(a).toLowerCase()];\n    const v = SORT_ORDER_BY_TYPE[getType(b).toLowerCase()];\n    if (u !== v)\n        return u - v;\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n};\nconst OBJECT_PROTOTYPE = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nfunction assert(condition, message) {\n    if (!condition)\n        throw new Error(message);\n}\n/**\n * Deep clone an object\n */\nfunction cloneDeep(obj) {\n    if (obj instanceof Array)\n        return obj.map(cloneDeep);\n    if (obj instanceof Date)\n        return new Date(obj);\n    if (isObject(obj))\n        return objectMap(obj, cloneDeep);\n    return obj;\n}\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nfunction getType(v) {\n    return OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\n}\nfunction isBoolean(v) {\n    return typeof v === \"boolean\";\n}\nfunction isString(v) {\n    return typeof v === \"string\";\n}\nfunction isNumber(v) {\n    return !isNaN(v) && typeof v === \"number\";\n}\nconst isArray = Array.isArray;\nfunction isObject(v) {\n    if (!v)\n        return false;\n    const proto = Object.getPrototypeOf(v);\n    return ((proto === OBJECT_PROTOTYPE || proto === null) &&\n        OBJECT_TAG === Object.prototype.toString.call(v));\n}\nfunction isObjectLike(v) {\n    return v === Object(v);\n} // objects, arrays, functions, date, custom object\nfunction isDate(v) {\n    return v instanceof Date;\n}\nfunction isRegExp(v) {\n    return v instanceof RegExp;\n}\nfunction isFunction(v) {\n    return typeof v === \"function\";\n}\nfunction isNil(v) {\n    return v === null || v === undefined;\n}\nfunction inArray(arr, item) {\n    return arr.includes(item);\n}\nfunction notInArray(arr, item) {\n    return !inArray(arr, item);\n}\nfunction truthy(arg) {\n    return !!arg;\n}\nfunction isEmpty(x) {\n    return (isNil(x) ||\n        (isString(x) && !x) ||\n        (x instanceof Array && x.length === 0) ||\n        (isObject(x) && Object.keys(x).length === 0));\n}\nfunction isMissing(m) {\n    return m === MISSING;\n}\n// ensure a value is an array or wrapped within one\nfunction ensureArray(x) {\n    return x instanceof Array ? x : [x];\n}\nfunction has(obj, prop) {\n    return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\n/**\n * Transform values in an object\n *\n * @param  {Object}   obj   An object whose values to transform\n * @param  {Function} fn The transform function\n * @return {Array|Object} Result object after applying the transform\n */\nfunction objectMap(obj, fn) {\n    const o = {};\n    const objKeys = Object.keys(obj);\n    for (let i = 0; i < objKeys.length; i++) {\n        const k = objKeys[i];\n        o[k] = fn(obj[k], k);\n    }\n    return o;\n}\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the source value (right hand side) is returned.\n * If inputs are arrays of same length and all elements are mergable, elements in the same position are merged together.\n * If AnyVal of the elements are unmergeable, elements in the source are appended to the target.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nfunction merge(target, obj, options) {\n    // take care of missing inputs\n    if (isMissing(target))\n        return obj;\n    if (isMissing(obj))\n        return target;\n    const inputs = [target, obj];\n    if (!(inputs.every(isObject) || inputs.every(isArray))) {\n        throw Error(\"mismatched types. must both be array or object\");\n    }\n    // default options\n    options = options || { flatten: false };\n    if (isArray(target)) {\n        const result = target;\n        const input = obj;\n        if (options.flatten) {\n            let i = 0;\n            let j = 0;\n            while (i < result.length && j < input.length) {\n                result[i] = merge(result[i++], input[j++], options);\n            }\n            while (j < input.length) {\n                result.push(obj[j++]);\n            }\n        }\n        else {\n            into(result, input);\n        }\n    }\n    else {\n        Object.keys(obj).forEach((k) => {\n            if (has(obj, k)) {\n                if (has(target, k)) {\n                    target[k] = merge(target[k], obj[k], options);\n                }\n                else {\n                    target[k] = obj[k];\n                }\n            }\n        });\n    }\n    return target;\n}\nfunction addIndex(root, key, index) {\n    if (root.key < key) {\n        if (root.right) {\n            addIndex(root.right, key, index);\n        }\n        else {\n            root.right = { key, indexes: [index] };\n        }\n    }\n    else if (root.key > key) {\n        if (root.left) {\n            addIndex(root.left, key, index);\n        }\n        else {\n            root.left = { key, indexes: [index] };\n        }\n    }\n    else {\n        root.indexes.push(index);\n    }\n}\nfunction getIndexes(root, key) {\n    if (root.key == key) {\n        return root.indexes;\n    }\n    else if (root.key < key) {\n        return root.right ? getIndexes(root.right, key) : undefined;\n    }\n    else if (root.key > key) {\n        return root.left ? getIndexes(root.left, key) : undefined;\n    }\n    return undefined;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} a The first array\n * @param  {Array} b The second array\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array}    Result array\n */\nfunction intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n    // if any array is empty, there is no intersection\n    if (input.some((arr) => arr.length == 0))\n        return [];\n    // sort input arrays by size\n    const sortedIndex = input.map((a, i) => [i, a.length]);\n    sortedIndex.sort((a, b) => a[1] - b[1]);\n    // matched items index of first array for all other arrays.\n    const result = [];\n    const smallestArray = input[sortedIndex[0][0]];\n    const root = {\n        key: hashCode(smallestArray[0], hashFunction),\n        indexes: [0],\n    };\n    for (let i = 1; i < smallestArray.length; i++) {\n        const val = smallestArray[i];\n        const h = hashCode(val, hashFunction);\n        addIndex(root, h, i);\n    }\n    let maxResultSize = sortedIndex[0][1];\n    const orderedIndexes = [];\n    for (let i = 1; i < sortedIndex.length; i++) {\n        const arrayIndex = sortedIndex[i][0];\n        const data = input[arrayIndex];\n        // number of matched items\n        let size = 0;\n        for (let j = 0; j < data.length; j++) {\n            const h = hashCode(data[j], hashFunction);\n            const indexes = getIndexes(root, h);\n            // not included.\n            if (!indexes)\n                continue;\n            // check items equality to mitigate hash collisions and select the matching index.\n            const idx = indexes\n                .map((n) => smallestArray[n])\n                .findIndex((v) => isEqual(v, data[j]));\n            // not included\n            if (idx == -1)\n                continue;\n            // item matched. ensure map exist for marking index\n            if (result.length < i)\n                result.push({});\n            // map to index of the actual value and set position\n            result[result.length - 1][indexes[idx]] = true;\n            // if we have seen max result items we can stop.\n            size = Object.keys(result[result.length - 1]).length;\n            // ensure stabilty\n            if (arrayIndex == 0) {\n                if (orderedIndexes.indexOf(indexes[idx]) == -1) {\n                    orderedIndexes.push(indexes[idx]);\n                }\n            }\n        }\n        // no intersection if nothing found\n        if (size == 0)\n            return [];\n        // new max result size\n        maxResultSize = Math.min(maxResultSize, size);\n    }\n    const freq = {};\n    // count occurrences\n    result.forEach((m) => {\n        Object.keys(m).forEach((k) => {\n            const n = parseFloat(k);\n            freq[n] = freq[n] || 0;\n            freq[n]++;\n        });\n    });\n    const keys = orderedIndexes;\n    if (keys.length == 0) {\n        // note: cannot use parseInt due to second argument for radix.\n        keys.push(...Object.keys(freq).map(parseFloat));\n        keys.sort();\n    }\n    return keys\n        .filter((n) => freq[n] == input.length - 1)\n        .map((n) => smallestArray[n]);\n}\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nfunction flatten(xs, depth) {\n    const arr = [];\n    function flatten2(ys, n) {\n        for (let i = 0, len = ys.length; i < len; i++) {\n            if (isArray(ys[i]) && (n > 0 || n < 0)) {\n                flatten2(ys[i], Math.max(-1, n - 1));\n            }\n            else {\n                arr.push(ys[i]);\n            }\n        }\n    }\n    flatten2(xs, depth);\n    return arr;\n}\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nfunction isEqual(a, b) {\n    const lhs = [a];\n    const rhs = [b];\n    while (lhs.length > 0) {\n        a = lhs.pop();\n        b = rhs.pop();\n        // strictly equal must be equal.\n        if (a === b)\n            continue;\n        // unequal types and functions cannot be equal.\n        const nativeType = getType(a).toLowerCase();\n        if (nativeType !== getType(b).toLowerCase() || nativeType === \"function\") {\n            return false;\n        }\n        // leverage toString for Date and RegExp types\n        if (nativeType === \"array\") {\n            const xs = a;\n            const ys = b;\n            if (xs.length !== ys.length)\n                return false;\n            if (xs.length === ys.length && xs.length === 0)\n                continue;\n            into(lhs, xs);\n            into(rhs, ys);\n        }\n        else if (nativeType === \"object\") {\n            // deep compare objects\n            const aKeys = Object.keys(a);\n            const bKeys = Object.keys(b);\n            // check length of keys early\n            if (aKeys.length !== bKeys.length)\n                return false;\n            // compare keys\n            for (let i = 0, len = aKeys.length; i < len; i++) {\n                const k = aKeys[i];\n                // not found\n                if (!has(b, k))\n                    return false;\n                // key found\n                lhs.push(a[k]);\n                rhs.push(b[k]);\n            }\n        }\n        else {\n            // compare encoded values\n            if (stringify(a) !== stringify(b))\n                return false;\n        }\n    }\n    return lhs.length === 0;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}\n */\nfunction unique(xs, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (xs.length == 0)\n        return [];\n    const root = {\n        key: hashCode(xs[0], hashFunction),\n        indexes: [0],\n    };\n    // hash items on to tree to track collisions\n    for (let i = 1; i < xs.length; i++) {\n        addIndex(root, hashCode(xs[i], hashFunction), i);\n    }\n    const result = [];\n    // walk tree and remove duplicates\n    const stack = [root];\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (node.indexes.length == 1) {\n            result.push(node.indexes[0]);\n        }\n        else {\n            // handle collisions by matching all items\n            const arr = node.indexes;\n            // we start by search from the back so we maintain the smaller index when there is a duplicate.\n            while (arr.length > 0) {\n                for (let j = 1; j < arr.length; j++) {\n                    // if last item matches any remove the last item.\n                    if (isEqual(xs[arr[arr.length - 1]], xs[arr[arr.length - 1 - j]])) {\n                        // remove last item\n                        arr.pop();\n                        // reset position\n                        j = 0;\n                    }\n                }\n                // add the unique item\n                result.push(arr.pop());\n            }\n        }\n        // add children\n        if (node.left)\n            stack.push(node.left);\n        if (node.right)\n            stack.push(node.right);\n    }\n    // sort indexes for stability\n    result.sort();\n    // return the unique items\n    return result.map((i) => xs[i]);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n *\n * @param value\n * @returns {*}\n */\nfunction stringify(value) {\n    const type = getType(value).toLowerCase();\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"regexp\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"date\":\n            return value.toISOString();\n        case \"null\":\n        case \"undefined\":\n            return type;\n        case \"array\":\n            return \"[\" + value.map(stringify).join(\",\") + \"]\";\n        default:\n            break;\n    }\n    // default case\n    const prefix = type === \"object\" ? \"\" : `${getType(value)}`;\n    const objKeys = Object.keys(value);\n    objKeys.sort();\n    return (`${prefix}{` +\n        objKeys.map((k) => `${stringify(k)}:${stringify(value[k])}`).join(\",\") +\n        \"}\");\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nfunction hashCode(value, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (isNil(value))\n        return null;\n    return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nfunction sortBy(collection, keyFn, comparator = DEFAULT_COMPARATOR) {\n    const sorted = [];\n    const result = [];\n    if (isEmpty(collection))\n        return collection;\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        if (isNil(key)) {\n            result.push(obj);\n        }\n        else {\n            sorted.push([key, obj]);\n        }\n    }\n    // use native array sorting but enforce stableness\n    sorted.sort((a, b) => comparator(a[0], b[0]));\n    result.push(...sorted.map((o) => o[1]));\n    return result;\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {{keys: Array, groups: Array}}\n */\nfunction groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    const result = {\n        keys: new Array(),\n        groups: new Array(),\n    };\n    const lookup = {};\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        const hash = hashCode(key, hashFunction);\n        let index = -1;\n        if (lookup[hash] === undefined) {\n            index = result.keys.length;\n            lookup[hash] = index;\n            result.keys.push(key);\n            result.groups.push([]);\n        }\n        index = lookup[hash];\n        result.groups[index].push(obj);\n    }\n    return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nfunction into(target, ...rest) {\n    if (target instanceof Array) {\n        return rest.reduce((acc, arr) => {\n            // push arrary in batches to handle large inputs\n            let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n            let begin = 0;\n            while (i-- > 0) {\n                Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n                begin += MAX_ARRAY_PUSH;\n            }\n            return acc;\n        }, target);\n    }\n    else {\n        // merge objects. same behaviour as Object.assign\n        return rest.filter(isObjectLike).reduce((acc, item) => {\n            Object.assign(acc, item);\n            return acc;\n        }, target);\n    }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nfunction memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    return ((memo) => {\n        return (...args) => {\n            const key = hashCode(args, hashFunction);\n            if (!has(memo, key)) {\n                memo[key] = fn.apply(this, args);\n            }\n            return memo[key];\n        };\n    })({\n    /* storage */\n    });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n    return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n    if (depth < 1)\n        return arr;\n    while (depth-- && arr.length === 1)\n        arr = arr[0];\n    return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nfunction resolve(obj, selector, options) {\n    let depth = 0;\n    function resolve2(o, path) {\n        let value = o;\n        for (let i = 0; i < path.length; i++) {\n            const field = path[i];\n            const isText = /^\\d+$/.exec(field) === null;\n            // using instanceof to aid typescript compiler\n            if (isText && value instanceof Array) {\n                // On the first iteration, we check if we received a stop flag.\n                // If so, we stop to prevent iterating over a nested array value\n                // on consecutive object keys in the selector.\n                if (i === 0 && depth > 0)\n                    break;\n                depth += 1;\n                // only look at the rest of the path\n                const subpath = path.slice(i);\n                value = value.reduce((acc, item) => {\n                    const v = resolve2(item, subpath);\n                    if (v !== undefined)\n                        acc.push(v);\n                    return acc;\n                }, []);\n                break;\n            }\n            else {\n                value = getValue(value, field);\n            }\n            if (value === undefined)\n                break;\n        }\n        return value;\n    }\n    const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase())\n        ? obj\n        : resolve2(obj, selector.split(\".\"));\n    return result instanceof Array && options?.unwrapArray\n        ? unwrap(result, depth)\n        : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nfunction resolveGraph(obj, selector, options) {\n    const names = selector.split(\".\");\n    const key = names[0];\n    // get the next part of the selector\n    const next = names.slice(1).join(\".\");\n    const isIndex = /^\\d+$/.exec(key) !== null;\n    const hasNext = names.length > 1;\n    let result;\n    let value;\n    if (obj instanceof Array) {\n        if (isIndex) {\n            result = getValue(obj, Number(key));\n            if (hasNext) {\n                result = resolveGraph(result, next, options);\n            }\n            result = [result];\n        }\n        else {\n            result = [];\n            for (const item of obj) {\n                value = resolveGraph(item, selector, options);\n                if (options?.preserveMissing) {\n                    if (value === undefined) {\n                        value = MISSING;\n                    }\n                    result.push(value);\n                }\n                else if (value !== undefined) {\n                    result.push(value);\n                }\n            }\n        }\n    }\n    else {\n        value = getValue(obj, key);\n        if (hasNext) {\n            value = resolveGraph(value, next, options);\n        }\n        if (value === undefined)\n            return undefined;\n        result = options?.preserveKeys ? { ...obj } : {};\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nfunction filterMissing(obj) {\n    if (obj instanceof Array) {\n        for (let i = obj.length - 1; i >= 0; i--) {\n            if (obj[i] === MISSING) {\n                obj.splice(i, 1);\n            }\n            else {\n                filterMissing(obj[i]);\n            }\n        }\n    }\n    else if (isObject(obj)) {\n        for (const k in obj) {\n            if (has(obj, k)) {\n                filterMissing(obj[k]);\n            }\n        }\n    }\n}\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} fn Function to execute for value at the end the traversal\n * @return {*}\n */\nfunction walk(obj, selector, fn, options) {\n    if (isNil(obj))\n        return;\n    const names = selector.split(\".\");\n    const key = names[0];\n    const next = names.slice(1).join(\".\");\n    if (names.length === 1) {\n        fn(obj, key);\n    }\n    else {\n        // force the rest of the graph while traversing\n        if (options?.buildGraph && isNil(obj[key])) {\n            obj[key] = {};\n        }\n        // get the next item\n        const item = obj[key];\n        // we peek to see if next key is an array index.\n        const isNextArrayIndex = !!(names.length > 1 && names[1].match(/^\\d+$/));\n        // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n        // we walk each item in the array separately. This allows for handling traversing keys for objects\n        // nested within an array.\n        //\n        // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n        //  - individual objecs can be traversed with \"array.k\"\n        //  - a specific object can be traversed with \"array.1\"\n        if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {\n            item.forEach((e) => walk(e, next, fn, options));\n        }\n        else {\n            walk(item, next, fn, options);\n        }\n    }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nfunction setValue(obj, selector, value) {\n    walk(obj, selector, (item, key) => {\n        item[key] = value;\n    }, { buildGraph: true });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nfunction removeValue(obj, selector, options) {\n    walk(obj, selector, (item, key) => {\n        if (item instanceof Array) {\n            if (/^\\d+$/.test(key)) {\n                item.splice(parseInt(key), 1);\n            }\n            else if (options && options.descendArray) {\n                for (const elem of item) {\n                    if (isObject(elem)) {\n                        delete elem[key];\n                    }\n                }\n            }\n        }\n        else if (isObject(item)) {\n            delete item[key];\n        }\n    }, options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nfunction isOperator(name) {\n    return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nfunction normalize(expr) {\n    // normalized primitives\n    if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n        return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n    }\n    // normalize object expression. using ObjectLike handles custom types\n    if (isObjectLike(expr)) {\n        // no valid query operator found, so we do simple comparison\n        if (!Object.keys(expr).some(isOperator)) {\n            return { $eq: expr };\n        }\n        // ensure valid regex\n        if (has(expr, \"$regex\")) {\n            return {\n                $regex: new RegExp(expr[\"$regex\"], expr[\"$options\"]),\n            };\n        }\n    }\n    return expr;\n}\n\n\n//# sourceURL=webpack://rxdb/./node_modules/mingo/es/util.js?");

/***/ }),

/***/ "./node_modules/oblivious-set/dist/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/oblivious-set/dist/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObliviousSet\": () => (/* binding */ ObliviousSet),\n/* harmony export */   \"now\": () => (/* binding */ now),\n/* harmony export */   \"removeTooOldValues\": () => (/* binding */ removeTooOldValues)\n/* harmony export */ });\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.map = new Map();\n        /**\n         * Creating calls to setTimeout() is expensive,\n         * so we only do that if there is not timeout already open.\n         */\n        this._to = false;\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.map.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.map.set(value, now());\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(function () {\n                _this._to = false;\n                removeTooOldValues(_this);\n            }, 0);\n        }\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.map.clear();\n    };\n    return ObliviousSet;\n}());\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nfunction removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.map[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var next = iterator.next().value;\n        if (!next) {\n            return; // no more elements\n        }\n        var value = next[0];\n        var time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nfunction now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/oblivious-set/dist/es/index.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BehaviorSubject\": () => (/* binding */ BehaviorSubject)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n\n\nvar BehaviorSubject = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, (this._value = value));\n    };\n    return BehaviorSubject;\n}(_Subject__WEBPACK_IMPORTED_MODULE_1__.Subject));\n\n//# sourceMappingURL=BehaviorSubject.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COMPLETE_NOTIFICATION\": () => (/* binding */ COMPLETE_NOTIFICATION),\n/* harmony export */   \"createNotification\": () => (/* binding */ createNotification),\n/* harmony export */   \"errorNotification\": () => (/* binding */ errorNotification),\n/* harmony export */   \"nextNotification\": () => (/* binding */ nextNotification)\n/* harmony export */ });\nvar COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nfunction errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nfunction nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nfunction createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Observable.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Observable.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/esm5/internal/Subscription.js\");\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/observable */ \"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\");\n/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/pipe */ \"./node_modules/rxjs/dist/esm5/internal/util/pipe.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \"./node_modules/rxjs/dist/esm5/internal/config.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\");\n\n\n\n\n\n\n\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber(observerOrNext, error, complete);\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_1__.errorContext)(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_3__.pipeFromArray)(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\n\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : _config__WEBPACK_IMPORTED_MODULE_4__.config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.next) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.error) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) || (isObserver(value) && (0,_Subscription__WEBPACK_IMPORTED_MODULE_6__.isSubscription)(value));\n}\n//# sourceMappingURL=Observable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReplaySubject\": () => (/* binding */ ReplaySubject)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduler/dateTimestampProvider */ \"./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js\");\n\n\n\nvar ReplaySubject = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ReplaySubject, _super);\n    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {\n        if (_bufferSize === void 0) { _bufferSize = Infinity; }\n        if (_windowTime === void 0) { _windowTime = Infinity; }\n        if (_timestampProvider === void 0) { _timestampProvider = _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_1__.dateTimestampProvider; }\n        var _this = _super.call(this) || this;\n        _this._bufferSize = _bufferSize;\n        _this._windowTime = _windowTime;\n        _this._timestampProvider = _timestampProvider;\n        _this._buffer = [];\n        _this._infiniteTimeWindow = true;\n        _this._infiniteTimeWindow = _windowTime === Infinity;\n        _this._bufferSize = Math.max(1, _bufferSize);\n        _this._windowTime = Math.max(1, _windowTime);\n        return _this;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        var subscription = this._innerSubscribe(subscriber);\n        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;\n        var copy = _buffer.slice();\n        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    };\n    ReplaySubject.prototype._trimBuffer = function () {\n        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;\n        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            var now = _timestampProvider.now();\n            var last = 0;\n            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    };\n    return ReplaySubject;\n}(_Subject__WEBPACK_IMPORTED_MODULE_2__.Subject));\n\n//# sourceMappingURL=ReplaySubject.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subject.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subject.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnonymousSubject\": () => (/* binding */ AnonymousSubject),\n/* harmony export */   \"Subject\": () => (/* binding */ Subject)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/esm5/internal/Subscription.js\");\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \"./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js\");\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/arrRemove */ \"./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\");\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\");\n\n\n\n\n\n\nvar Subject = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_2__.errorContext)(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new _Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription(function () {\n            _this.currentObservers = null;\n            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_4__.arrRemove)(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_5__.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(_Observable__WEBPACK_IMPORTED_MODULE_5__.Observable));\n\nvar AnonymousSubject = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : _Subscription__WEBPACK_IMPORTED_MODULE_3__.EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\n\n//# sourceMappingURL=Subject.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subscriber.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subscriber.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_OBSERVER\": () => (/* binding */ EMPTY_OBSERVER),\n/* harmony export */   \"SafeSubscriber\": () => (/* binding */ SafeSubscriber),\n/* harmony export */   \"Subscriber\": () => (/* binding */ Subscriber)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/esm5/internal/Subscription.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \"./node_modules/rxjs/dist/esm5/internal/config.js\");\n/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/reportUnhandledError */ \"./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js\");\n/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/noop */ \"./node_modules/rxjs/dist/esm5/internal/util/noop.js\");\n/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationFactories */ \"./node_modules/rxjs/dist/esm5/internal/NotificationFactories.js\");\n/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ \"./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js\");\n/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/esm5/internal/util/errorContext.js\");\n\n\n\n\n\n\n\n\n\nvar Subscriber = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.nextNotification)(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.errorNotification)(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));\n\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && _config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\n\nfunction handleUnhandledError(error) {\n    if (_config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedSynchronousErrorHandling) {\n        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_5__.captureError)(error);\n    }\n    else {\n        (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__.reportUnhandledError)(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = _config__WEBPACK_IMPORTED_MODULE_4__.config.onStoppedNotification;\n    onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nvar EMPTY_OBSERVER = {\n    closed: true,\n    next: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,\n    error: defaultErrorHandler,\n    complete: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,\n};\n//# sourceMappingURL=Subscriber.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/Subscription.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/Subscription.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_SUBSCRIPTION\": () => (/* binding */ EMPTY_SUBSCRIPTION),\n/* harmony export */   \"Subscription\": () => (/* binding */ Subscription),\n/* harmony export */   \"isSubscription\": () => (/* binding */ isSubscription)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/UnsubscriptionError */ \"./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js\");\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ \"./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\");\n\n\n\n\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError) {\n                                errors = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(errors)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\n\nvar EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nfunction isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/Subscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/config.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/config.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"config\": () => (/* binding */ config)\n/* harmony export */ });\nvar config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/config.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"firstValueFrom\": () => (/* binding */ firstValueFrom)\n/* harmony export */ });\n/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/EmptyError */ \"./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\");\n\n\nfunction firstValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({\n            next: function (value) {\n                resolve(value);\n                subscriber.unsubscribe();\n            },\n            error: reject,\n            complete: function () {\n                if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__.EmptyError());\n                }\n            },\n        });\n        source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=firstValueFrom.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/firstValueFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/concat.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/concat.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"concat\": () => (/* binding */ concat)\n/* harmony export */ });\n/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operators/concatAll */ \"./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js\");\n/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/esm5/internal/util/args.js\");\n/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n\n\n\nfunction concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return (0,_operators_concatAll__WEBPACK_IMPORTED_MODULE_0__.concatAll)()((0,_from__WEBPACK_IMPORTED_MODULE_1__.from)(args, (0,_util_args__WEBPACK_IMPORTED_MODULE_2__.popScheduler)(args)));\n}\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/observable/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/empty.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY\": () => (/* binding */ EMPTY),\n/* harmony export */   \"empty\": () => (/* binding */ empty)\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n\nvar EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.complete(); });\nfunction empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/observable/empty.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/from.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/from.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"from\": () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduled/scheduled */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js\");\n/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n\n\nfunction from(input, scheduler) {\n    return scheduler ? (0,_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_0__.scheduled)(input, scheduler) : (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(input);\n}\n//# sourceMappingURL=from.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/observable/from.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromArrayLike\": () => (/* binding */ fromArrayLike),\n/* harmony export */   \"fromAsyncIterable\": () => (/* binding */ fromAsyncIterable),\n/* harmony export */   \"fromInteropObservable\": () => (/* binding */ fromInteropObservable),\n/* harmony export */   \"fromIterable\": () => (/* binding */ fromIterable),\n/* harmony export */   \"fromPromise\": () => (/* binding */ fromPromise),\n/* harmony export */   \"fromReadableStreamLike\": () => (/* binding */ fromReadableStreamLike),\n/* harmony export */   \"innerFrom\": () => (/* binding */ innerFrom)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\");\n/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isPromise */ \"./node_modules/rxjs/dist/esm5/internal/util/isPromise.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isInteropObservable */ \"./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js\");\n/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isAsyncIterable */ \"./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js\");\n/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/throwUnobservableError */ \"./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js\");\n/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/isIterable */ \"./node_modules/rxjs/dist/esm5/internal/util/isIterable.js\");\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/reportUnhandledError */ \"./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js\");\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction innerFrom(input) {\n    if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable) {\n        return input;\n    }\n    if (input != null) {\n        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_1__.isInteropObservable)(input)) {\n            return fromInteropObservable(input);\n        }\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(input)) {\n            return fromArrayLike(input);\n        }\n        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_3__.isPromise)(input)) {\n            return fromPromise(input);\n        }\n        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_4__.isAsyncIterable)(input)) {\n            return fromAsyncIterable(input);\n        }\n        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_5__.isIterable)(input)) {\n            return fromIterable(input);\n        }\n        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__.isReadableStreamLike)(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_7__.createInvalidObservableTypeError)(input);\n}\nfunction fromInteropObservable(obj) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_8__.observable]();\n        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_9__.isFunction)(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nfunction fromArrayLike(array) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nfunction fromPromise(promise) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        promise\n            .then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_10__.reportUnhandledError);\n    });\n}\nfunction fromIterable(iterable) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__values)(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var value = iterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\nfunction fromAsyncIterable(asyncIterable) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\n    });\n}\nfunction fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_6__.readableStreamLikeToAsyncGenerator)(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_2, _a;\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__awaiter)(this, void 0, void 0, function () {\n        var value, e_2_1;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__generator)(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 5, 6, 11]);\n                    asyncIterable_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_11__.__asyncValues)(asyncIterable);\n                    _b.label = 1;\n                case 1: return [4, asyncIterable_1.next()];\n                case 2:\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n                    value = asyncIterable_1_1.value;\n                    subscriber.next(value);\n                    if (subscriber.closed) {\n                        return [2];\n                    }\n                    _b.label = 3;\n                case 3: return [3, 1];\n                case 4: return [3, 11];\n                case 5:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3, 11];\n                case 6:\n                    _b.trys.push([6, , 9, 10]);\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n                    return [4, _a.call(asyncIterable_1)];\n                case 7:\n                    _b.sent();\n                    _b.label = 8;\n                case 8: return [3, 10];\n                case 9:\n                    if (e_2) throw e_2.error;\n                    return [7];\n                case 10: return [7];\n                case 11:\n                    subscriber.complete();\n                    return [2];\n            }\n        });\n    });\n}\n//# sourceMappingURL=innerFrom.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/observable/merge.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/merge.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"merge\": () => (/* binding */ merge)\n/* harmony export */ });\n/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../operators/mergeAll */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js\");\n/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty */ \"./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/esm5/internal/util/args.js\");\n/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n\n\n\n\n\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);\n    var concurrent = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popNumber)(args, Infinity);\n    var sources = args;\n    return !sources.length\n        ?\n            _empty__WEBPACK_IMPORTED_MODULE_1__.EMPTY\n        : sources.length === 1\n            ?\n                (0,_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(sources[0])\n            :\n                (0,_operators_mergeAll__WEBPACK_IMPORTED_MODULE_3__.mergeAll)(concurrent)((0,_from__WEBPACK_IMPORTED_MODULE_4__.from)(sources, scheduler));\n}\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/observable/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OperatorSubscriber\": () => (/* binding */ OperatorSubscriber),\n/* harmony export */   \"createOperatorSubscriber\": () => (/* binding */ createOperatorSubscriber)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\");\n\n\nfunction createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(OperatorSubscriber, _super);\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        var _this = _super.call(this, destination) || this;\n        _this.onFinalize = onFinalize;\n        _this.shouldUnsubscribe = shouldUnsubscribe;\n        _this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : _super.prototype._next;\n        _this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._error;\n        _this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._complete;\n        return _this;\n    }\n    OperatorSubscriber.prototype.unsubscribe = function () {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            var closed_1 = this.closed;\n            _super.prototype.unsubscribe.call(this);\n            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    };\n    return OperatorSubscriber;\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));\n\n//# sourceMappingURL=OperatorSubscriber.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"concatAll\": () => (/* binding */ concatAll)\n/* harmony export */ });\n/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeAll */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js\");\n\nfunction concatAll() {\n    return (0,_mergeAll__WEBPACK_IMPORTED_MODULE_0__.mergeAll)(1);\n}\n//# sourceMappingURL=concatAll.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"distinctUntilChanged\": () => (/* binding */ distinctUntilChanged)\n/* harmony export */ });\n/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/esm5/internal/util/identity.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction distinctUntilChanged(comparator, keySelector) {\n    if (keySelector === void 0) { keySelector = _util_identity__WEBPACK_IMPORTED_MODULE_0__.identity; }\n    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {\n        var previousKey;\n        var first = true;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function (value) {\n            var currentKey = keySelector(value);\n            if (first || !comparator(previousKey, currentKey)) {\n                first = false;\n                previousKey = currentKey;\n                subscriber.next(value);\n            }\n        }));\n    });\n}\nfunction defaultCompare(a, b) {\n    return a === b;\n}\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/filter.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/filter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"filter\": () => (/* binding */ filter)\n/* harmony export */ });\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\nfunction filter(predicate, thisArg) {\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\n        var index = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\n    });\n}\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/filter.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/map.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"map\": () => (/* binding */ map)\n/* harmony export */ });\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\nfunction map(project, thisArg) {\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\n        var index = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/map.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/merge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"merge\": () => (/* binding */ merge)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _util_argsOrArgArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js\");\n/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mergeAll */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js\");\n/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/esm5/internal/util/args.js\");\n/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../observable/from */ \"./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n\n\n\n\n\n\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(args);\n    var concurrent = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popNumber)(args, Infinity);\n    args = (0,_util_argsOrArgArray__WEBPACK_IMPORTED_MODULE_1__.argsOrArgArray)(args);\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_2__.operate)(function (source, subscriber) {\n        (0,_mergeAll__WEBPACK_IMPORTED_MODULE_3__.mergeAll)(concurrent)((0,_observable_from__WEBPACK_IMPORTED_MODULE_4__.from)((0,tslib__WEBPACK_IMPORTED_MODULE_5__.__spreadArray)([source], (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__read)(args)), scheduler)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mergeAll\": () => (/* binding */ mergeAll)\n/* harmony export */ });\n/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/esm5/internal/util/identity.js\");\n\n\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mergeInternals\": () => (/* binding */ mergeInternals)\n/* harmony export */ });\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function () {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };\n    var doInnerSub = function (value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, index++)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, function () {\n            innerComplete = true;\n        }, undefined, function () {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function () {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while (buffer.length && active < concurrent) {\n                        _loop_1();\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, outerNext, function () {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function () {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mergeMap\": () => (/* binding */ mergeMap)\n/* harmony export */ });\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _mergeInternals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mergeInternals */ \"./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\n\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector)) {\n        return mergeMap(function (a, i) { return (0,_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (b, ii) { return resultSelector(a, b, i, ii); })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(project(a, i))); }, concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_3__.operate)(function (source, subscriber) { return (0,_mergeInternals__WEBPACK_IMPORTED_MODULE_4__.mergeInternals)(source, subscriber, project, concurrent); });\n}\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mergeWith\": () => (/* binding */ mergeWith)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./merge */ \"./node_modules/rxjs/dist/esm5/internal/operators/merge.js\");\n\n\nfunction mergeWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return _merge__WEBPACK_IMPORTED_MODULE_0__.merge.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(otherSources)));\n}\n//# sourceMappingURL=mergeWith.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observeOn\": () => (/* binding */ observeOn)\n/* harmony export */ });\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));\n    });\n}\n//# sourceMappingURL=observeOn.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/share.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/share.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"share\": () => (/* binding */ share)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/dist/esm5/internal/Subscriber.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n\n\n\n\n\nfunction share(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.connector, connector = _a === void 0 ? function () { return new _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\n    return function (wrapperSource) {\n        var connection;\n        var resetConnection;\n        var subject;\n        var refCount = 0;\n        var hasCompleted = false;\n        var hasErrored = false;\n        var cancelReset = function () {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        var reset = function () {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        var resetAndUnsubscribe = function () {\n            var conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(function () {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.SafeSubscriber({\n                    next: function (value) { return dest.next(value); },\n                    error: function (err) {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: function () {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__.innerFrom)(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    var onSubscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.SafeSubscriber({\n        next: function () {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_3__.innerFrom)(on.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__read)(args)))).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/share.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shareReplay\": () => (/* binding */ shareReplay)\n/* harmony export */ });\n/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ReplaySubject */ \"./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _share__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share */ \"./node_modules/rxjs/dist/esm5/internal/operators/share.js\");\n\n\nfunction shareReplay(configOrBufferSize, windowTime, scheduler) {\n    var _a, _b, _c;\n    var bufferSize;\n    var refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);\n    }\n    else {\n        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);\n    }\n    return (0,_share__WEBPACK_IMPORTED_MODULE_0__.share)({\n        connector: function () { return new _ReplaySubject__WEBPACK_IMPORTED_MODULE_1__.ReplaySubject(bufferSize, windowTime, scheduler); },\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount,\n    });\n}\n//# sourceMappingURL=shareReplay.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/startWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/startWith.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"startWith\": () => (/* binding */ startWith)\n/* harmony export */ });\n/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/dist/esm5/internal/observable/concat.js\");\n/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/esm5/internal/util/args.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n\n\n\nfunction startWith() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    var scheduler = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popScheduler)(values);\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {\n        (scheduler ? (0,_observable_concat__WEBPACK_IMPORTED_MODULE_2__.concat)(values, source, scheduler) : (0,_observable_concat__WEBPACK_IMPORTED_MODULE_2__.concat)(values, source)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=startWith.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/startWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribeOn\": () => (/* binding */ subscribeOn)\n/* harmony export */ });\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {\n        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));\n    });\n}\n//# sourceMappingURL=subscribeOn.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduleArray\": () => (/* binding */ scheduleArray)\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n\nfunction scheduleArray(input, scheduler) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        var i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n//# sourceMappingURL=scheduleArray.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduleAsyncIterable\": () => (/* binding */ scheduleAsyncIterable)\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n\n\nfunction scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {\n            var iterator = input[Symbol.asyncIterator]();\n            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {\n                iterator.next().then(function (result) {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n//# sourceMappingURL=scheduleAsyncIterable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduleIterable\": () => (/* binding */ scheduleIterable)\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n\n\n\n\nfunction scheduleIterable(input, scheduler) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {\n        var iterator;\n        (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {\n            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__.iterator]();\n            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_1__.executeSchedule)(subscriber, scheduler, function () {\n                var _a;\n                var value;\n                var done;\n                try {\n                    (_a = iterator.next(), value = _a.value, done = _a.done);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return function () { return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };\n    });\n}\n//# sourceMappingURL=scheduleIterable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduleObservable\": () => (/* binding */ scheduleObservable)\n/* harmony export */ });\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js\");\n/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/subscribeOn */ \"./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js\");\n\n\n\nfunction scheduleObservable(input, scheduler) {\n    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_2__.observeOn)(scheduler));\n}\n//# sourceMappingURL=scheduleObservable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schedulePromise\": () => (/* binding */ schedulePromise)\n/* harmony export */ });\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js\");\n/* harmony import */ var _operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operators/subscribeOn */ \"./node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js\");\n\n\n\nfunction schedulePromise(input, scheduler) {\n    return (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(input).pipe((0,_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_1__.subscribeOn)(scheduler), (0,_operators_observeOn__WEBPACK_IMPORTED_MODULE_2__.observeOn)(scheduler));\n}\n//# sourceMappingURL=schedulePromise.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduleReadableStreamLike\": () => (/* binding */ scheduleReadableStreamLike)\n/* harmony export */ });\n/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduleAsyncIterable */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js\");\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\");\n\n\nfunction scheduleReadableStreamLike(input, scheduler) {\n    return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_0__.scheduleAsyncIterable)((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_1__.readableStreamLikeToAsyncGenerator)(input), scheduler);\n}\n//# sourceMappingURL=scheduleReadableStreamLike.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"scheduled\": () => (/* binding */ scheduled)\n/* harmony export */ });\n/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scheduleObservable */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js\");\n/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./schedulePromise */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js\");\n/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scheduleArray */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js\");\n/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./scheduleIterable */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js\");\n/* harmony import */ var _scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduleAsyncIterable */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js\");\n/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isInteropObservable */ \"./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js\");\n/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/isPromise */ \"./node_modules/rxjs/dist/esm5/internal/util/isPromise.js\");\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\");\n/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/isIterable */ \"./node_modules/rxjs/dist/esm5/internal/util/isIterable.js\");\n/* harmony import */ var _util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/isAsyncIterable */ \"./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js\");\n/* harmony import */ var _util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../util/throwUnobservableError */ \"./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js\");\n/* harmony import */ var _util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js\");\n/* harmony import */ var _scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./scheduleReadableStreamLike */ \"./node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction scheduled(input, scheduler) {\n    if (input != null) {\n        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__.isInteropObservable)(input)) {\n            return (0,_scheduleObservable__WEBPACK_IMPORTED_MODULE_1__.scheduleObservable)(input, scheduler);\n        }\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(input)) {\n            return (0,_scheduleArray__WEBPACK_IMPORTED_MODULE_3__.scheduleArray)(input, scheduler);\n        }\n        if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(input)) {\n            return (0,_schedulePromise__WEBPACK_IMPORTED_MODULE_5__.schedulePromise)(input, scheduler);\n        }\n        if ((0,_util_isAsyncIterable__WEBPACK_IMPORTED_MODULE_6__.isAsyncIterable)(input)) {\n            return (0,_scheduleAsyncIterable__WEBPACK_IMPORTED_MODULE_7__.scheduleAsyncIterable)(input, scheduler);\n        }\n        if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_8__.isIterable)(input)) {\n            return (0,_scheduleIterable__WEBPACK_IMPORTED_MODULE_9__.scheduleIterable)(input, scheduler);\n        }\n        if ((0,_util_isReadableStreamLike__WEBPACK_IMPORTED_MODULE_10__.isReadableStreamLike)(input)) {\n            return (0,_scheduleReadableStreamLike__WEBPACK_IMPORTED_MODULE_11__.scheduleReadableStreamLike)(input, scheduler);\n        }\n    }\n    throw (0,_util_throwUnobservableError__WEBPACK_IMPORTED_MODULE_12__.createInvalidObservableTypeError)(input);\n}\n//# sourceMappingURL=scheduled.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dateTimestampProvider\": () => (/* binding */ dateTimestampProvider)\n/* harmony export */ });\nvar dateTimestampProvider = {\n    now: function () {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=dateTimestampProvider.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"timeoutProvider\": () => (/* binding */ timeoutProvider)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n\nvar timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));\n        }\n        return setTimeout.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSymbolIterator\": () => (/* binding */ getSymbolIterator),\n/* harmony export */   \"iterator\": () => (/* binding */ iterator)\n/* harmony export */ });\nfunction getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nvar iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/symbol/observable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/symbol/observable.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"observable\": () => (/* binding */ observable)\n/* harmony export */ });\nvar observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/symbol/observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmptyError\": () => (/* binding */ EmptyError)\n/* harmony export */ });\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\");\n\nvar EmptyError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) { return function EmptyErrorImpl() {\n    _super(this);\n    this.name = 'EmptyError';\n    this.message = 'no elements in sequence';\n}; });\n//# sourceMappingURL=EmptyError.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js":
/*!******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjectUnsubscribedError\": () => (/* binding */ ObjectUnsubscribedError)\n/* harmony export */ });\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\");\n\nvar ObjectUnsubscribedError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnsubscriptionError\": () => (/* binding */ UnsubscriptionError)\n/* harmony export */ });\n/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js\");\n\nvar UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/args.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/args.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"popNumber\": () => (/* binding */ popNumber),\n/* harmony export */   \"popResultSelector\": () => (/* binding */ popResultSelector),\n/* harmony export */   \"popScheduler\": () => (/* binding */ popScheduler)\n/* harmony export */ });\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScheduler */ \"./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js\");\n\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction popResultSelector(args) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(last(args)) ? args.pop() : undefined;\n}\nfunction popScheduler(args) {\n    return (0,_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(last(args)) ? args.pop() : undefined;\n}\nfunction popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n//# sourceMappingURL=args.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/args.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"argsOrArgArray\": () => (/* binding */ argsOrArgArray)\n/* harmony export */ });\nvar isArray = Array.isArray;\nfunction argsOrArgArray(args) {\n    return args.length === 1 && isArray(args[0]) ? args[0] : args;\n}\n//# sourceMappingURL=argsOrArgArray.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrRemove\": () => (/* binding */ arrRemove)\n/* harmony export */ });\nfunction arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createErrorClass\": () => (/* binding */ createErrorClass)\n/* harmony export */ });\nfunction createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/errorContext.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/errorContext.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"captureError\": () => (/* binding */ captureError),\n/* harmony export */   \"errorContext\": () => (/* binding */ errorContext)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./node_modules/rxjs/dist/esm5/internal/config.js\");\n\nvar context = null;\nfunction errorContext(cb) {\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nfunction captureError(err) {\n    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/errorContext.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"executeSchedule\": () => (/* binding */ executeSchedule)\n/* harmony export */ });\nfunction executeSchedule(parentSubscription, scheduler, work, delay, repeat) {\n    if (delay === void 0) { delay = 0; }\n    if (repeat === void 0) { repeat = false; }\n    var scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\n//# sourceMappingURL=executeSchedule.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/identity.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/identity.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"identity\": () => (/* binding */ identity)\n/* harmony export */ });\nfunction identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/identity.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isArrayLike\": () => (/* binding */ isArrayLike)\n/* harmony export */ });\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAsyncIterable\": () => (/* binding */ isAsyncIterable)\n/* harmony export */ });\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\nfunction isAsyncIterable(obj) {\n    return Symbol.asyncIterator && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n//# sourceMappingURL=isAsyncIterable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isFunction.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction)\n/* harmony export */ });\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isInteropObservable\": () => (/* binding */ isInteropObservable)\n/* harmony export */ });\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/dist/esm5/internal/symbol/observable.js\");\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\nfunction isInteropObservable(input) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input[_symbol_observable__WEBPACK_IMPORTED_MODULE_1__.observable]);\n}\n//# sourceMappingURL=isInteropObservable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isIterable.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isIterable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isIterable\": () => (/* binding */ isIterable)\n/* harmony export */ });\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/dist/esm5/internal/symbol/iterator.js\");\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\nfunction isIterable(input) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(input === null || input === void 0 ? void 0 : input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__.iterator]);\n}\n//# sourceMappingURL=isIterable.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isPromise.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isPromise.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\nfunction isPromise(value) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value === null || value === void 0 ? void 0 : value.then);\n}\n//# sourceMappingURL=isPromise.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isReadableStreamLike\": () => (/* binding */ isReadableStreamLike),\n/* harmony export */   \"readableStreamLikeToAsyncGenerator\": () => (/* binding */ readableStreamLikeToAsyncGenerator)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\nfunction readableStreamLikeToAsyncGenerator(readableStream) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__asyncGenerator)(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\n        var reader, _a, value, done;\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = readableStream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (false) {}\n                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(reader.read())];\n                case 3:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    if (!done) return [3, 5];\n                    return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(void 0)];\n                case 4: return [2, _b.sent()];\n                case 5: return [4, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__await)(value)];\n                case 6: return [4, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3, 2];\n                case 8: return [3, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7];\n                case 10: return [2];\n            }\n        });\n    });\n}\nfunction isReadableStreamLike(obj) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n//# sourceMappingURL=isReadableStreamLike.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isScheduler\": () => (/* binding */ isScheduler)\n/* harmony export */ });\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\nfunction isScheduler(value) {\n    return value && (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value.schedule);\n}\n//# sourceMappingURL=isScheduler.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/lift.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/lift.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasLift\": () => (/* binding */ hasLift),\n/* harmony export */   \"operate\": () => (/* binding */ operate)\n/* harmony export */ });\n/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\nfunction hasLift(source) {\n    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);\n}\nfunction operate(init) {\n    return function (source) {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n//# sourceMappingURL=lift.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/lift.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/noop.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/noop.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"noop\": () => (/* binding */ noop)\n/* harmony export */ });\nfunction noop() { }\n//# sourceMappingURL=noop.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/noop.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/pipe.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/pipe.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pipe\": () => (/* binding */ pipe),\n/* harmony export */   \"pipeFromArray\": () => (/* binding */ pipeFromArray)\n/* harmony export */ });\n/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ \"./node_modules/rxjs/dist/esm5/internal/util/identity.js\");\n\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nfunction pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/pipe.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"reportUnhandledError\": () => (/* binding */ reportUnhandledError)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./node_modules/rxjs/dist/esm5/internal/config.js\");\n/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ \"./node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js\");\n\n\nfunction reportUnhandledError(err) {\n    _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__.timeoutProvider.setTimeout(function () {\n        var onUnhandledError = _config__WEBPACK_IMPORTED_MODULE_1__.config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createInvalidObservableTypeError\": () => (/* binding */ createInvalidObservableTypeError)\n/* harmony export */ });\nfunction createInvalidObservableTypeError(input) {\n    return new TypeError(\"You provided \" + (input !== null && typeof input === 'object' ? 'an invalid object' : \"'\" + input + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\n//# sourceMappingURL=throwUnobservableError.js.map\n\n//# sourceURL=webpack://rxdb/./node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js?");

/***/ }),

/***/ "./docs-src/database.ts":
/*!******************************!*\
  !*** ./docs-src/database.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDatabase\": () => (/* binding */ getDatabase)\n/* harmony export */ });\n/* harmony import */ var _plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../plugins/storage-dexie */ \"./dist/es/plugins/storage-dexie/rx-storage-dexie.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./dist/es/plugin.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ */ \"./dist/es/rx-database.js\");\n/* harmony import */ var _plugins_local_documents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../plugins/local-documents */ \"./dist/es/plugins/local-documents/index.js\");\n\n\n\nasync function getDatabase() {\n    (0,___WEBPACK_IMPORTED_MODULE_0__.addRxPlugin)(_plugins_local_documents__WEBPACK_IMPORTED_MODULE_1__.RxDBLocalDocumentsPlugin);\n    const database = await (0,___WEBPACK_IMPORTED_MODULE_2__.createRxDatabase)({\n        name: 'rxdb-landingpage',\n        localDocuments: true,\n        storage: (0,_plugins_storage_dexie__WEBPACK_IMPORTED_MODULE_3__.getRxStorageDexie)()\n    });\n    return database;\n}\n\n\n//# sourceURL=webpack://rxdb/./docs-src/database.ts?");

/***/ }),

/***/ "./docs-src/premium.ts":
/*!*****************************!*\
  !*** ./docs-src/premium.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"INFLATION_RATE\": () => (/* binding */ INFLATION_RATE),\n/* harmony export */   \"PACKAGE_PRICE\": () => (/* binding */ PACKAGE_PRICE),\n/* harmony export */   \"calculatePrice\": () => (/* binding */ calculatePrice)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ */ \"./dist/es/plugins/utils/utils-other.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ */ \"./dist/es/plugins/utils/utils-array.js\");\n/* harmony import */ var _database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./database */ \"./docs-src/database.ts\");\n/* harmony import */ var _salaries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./salaries */ \"./docs-src/salaries.ts\");\n\n\n\nconst dbPromise = (0,_database__WEBPACK_IMPORTED_MODULE_0__.getDatabase)();\nconst FORM_VALUE_DOCUMENT_ID = 'premium-price-form-value';\nwindow.onload = async function () {\n    const $homeCountry = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('home-country'));\n    const $priceCalculatorForm = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('price-calculator-form'));\n    const $priceCalculatorSubmit = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('price-calculator-submit'));\n    const $priceCalculatorResult = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('price-calculator-result'));\n    const $priceCalculatorResultPerMonth = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('total-per-developer-per-month'));\n    const $priceCalculatorResultPerYear = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.getElementById('total-per-year'));\n    _salaries__WEBPACK_IMPORTED_MODULE_2__.AVERAGE_FRONT_END_DEVELOPER_SALARY_BY_COUNTRY.sort((a, b) => a.code >= b.code ? 1 : -1)\n        .forEach(country => {\n        const option = document.createElement('option');\n        option.value = country.code;\n        option.innerHTML = country.name;\n        $homeCountry.appendChild(option);\n    });\n    const database = await dbPromise;\n    const formValueDoc = await database.getLocal(FORM_VALUE_DOCUMENT_ID);\n    if (formValueDoc) {\n        setToInput('developer-count', formValueDoc._data.data.teamSize);\n        setToInput('home-country', formValueDoc._data.data.homeCountryCode);\n        setToInput('company-age', formValueDoc._data.data.companyAge);\n    }\n    $priceCalculatorSubmit.onclick = async () => {\n        window.trigger('calculate_premium_price', 1.5);\n        const isValid = $priceCalculatorForm.reportValidity();\n        if (!isValid) {\n            return;\n        }\n        const formDataPlain = new FormData($priceCalculatorForm);\n        const formData = Object.fromEntries(formDataPlain.entries());\n        console.log('formData:');\n        console.dir(formData);\n        /**\n         * Save the input\n         * so we have to not re-insert manually on page reload.\n         */\n        await database.upsertLocal(FORM_VALUE_DOCUMENT_ID, {\n            companyAge: formData['company-age'],\n            teamSize: formData['developer-count'],\n            homeCountryCode: formData['home-country']\n        });\n        const packages = Object.keys(formData)\n            .filter(k => k.startsWith('package-'))\n            .map(k => (0,___WEBPACK_IMPORTED_MODULE_3__.lastOfArray)(k.split('-')));\n        const priceResult = calculatePrice({\n            companyAge: formData['company-age'],\n            teamSize: formData['developer-count'],\n            homeCountryCode: formData['home-country'],\n            packages\n        });\n        console.log('priceResult:');\n        console.log(JSON.stringify(priceResult, null, 4));\n        const getConverterUrl = (price) => {\n            return 'https://www.xe.com/en/currencyconverter/convert/?Amount=' + price + '&From=EUR&To=USD';\n        };\n        const setPrice = (element, price) => {\n            element.innerHTML = price + ' &euro; (EUR)';\n            element.href = getConverterUrl(price);\n        };\n        setPrice($priceCalculatorResultPerMonth, priceResult.perDeveloperPerMonth);\n        setPrice($priceCalculatorResultPerYear, priceResult.totalPerYear);\n        $priceCalculatorResult.style.display = 'block';\n    };\n};\n/**\n * Prices are in percent of averagy salary.\n */\nconst PACKAGE_PRICE = {\n    browser: 0.55,\n    native: 0.65,\n    performance: 0.30\n};\n/**\n * @link https://www.statista.com/statistics/256598/global-inflation-rate-compared-to-previous-year/\n */\nconst INFLATION_RATE = 0.05;\n/**\n * All prices are in Euro €\n */\nfunction calculatePrice(input) {\n    const baseFee = 400;\n    const baseFeePerDeveloper = 90;\n    const country = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(_salaries__WEBPACK_IMPORTED_MODULE_2__.AVERAGE_FRONT_END_DEVELOPER_SALARY_BY_COUNTRY.find(c => c.code === input.homeCountryCode));\n    const developerSalary = country.salary;\n    let aimInPercent = 0;\n    input.packages.forEach(packageKey => {\n        const priceInPercent = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(PACKAGE_PRICE[packageKey]);\n        aimInPercent = aimInPercent + priceInPercent;\n    });\n    console.log('aimInPercent: ' + aimInPercent);\n    let totalPerYear = baseFee +\n        (baseFeePerDeveloper * input.teamSize) +\n        (developerSalary * (aimInPercent / 100) * input.teamSize);\n    /**\n     * Discount for 'young' companies.\n     */\n    if (input.companyAge === 'less-than-3') {\n        totalPerYear = totalPerYear * 0.80;\n    }\n    /**\n     * Discount if more then one package\n     */\n    if (input.packages.length > 1) {\n        totalPerYear = totalPerYear * 0.90;\n    }\n    /**\n     * Respect the inflation rate\n     */\n    const baseYear = 2022;\n    const currentYear = new Date().getFullYear();\n    const yearsDiff = currentYear - baseYear;\n    const inflationMultiplier = Math.pow((1 + INFLATION_RATE), yearsDiff);\n    console.log('inflationMultiplier: ' + inflationMultiplier);\n    totalPerYear = totalPerYear * inflationMultiplier;\n    totalPerYear = Math.ceil(totalPerYear);\n    return {\n        totalPerYear,\n        perDeveloperPerMonth: Math.floor(totalPerYear / 12 / input.teamSize)\n    };\n}\nfunction setToInput(name, value) {\n    const element = (0,___WEBPACK_IMPORTED_MODULE_1__.ensureNotFalsy)(document.querySelector('[name=' + name + ']'));\n    element.value = value;\n}\n\n\n//# sourceURL=webpack://rxdb/./docs-src/premium.ts?");

/***/ }),

/***/ "./docs-src/salaries.ts":
/*!******************************!*\
  !*** ./docs-src/salaries.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AVERAGE_FRONT_END_DEVELOPER_SALARY_BY_COUNTRY\": () => (/* binding */ AVERAGE_FRONT_END_DEVELOPER_SALARY_BY_COUNTRY)\n/* harmony export */ });\n/**\n * Countries where I could not find a value, are commented out.\n */\nconst AVERAGE_FRONT_END_DEVELOPER_SALARY_BY_COUNTRY = [\n    // { 'name': 'Afghanistan', 'code': 'AF', salary: false },\n    // { 'name': 'Åland Islands', 'code': 'AX', salary: false },\n    // { 'name': 'Albania', 'code': 'AL', salary: false },\n    // { 'name': 'Algeria', 'code': 'DZ', salary: false },\n    // { 'name': 'American Samoa', 'code': 'AS', salary: false },\n    // { 'name': 'Andorra', 'code': 'AD', salary: false },\n    // { 'name': 'Angola', 'code': 'AO', salary: false },\n    // { 'name': 'Anguilla', 'code': 'AI', salary: false },\n    // { 'name': 'Antarctica', 'code': 'AQ', salary: false },\n    { 'name': 'Antigua and Barbuda', 'code': 'AG', salary: 49527 },\n    { 'name': 'Argentina', 'code': 'AR', salary: 17158 },\n    // { 'name': 'Armenia', 'code': 'AM', salary: false },\n    // { 'name': 'Aruba', 'code': 'AW', salary: false },\n    { 'name': 'Australia', 'code': 'AU', salary: 76036 },\n    { 'name': 'Austria', 'code': 'AT', salary: 59383 },\n    // { 'name': 'Azerbaijan', 'code': 'AZ', salary: false },\n    { 'name': 'Bahamas', 'code': 'BS', salary: 62024 },\n    // { 'name': 'Bahrain', 'code': 'BH', salary: false },\n    // { 'name': 'Bangladesh', 'code': 'BD', salary: false },\n    // { 'name': 'Barbados', 'code': 'BB', salary: false },\n    { 'name': 'Belarus', 'code': 'BY', salary: 5749 },\n    { 'name': 'Belgium', 'code': 'BE', salary: 63749 },\n    // { 'name': 'Belize', 'code': 'BZ', salary: false },\n    // { 'name': 'Benin', 'code': 'BJ', salary: false },\n    { 'name': 'Bermuda', 'code': 'BM', salary: 86590 },\n    // { 'name': 'Bhutan', 'code': 'BT', salary: false },\n    // { 'name': 'Bolivia', 'code': 'BO', salary: false },\n    { 'name': 'Bosnia and Herzegovina', 'code': 'BA', salary: 11992 },\n    // { 'name': 'Botswana', 'code': 'BW', salary: false },\n    // { 'name': 'Bouvet Island', 'code': 'BV', salary: false },\n    { 'name': 'Brazil', 'code': 'BR', salary: 26464 },\n    // { 'name': 'British Indian Ocean Territory', 'code': 'IO', salary: false },\n    // { 'name': 'Brunei Darussalam', 'code': 'BN', salary: false },\n    { 'name': 'Bulgaria', 'code': 'BG', salary: 23384 },\n    // { 'name': 'Burkina Faso', 'code': 'BF', salary: false },\n    // { 'name': 'Burundi', 'code': 'BI', salary: false },\n    // { 'name': 'Cambodia', 'code': 'KH', salary: false },\n    // { 'name': 'Cameroon', 'code': 'CM', salary: false },\n    { 'name': 'Canada', 'code': 'CA', salary: 71554 },\n    // { 'name': 'Cape Verde', 'code': 'CV', salary: false },\n    // { 'name': 'Cayman Islands', 'code': 'KY', salary: false },\n    // { 'name': 'Central African Republic', 'code': 'CF', salary: false },\n    // { 'name': 'Chad', 'code': 'TD', salary: false },\n    { 'name': 'Chile', 'code': 'CL', salary: 31073 },\n    { 'name': 'China', 'code': 'CN', salary: 40611 },\n    // { 'name': 'Christmas Island', 'code': 'CX', salary: false },\n    // { 'name': 'Cocos (Keeling) Islands', 'code': 'CC', salary: false },\n    { 'name': 'Colombia', 'code': 'CO', salary: 12894 },\n    // { 'name': 'Comoros', 'code': 'KM', salary: false },\n    // { 'name': 'Congo', 'code': 'CG', salary: false },\n    // { 'name': 'Congo, The Democratic Republic of the', 'code': 'CD', salary: false },\n    // { 'name': 'Cook Islands', 'code': 'CK', salary: false },\n    { 'name': 'Costa Rica', 'code': 'CR', salary: 40256 },\n    { 'name': 'Croatia', 'code': 'HR', salary: 22566 },\n    // { 'name': 'Cuba', 'code': 'CU', salary: false },\n    // { 'name': 'Cyprus', 'code': 'CY', salary: false },\n    { 'name': 'Czech Republic', 'code': 'CZ', salary: 33760 },\n    { 'name': 'Denmark', 'code': 'DK', salary: 68778 },\n    // { 'name': 'Djibouti', 'code': 'DJ', salary: false },\n    // { 'name': 'Dominica', 'code': 'DM', salary: false },\n    // { 'name': 'Dominican Republic', 'code': 'DO', salary: false },\n    { 'name': 'Ecuador', 'code': 'EC', salary: 35016 },\n    { 'name': 'Egypt', 'code': 'EG', salary: 7758 },\n    // { 'name': 'El Salvador', 'code': 'SV', salary: false },\n    // { 'name': 'Equatorial Guinea', 'code': 'GQ', salary: false },\n    // { 'name': 'Eritrea', 'code': 'ER', salary: false },\n    { 'name': 'Estonia', 'code': 'EE', salary: 26728 },\n    // { 'name': 'Ethiopia', 'code': 'ET', salary: false },\n    // { 'name': 'Falkland Islands (Malvinas)', 'code': 'FK', salary: false },\n    // { 'name': 'Faroe Islands', 'code': 'FO', salary: false },\n    // { 'name': 'Fiji', 'code': 'FJ', salary: false },\n    { 'name': 'Finland', 'code': 'FI', salary: 64198 },\n    { 'name': 'France', 'code': 'FR', salary: 58137 },\n    // { 'name': 'French Guiana', 'code': 'GF', salary: false },\n    // { 'name': 'French Polynesia', 'code': 'PF', salary: false },\n    // { 'name': 'French Southern Territories', 'code': 'TF', salary: false },\n    // { 'name': 'Gabon', 'code': 'GA', salary: false },\n    // { 'name': 'Gambia', 'code': 'GM', salary: false },\n    { 'name': 'Georgia', 'code': 'GE', salary: 40315 },\n    { 'name': 'Germany', 'code': 'DE', salary: 72138 },\n    // { 'name': 'Ghana', 'code': 'GH', salary: false },\n    // { 'name': 'Gibraltar', 'code': 'GI', salary: false },\n    { 'name': 'Greece', 'code': 'GR', salary: 36824 },\n    // { 'name': 'Greenland', 'code': 'GL', salary: false },\n    // { 'name': 'Grenada', 'code': 'GD', salary: false },\n    // { 'name': 'Guadeloupe', 'code': 'GP', salary: false },\n    // { 'name': 'Guam', 'code': 'GU', salary: false },\n    { 'name': 'Guatemala', 'code': 'GT', salary: 49612 },\n    // { 'name': 'Guernsey', 'code': 'GG', salary: false },\n    // { 'name': 'Guinea', 'code': 'GN', salary: false },\n    // { 'name': 'Guinea-Bissau', 'code': 'GW', salary: false },\n    // { 'name': 'Guyana', 'code': 'GY', salary: false },\n    // { 'name': 'Haiti', 'code': 'HT', salary: false },\n    // { 'name': 'Heard Island and Mcdonald Islands', 'code': 'HM', salary: false },\n    { 'name': 'Holy See (Vatican City State)', 'code': 'VA', salary: 51474 },\n    // { 'name': 'Honduras', 'code': 'HN', salary: false },\n    { 'name': 'Hong Kong', 'code': 'HK', salary: 71970 },\n    { 'name': 'Hungary', 'code': 'HU', salary: 22341 },\n    { 'name': 'Iceland', 'code': 'IS', salary: 66512 },\n    { 'name': 'India', 'code': 'IN', salary: 17710 },\n    { 'name': 'Indonesia', 'code': 'ID', salary: 20978 },\n    // { 'name': 'Iran, Islamic Republic Of', 'code': 'IR', salary: false },\n    { 'name': 'Iraq', 'code': 'IQ', salary: 21029 },\n    { 'name': 'Ireland', 'code': 'IE', salary: 66281 },\n    // { 'name': 'Isle of Man', 'code': 'IM', salary: false },\n    { 'name': 'Israel', 'code': 'IL', salary: 57466 },\n    { 'name': 'Italy', 'code': 'IT', salary: 50900 },\n    { 'name': 'Jamaica', 'code': 'JM', salary: 21048 },\n    { 'name': 'Japan', 'code': 'JP', salary: 57793 },\n    // { 'name': 'Jersey', 'code': 'JE', salary: false },\n    // { 'name': 'Jordan', 'code': 'JO', salary: false },\n    { 'name': 'Kazakhstan', 'code': 'KZ', salary: 12243 },\n    // { 'name': 'Kenya', 'code': 'KE', salary: false },\n    // { 'name': 'Kiribati', 'code': 'KI', salary: false },\n    { 'name': 'Korea, Republic of', 'code': 'KR', salary: 45957 },\n    // { 'name': 'Kuwait', 'code': 'KW', salary: false },\n    // { 'name': 'Kyrgyzstan', 'code': 'KG', salary: false },\n    // { 'name': 'Latvia', 'code': 'LV', salary: false },\n    // { 'name': 'Lebanon', 'code': 'LB', salary: false },\n    // { 'name': 'Lesotho', 'code': 'LS', salary: false },\n    // { 'name': 'Liberia', 'code': 'LR', salary: false },\n    // { 'name': 'Libyan Arab Jamahiriya', 'code': 'LY', salary: false },\n    // { 'name': 'Liechtenstein', 'code': 'LI', salary: false },\n    // { 'name': 'Lithuania', 'code': 'LT', salary: false },\n    { 'name': 'Luxembourg', 'code': 'LU', salary: 84663 },\n    // { 'name': 'Macao', 'code': 'MO', salary: false },\n    // { 'name': 'North Macedonia', 'code': 'MK', salary: false },\n    // { 'name': 'Madagascar', 'code': 'MG', salary: false },\n    // { 'name': 'Malawi', 'code': 'MW', salary: false },\n    { 'name': 'Malaysia', 'code': 'MY', salary: 26117 },\n    // { 'name': 'Maldives', 'code': 'MV', salary: false },\n    // { 'name': 'Mali', 'code': 'ML', salary: false },\n    { 'name': 'Malta', 'code': 'MT', salary: 41971 },\n    // { 'name': 'Marshall Islands', 'code': 'MH', salary: false },\n    // { 'name': 'Martinique', 'code': 'MQ', salary: false },\n    // { 'name': 'Mauritania', 'code': 'MR', salary: false },\n    // { 'name': 'Mauritius', 'code': 'MU', salary: false },\n    // { 'name': 'Mayotte', 'code': 'YT', salary: false },\n    { 'name': 'Mexico', 'code': 'MX', salary: 24050 },\n    // { 'name': 'Micronesia, Federated States of', 'code': 'FM', salary: false },\n    // { 'name': 'Moldova, Republic of', 'code': 'MD', salary: false },\n    // { 'name': 'Monaco', 'code': 'MC', salary: false },\n    // { 'name': 'Mongolia', 'code': 'MN', salary: false },\n    // { 'name': 'Montserrat', 'code': 'MS', salary: false },\n    { 'name': 'Morocco', 'code': 'MA', salary: 17903 },\n    // { 'name': 'Mozambique', 'code': 'MZ', salary: false },\n    // { 'name': 'Myanmar', 'code': 'MM', salary: false },\n    // { 'name': 'Namibia', 'code': 'NA', salary: false },\n    // { 'name': 'Nauru', 'code': 'NR', salary: false },\n    // { 'name': 'Nepal', 'code': 'NP', salary: false },\n    { 'name': 'Netherlands', 'code': 'NL', salary: 62661 },\n    // { 'name': 'Netherlands Antilles', 'code': 'AN', salary: false },\n    // { 'name': 'New Caledonia', 'code': 'NC', salary: false },\n    { 'name': 'New Zealand', 'code': 'NZ', salary: 63948 },\n    // { 'name': 'Nicaragua', 'code': 'NI', salary: false },\n    // { 'name': 'Niger', 'code': 'NE', salary: false },\n    // { 'name': 'Nigeria', 'code': 'NG', salary: false },\n    // { 'name': 'Niue', 'code': 'NU', salary: false },\n    // { 'name': 'Norfolk Island', 'code': 'NF', salary: false },\n    // { 'name': 'Northern Mariana Islands', 'code': 'MP', salary: false },\n    { 'name': 'Norway', 'code': 'NO', salary: 69498 },\n    // { 'name': 'Oman', 'code': 'OM', salary: false },\n    { 'name': 'Pakistan', 'code': 'PK', salary: 9066 },\n    // { 'name': 'Palau', 'code': 'PW', salary: false },\n    // { 'name': 'Palestinian Territory, Occupied', 'code': 'PS', salary: false },\n    { 'name': 'Panama', 'code': 'PA', salary: 39143 },\n    // { 'name': 'Papua New Guinea', 'code': 'PG', salary: false },\n    // { 'name': 'Paraguay', 'code': 'PY', salary: false },\n    { 'name': 'Peru', 'code': 'PE', salary: 17469 },\n    { 'name': 'Philippines', 'code': 'PH', salary: 11088 },\n    // { 'name': 'Pitcairn Islands', 'code': 'PN', salary: false },\n    { 'name': 'Poland', 'code': 'PL', salary: 30236 },\n    { 'name': 'Portugal', 'code': 'PT', salary: 37959 },\n    // { 'name': 'Puerto Rico', 'code': 'PR', salary: false },\n    // { 'name': 'Qatar', 'code': 'QA', salary: false },\n    // { 'name': 'Reunion', 'code': 'RE', salary: false },\n    { 'name': 'Romania', 'code': 'RO', salary: 22319 },\n    { 'name': 'Russian Federation', 'code': 'RU', salary: 20492 },\n    // { 'name': 'Rwanda', 'code': 'RW', salary: false },\n    // { 'name': 'Saint Helena', 'code': 'SH', salary: false },\n    // { 'name': 'Saint Kitts and Nevis', 'code': 'KN', salary: false },\n    // { 'name': 'Saint Lucia', 'code': 'LC', salary: false },\n    // { 'name': 'Saint Pierre and Miquelon', 'code': 'PM', salary: false },\n    // { 'name': 'Saint Vincent and the Grenadines', 'code': 'VC', salary: false },\n    // { 'name': 'Samoa', 'code': 'WS', salary: false },\n    // { 'name': 'San Marino', 'code': 'SM', salary: false },\n    // { 'name': 'Sao Tome and Principe', 'code': 'ST', salary: false },\n    { 'name': 'Saudi Arabia', 'code': 'SA', salary: 47336 },\n    // { 'name': 'Senegal', 'code': 'SN', salary: false },\n    // { 'name': 'Serbia and Montenegro', 'code': 'CS', salary: false },\n    // { 'name': 'Seychelles', 'code': 'SC', salary: false },\n    // { 'name': 'Sierra Leone', 'code': 'SL', salary: false },\n    { 'name': 'Singapore', 'code': 'SG', salary: 66023 },\n    { 'name': 'Slovakia', 'code': 'SK', salary: 29650 },\n    // { 'name': 'Slovenia', 'code': 'SI', salary: false },\n    // { 'name': 'Solomon Islands', 'code': 'SB', salary: false },\n    // { 'name': 'Somalia', 'code': 'SO', salary: false },\n    { 'name': 'South Africa', 'code': 'ZA', salary: 40336 },\n    // { 'name': 'South Georgia and the South Sandwich Islands', 'code': 'GS', salary: false },\n    { 'name': 'Spain', 'code': 'ES', salary: 47819 },\n    // { 'name': 'Sri Lanka', 'code': 'LK', salary: false },\n    // { 'name': 'Sudan', 'code': 'SD', salary: false },\n    // { 'name': 'Suriname', 'code': 'SR', salary: false },\n    // { 'name': 'Svalbard and Jan Mayen', 'code': 'SJ', salary: false },\n    // { 'name': 'Swaziland', 'code': 'SZ', salary: false },\n    { 'name': 'Sweden', 'code': 'SE', salary: 49361 },\n    { 'name': 'Switzerland', 'code': 'CH', salary: 92820 },\n    // { 'name': 'Syrian Arab Republic', 'code': 'SY', salary: false },\n    { 'name': 'Taiwan', 'code': 'TW', salary: 47737 },\n    // { 'name': 'Tajikistan', 'code': 'TJ', salary: false },\n    // { 'name': 'Tanzania, United Republic of', 'code': 'TZ', salary: false },\n    { 'name': 'Thailand', 'code': 'TH', salary: 21772 },\n    // { 'name': 'Timor-Leste', 'code': 'TL', salary: false },\n    // { 'name': 'Togo', 'code': 'TG', salary: false },\n    // { 'name': 'Tokelau', 'code': 'TK', salary: false },\n    // { 'name': 'Tonga', 'code': 'TO', salary: false },\n    // { 'name': 'Trinidad and Tobago', 'code': 'TT', salary: false },\n    // { 'name': 'Tunisia', 'code': 'TN', salary: false },\n    { 'name': 'Turkey', 'code': 'TR', salary: 8788 },\n    // { 'name': 'Turkmenistan', 'code': 'TM', salary: false },\n    // { 'name': 'Turks and Caicos Islands', 'code': 'TC', salary: false },\n    // { 'name': 'Tuvalu', 'code': 'TV', salary: false },\n    // { 'name': 'Uganda', 'code': 'UG', salary: false },\n    { 'name': 'Ukraine', 'code': 'UA', salary: 14139 },\n    { 'name': 'United Arab Emirates', 'code': 'AE', salary: 66381 },\n    { 'name': 'United Kingdom', 'code': 'GB', salary: 61188 },\n    { 'name': 'United States', 'code': 'US', salary: 91935 },\n    // { 'name': 'United States Minor Outlying Islands', 'code': 'UM', salary: false },\n    { 'name': 'Uruguay', 'code': 'UY', salary: 23754 },\n    // { 'name': 'Uzbekistan', 'code': 'UZ', salary: false },\n    // { 'name': 'Vanuatu', 'code': 'VU', salary: false },\n    // { 'name': 'Venezuela', 'code': 'VE', salary: false },\n    { 'name': 'Vietnam', 'code': 'VN', salary: 19058 },\n    // { 'name': 'Virgin Islands, British', 'code': 'VG', salary: false },\n    // { 'name': 'Virgin Islands, U.S.', 'code': 'VI', salary: false },\n    // { 'name': 'Wallis and Futuna', 'code': 'WF', salary: false },\n    // { 'name': 'Western Sahara', 'code': 'EH', salary: false },\n    // { 'name': 'Yemen', 'code': 'YE', salary: false },\n    // { 'name': 'Zambia', 'code': 'ZM', salary: false },\n    // { 'name': 'Zimbabwe', 'code': 'ZN' }\n];\n\n\n//# sourceURL=webpack://rxdb/./docs-src/salaries.ts?");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__esDecorate\": () => (/* binding */ __esDecorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__propKey\": () => (/* binding */ __propKey),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__runInitializers\": () => (/* binding */ __runInitializers),\n/* harmony export */   \"__setFunctionName\": () => (/* binding */ __setFunctionName),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nfunction __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nfunction __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nfunction __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\n\n//# sourceURL=webpack://rxdb/./node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "./node_modules/unload/dist/es/browser.js":
/*!************************************************!*\
  !*** ./node_modules/unload/dist/es/browser.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addBrowser\": () => (/* binding */ addBrowser)\n/* harmony export */ });\n/* global WorkerGlobalScope */\n\nfunction addBrowser(fn) {\n  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) {\n    /**\n     * Because killing a worker does directly stop the excution\n     * of the code, our only chance is to overwrite the close function\n     * which could work some times.\n     * @link https://stackoverflow.com/q/72903255/3443137\n     */\n    var oldClose = self.close.bind(self);\n    self.close = function () {\n      fn();\n      return oldClose();\n    };\n  } else {\n    /**\n     * if we are on react-native, there is no window.addEventListener\n     * @link https://github.com/pubkey/unload/issues/6\n     */\n    if (typeof window.addEventListener !== 'function') {\n      return;\n    }\n\n    /**\n     * for normal browser-windows, we use the beforeunload-event\n     */\n    window.addEventListener('beforeunload', function () {\n      fn();\n    }, true);\n\n    /**\n     * for iframes, we have to use the unload-event\n     * @link https://stackoverflow.com/q/47533670/3443137\n     */\n    window.addEventListener('unload', function () {\n      fn();\n    }, true);\n  }\n\n  /**\n   * TODO add fallback for safari-mobile\n   * @link https://stackoverflow.com/a/26193516/3443137\n   */\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/unload/dist/es/browser.js?");

/***/ }),

/***/ "./node_modules/unload/dist/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/unload/dist/es/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"getSize\": () => (/* binding */ getSize),\n/* harmony export */   \"removeAll\": () => (/* binding */ removeAll),\n/* harmony export */   \"runAll\": () => (/* binding */ runAll)\n/* harmony export */ });\n/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser.js */ \"./node_modules/unload/dist/es/browser.js\");\n/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.js */ \"./node_modules/unload/dist/es/node.js\");\n\n\n\n/**\n * Use the code directly to prevent import problems\n * with the detect-node package.\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar USE_METHOD = isNode ? _node_js__WEBPACK_IMPORTED_MODULE_1__.addNode : _browser_js__WEBPACK_IMPORTED_MODULE_0__.addBrowser;\nvar LISTENERS = new Set();\nvar startedListening = false;\nfunction startListening() {\n  if (startedListening) {\n    return;\n  }\n  startedListening = true;\n  USE_METHOD(runAll);\n}\nfunction add(fn) {\n  startListening();\n  if (typeof fn !== 'function') {\n    throw new Error('Listener is no function');\n  }\n  LISTENERS.add(fn);\n  var addReturn = {\n    remove: function remove() {\n      return LISTENERS[\"delete\"](fn);\n    },\n    run: function run() {\n      LISTENERS[\"delete\"](fn);\n      return fn();\n    }\n  };\n  return addReturn;\n}\nfunction runAll() {\n  var promises = [];\n  LISTENERS.forEach(function (fn) {\n    promises.push(fn());\n    LISTENERS[\"delete\"](fn);\n  });\n  return Promise.all(promises);\n}\nfunction removeAll() {\n  LISTENERS.clear();\n}\nfunction getSize() {\n  return LISTENERS.size;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/unload/dist/es/index.js?");

/***/ }),

/***/ "./node_modules/unload/dist/es/node.js":
/*!*********************************************!*\
  !*** ./node_modules/unload/dist/es/node.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addNode\": () => (/* binding */ addNode)\n/* harmony export */ });\nfunction addNode(fn) {\n  process.on('exit', function () {\n    return fn();\n  });\n\n  /**\n   * on the following events,\n   * the process will not end if there are\n   * event-handlers attached,\n   * therefore we have to call process.exit()\n   */\n  process.on('beforeExit', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches ctrl+c event\n  process.on('SIGINT', function () {\n    return fn().then(function () {\n      return process.exit();\n    });\n  });\n  // catches uncaught exceptions\n  process.on('uncaughtException', function (err) {\n    return fn().then(function () {\n      console.trace(err);\n      process.exit(101);\n    });\n  });\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/unload/dist/es/node.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _construct)\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\");\n\n\nfunction _construct(Parent, args, Class) {\n  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/construct.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _createClass)\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _getPrototypeOf)\n/* harmony export */ });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _inheritsLoose)\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(subClass, superClass);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _isNativeFunction)\n/* harmony export */ });\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _isNativeReflectConstruct)\n/* harmony export */ });\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _setPrototypeOf)\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _toPrimitive)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction _toPrimitive(input, hint) {\n  if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _toPropertyKey)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction _toPropertyKey(arg) {\n  var key = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arg, \"string\");\n  return (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key) === \"symbol\" ? key : String(key);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _typeof)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/typeof.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _wrapNativeSuper)\n/* harmony export */ });\n/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\");\n/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/esm/construct.js\");\n\n\n\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Class, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BroadcastChannel\": () => (/* binding */ BroadcastChannel),\n/* harmony export */   \"OPEN_BROADCAST_CHANNELS\": () => (/* binding */ OPEN_BROADCAST_CHANNELS),\n/* harmony export */   \"clearNodeFolder\": () => (/* binding */ clearNodeFolder),\n/* harmony export */   \"enforceOptions\": () => (/* binding */ enforceOptions)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var _method_chooser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./method-chooser.js */ \"./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options.js */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n\n\n\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nvar OPEN_BROADCAST_CHANNELS = new Set();\nvar lastId = 0;\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.fillOptionsWithDefaults)(options);\n  this.method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsent message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\nfunction clearNodeFolder(options) {\n  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_2__.fillOptionsWithDefaults)(options);\n  var method = (0,_method_chooser_js__WEBPACK_IMPORTED_MODULE_1__.chooseMethod)(options);\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_FALSE;\n  }\n}\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nvar ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was really hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    })\n    // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    })\n    // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsent messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n  if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isPromise)(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happened 'after' the listener\n         * was added, we also listen to events that happened 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    var time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BroadcastChannel\": () => (/* reexport safe */ _broadcast_channel_js__WEBPACK_IMPORTED_MODULE_0__.BroadcastChannel),\n/* harmony export */   \"OPEN_BROADCAST_CHANNELS\": () => (/* reexport safe */ _broadcast_channel_js__WEBPACK_IMPORTED_MODULE_0__.OPEN_BROADCAST_CHANNELS),\n/* harmony export */   \"beLeader\": () => (/* reexport safe */ _leader_election_js__WEBPACK_IMPORTED_MODULE_1__.beLeader),\n/* harmony export */   \"clearNodeFolder\": () => (/* reexport safe */ _broadcast_channel_js__WEBPACK_IMPORTED_MODULE_0__.clearNodeFolder),\n/* harmony export */   \"createLeaderElection\": () => (/* reexport safe */ _leader_election_js__WEBPACK_IMPORTED_MODULE_1__.createLeaderElection),\n/* harmony export */   \"enforceOptions\": () => (/* reexport safe */ _broadcast_channel_js__WEBPACK_IMPORTED_MODULE_0__.enforceOptions)\n/* harmony export */ });\n/* harmony import */ var _broadcast_channel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broadcast-channel.js */ \"./node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js\");\n/* harmony import */ var _leader_election_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./leader-election.js */ \"./node_modules/broadcast-channel/dist/esbrowser/leader-election.js\");\n\n\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/index.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/leader-election.js":
/*!**************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/leader-election.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"beLeader\": () => (/* binding */ beLeader),\n/* harmony export */   \"createLeaderElection\": () => (/* binding */ createLeaderElection)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var unload__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unload */ \"./node_modules/unload/dist/es/index.js\");\n\n\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this.hasLeader = false;\n  this.isDead = false;\n  this.token = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)();\n\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n  this._aplQ = _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  // amount of unfinished applyOnce() calls\n  this._aplQC = 0;\n\n  // things to clean up\n  this._unl = []; // _unloads\n  this._lstns = []; // _listeners\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this.hasLeader = false;\n      }\n      if (msg.action === 'tell') {\n        _this.hasLeader = true;\n      }\n    }\n  };\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n  this._lstns.push(hasLeaderListener);\n};\nLeaderElection.prototype = {\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce(\n  // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n    if (this.isLeader) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0, true);\n    }\n    if (this.isDead) {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(0, false);\n    }\n\n    /**\n     * Already applying more than once,\n     * -> wait for the apply queue to be finished.\n     */\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n\n    /**\n     * Add a new apply-run\n     */\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_TRUE;\n      }\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2.hasLeader = true;\n          }\n        }\n      };\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other instances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n      return _sendMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })\n      // send again in case another instance was just created\n      .then(function () {\n        return _sendMessage(_this2, 'apply');\n      })\n      // let others time to respond\n      .then(function () {\n        return Promise.race([(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n    };\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if ( /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n    return this._aLP;\n  },\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n  die: function die() {\n    var _this3 = this;\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this.hasLeader = false;\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    return _sendMessage(this, 'death');\n  }\n};\n\n/**\n * @param leaderElector {LeaderElector}\n */\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  }\n  return new Promise(function (res) {\n    var resolved = false;\n    function finish() {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n    var tryOnFallBack = function tryOnFallBack() {\n      return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n    tryOnFallBack();\n\n    // try when other leader dies\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\n\n/**\n * sends and internal message over the broadcast-channel\n */\nfunction _sendMessage(leaderElector, action) {\n  var msgJson = {\n    context: 'leader',\n    action: action,\n    token: leaderElector.token\n  };\n  return leaderElector.broadcastChannel.postInternal(msgJson);\n}\nfunction beLeader(leaderElector) {\n  leaderElector.isLeader = true;\n  leaderElector.hasLeader = true;\n  var unloadFn = (0,unload__WEBPACK_IMPORTED_MODULE_1__.add)(function () {\n    return leaderElector.die();\n  });\n  leaderElector._unl.push(unloadFn);\n  var isLeaderListener = function isLeaderListener(msg) {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell');\n    }\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {\n      /**\n       * another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       * @link https://github.com/pubkey/broadcast-channel/issues/414\n       * @link https://github.com/pubkey/broadcast-channel/issues/385\n       */\n      leaderElector._dpLC = true;\n      leaderElector._dpL(); // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem\n    }\n  };\n\n  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);\n  leaderElector._lstns.push(isLeaderListener);\n  return _sendMessage(leaderElector, 'tell');\n}\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n  return options;\n}\nfunction createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = new LeaderElection(channel, options);\n  channel._befC.push(function () {\n    return elector.die();\n  });\n  channel._leaderElector = elector;\n  return elector;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/leader-election.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"chooseMethod\": () => (/* binding */ chooseMethod)\n/* harmony export */ });\n/* harmony import */ var _methods_native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/native.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/native.js\");\n/* harmony import */ var _methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/indexed-db.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js\");\n/* harmony import */ var _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/localstorage.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js\");\n/* harmony import */ var _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/simulate.js */ \"./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js\");\n\n\n\n\n// the line below will be removed from es5/browser builds\n\n// order is important\nvar METHODS = [_methods_native_js__WEBPACK_IMPORTED_MODULE_0__.NativeMethod,\n// fastest\n_methods_indexed_db_js__WEBPACK_IMPORTED_MODULE_1__.IndexedDBMethod, _methods_localstorage_js__WEBPACK_IMPORTED_MODULE_2__.LocalstorageMethod];\nfunction chooseMethod(options) {\n  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // the line below will be removed from es5/browser builds\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return _methods_simulate_js__WEBPACK_IMPORTED_MODULE_3__.SimulateMethod;\n    }\n    var ret = chooseMethods.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage will be chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error(\"No usable method found in \" + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/method-chooser.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndexedDBMethod\": () => (/* binding */ IndexedDBMethod),\n/* harmony export */   \"TRANSACTION_SETTINGS\": () => (/* binding */ TRANSACTION_SETTINGS),\n/* harmony export */   \"averageResponseTime\": () => (/* binding */ averageResponseTime),\n/* harmony export */   \"canBeUsed\": () => (/* binding */ canBeUsed),\n/* harmony export */   \"cleanOldMessages\": () => (/* binding */ cleanOldMessages),\n/* harmony export */   \"close\": () => (/* binding */ close),\n/* harmony export */   \"commitIndexedDBTransaction\": () => (/* binding */ commitIndexedDBTransaction),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"createDatabase\": () => (/* binding */ createDatabase),\n/* harmony export */   \"getAllMessages\": () => (/* binding */ getAllMessages),\n/* harmony export */   \"getIdb\": () => (/* binding */ getIdb),\n/* harmony export */   \"getMessagesHigherThan\": () => (/* binding */ getMessagesHigherThan),\n/* harmony export */   \"getOldMessages\": () => (/* binding */ getOldMessages),\n/* harmony export */   \"microSeconds\": () => (/* binding */ microSeconds),\n/* harmony export */   \"onMessage\": () => (/* binding */ onMessage),\n/* harmony export */   \"postMessage\": () => (/* binding */ postMessage),\n/* harmony export */   \"removeMessagesById\": () => (/* binding */ removeMessagesById),\n/* harmony export */   \"type\": () => (/* binding */ type),\n/* harmony export */   \"writeMessage\": () => (/* binding */ writeMessage)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"./node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../options.js */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n * \n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\n\nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\n\n\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nvar TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nvar type = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nfunction commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nfunction createDatabase(channelName) {\n  var IndexedDB = getIdb();\n\n  // create table\n  var dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  var openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  return new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nfunction writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise(function (res, rej) {\n    tx.oncomplete = function () {\n      return res();\n    };\n    tx.onerror = function (ev) {\n      return rej(ev);\n    };\n    var objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nfunction getAllMessages(db) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor[\"continue\"]();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    var getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise(function (res, rej) {\n      getAllRequest.onerror = function (err) {\n        return rej(err);\n      };\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise(function (res, rej) {\n    var openCursorRequest = openCursor();\n    openCursorRequest.onerror = function (err) {\n      return rej(err);\n    };\n    openCursorRequest.onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor[\"continue\"](lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor[\"continue\"]();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessagesById(channelState, ids) {\n  if (channelState.closed) {\n    return Promise.resolve([]);\n  }\n  var tx = channelState.db.transaction(OBJECT_STORE_ID, 'readwrite', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(function (id) {\n    var deleteRequest = objectStore[\"delete\"](id);\n    return new Promise(function (res) {\n      deleteRequest.onsuccess = function () {\n        return res();\n      };\n    });\n  }));\n}\nfunction getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  var objectStore = tx.objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n      if (cursor) {\n        var msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(channelState) {\n  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function (tooOld) {\n    return removeMessagesById(channelState, tooOld.map(function (msg) {\n      return msg.id;\n    }));\n  });\n}\nfunction create(channelName, options) {\n  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_1__.fillOptionsWithDefaults)(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomToken)(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parallel\n      writeBlockPromise: _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(function () {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.sleep)(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined sometimes\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  });\n}\nfunction close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.randomInt)(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed() {\n  return !!getIdb();\n}\nfunction averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nvar IndexedDBMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LocalstorageMethod\": () => (/* binding */ LocalstorageMethod),\n/* harmony export */   \"addStorageEventListener\": () => (/* binding */ addStorageEventListener),\n/* harmony export */   \"averageResponseTime\": () => (/* binding */ averageResponseTime),\n/* harmony export */   \"canBeUsed\": () => (/* binding */ canBeUsed),\n/* harmony export */   \"close\": () => (/* binding */ close),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"getLocalStorage\": () => (/* binding */ getLocalStorage),\n/* harmony export */   \"microSeconds\": () => (/* binding */ microSeconds),\n/* harmony export */   \"onMessage\": () => (/* binding */ onMessage),\n/* harmony export */   \"postMessage\": () => (/* binding */ postMessage),\n/* harmony export */   \"removeStorageEventListener\": () => (/* binding */ removeStorageEventListener),\n/* harmony export */   \"storageKey\": () => (/* binding */ storageKey),\n/* harmony export */   \"type\": () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! oblivious-set */ \"./node_modules/oblivious-set/dist/es/index.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../options.js */ \"./node_modules/broadcast-channel/dist/esbrowser/options.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside webworkers because they have no access to localstorage\n * This is basically implemented to support IE9 or your grandmother's toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\n\n\n\nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_1__.microSeconds;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nvar type = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nfunction getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nfunction postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.sleep)().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomToken)(),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create(channelName, options) {\n  options = (0,_options_js__WEBPACK_IMPORTED_MODULE_0__.fillOptionsWithDefaults)(options);\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  var uuid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomToken)();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  var eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_2__.ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n  };\n\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  var ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nfunction averageResponseTime() {\n  var defaultTime = 120;\n  var userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\nvar LocalstorageMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/native.js":
/*!*************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/native.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NativeMethod\": () => (/* binding */ NativeMethod),\n/* harmony export */   \"averageResponseTime\": () => (/* binding */ averageResponseTime),\n/* harmony export */   \"canBeUsed\": () => (/* binding */ canBeUsed),\n/* harmony export */   \"close\": () => (/* binding */ close),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"microSeconds\": () => (/* binding */ microSeconds),\n/* harmony export */   \"onMessage\": () => (/* binding */ onMessage),\n/* harmony export */   \"postMessage\": () => (/* binding */ postMessage),\n/* harmony export */   \"type\": () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n\nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\nvar type = 'native';\nfunction create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n  return state;\n}\nfunction close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction averageResponseTime() {\n  return 150;\n}\nvar NativeMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/methods/native.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js":
/*!***************************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimulateMethod\": () => (/* binding */ SimulateMethod),\n/* harmony export */   \"averageResponseTime\": () => (/* binding */ averageResponseTime),\n/* harmony export */   \"canBeUsed\": () => (/* binding */ canBeUsed),\n/* harmony export */   \"close\": () => (/* binding */ close),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"microSeconds\": () => (/* binding */ microSeconds),\n/* harmony export */   \"onMessage\": () => (/* binding */ onMessage),\n/* harmony export */   \"postMessage\": () => (/* binding */ postMessage),\n/* harmony export */   \"type\": () => (/* binding */ type)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"./node_modules/broadcast-channel/dist/esbrowser/util.js\");\n\nvar microSeconds = _util_js__WEBPACK_IMPORTED_MODULE_0__.microSeconds;\nvar type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nfunction create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nfunction close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nfunction postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  return 5;\n}\nvar SimulateMethod = {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/options.js":
/*!******************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/options.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fillOptionsWithDefaults\": () => (/* binding */ fillOptionsWithDefaults)\n/* harmony export */ });\nfunction fillOptionsWithDefaults() {\n  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n\n  // node\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n  /**\n   * On linux use 'ulimit -Hn' to get the limit of open files.\n   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.\n   */\n  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/options.js?");

/***/ }),

/***/ "./node_modules/broadcast-channel/dist/esbrowser/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/broadcast-channel/dist/esbrowser/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PROMISE_RESOLVED_FALSE\": () => (/* binding */ PROMISE_RESOLVED_FALSE),\n/* harmony export */   \"PROMISE_RESOLVED_TRUE\": () => (/* binding */ PROMISE_RESOLVED_TRUE),\n/* harmony export */   \"PROMISE_RESOLVED_VOID\": () => (/* binding */ PROMISE_RESOLVED_VOID),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"microSeconds\": () => (/* binding */ microSeconds),\n/* harmony export */   \"randomInt\": () => (/* binding */ randomInt),\n/* harmony export */   \"randomToken\": () => (/* binding */ randomToken),\n/* harmony export */   \"sleep\": () => (/* binding */ sleep)\n/* harmony export */ });\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\nvar PROMISE_RESOLVED_FALSE = Promise.resolve(false);\nvar PROMISE_RESOLVED_TRUE = Promise.resolve(true);\nvar PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      return res(resolveWith);\n    }, time);\n  });\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nfunction randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nvar lastMs = 0;\nvar additional = 0;\n\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nfunction microSeconds() {\n  var ms = new Date().getTime();\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n\n//# sourceURL=webpack://rxdb/./node_modules/broadcast-channel/dist/esbrowser/util.js?");

/***/ }),

/***/ "./node_modules/dexie/dist/modern/dexie.mjs":
/*!**************************************************!*\
  !*** ./node_modules/dexie/dist/modern/dexie.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dexie\": () => (/* binding */ Dexie$1),\n/* harmony export */   \"Entity\": () => (/* binding */ Entity),\n/* harmony export */   \"RangeSet\": () => (/* binding */ RangeSet),\n/* harmony export */   \"cmp\": () => (/* binding */ cmp),\n/* harmony export */   \"default\": () => (/* binding */ Dexie$1),\n/* harmony export */   \"liveQuery\": () => (/* binding */ liveQuery),\n/* harmony export */   \"mergeRanges\": () => (/* binding */ mergeRanges),\n/* harmony export */   \"rangesOverlap\": () => (/* binding */ rangesOverlap)\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 4.0.0-alpha.4, Tue May 31 2022\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '4.0.0-alpha.4';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nfunction Entity() {\n    throw exceptions.Type();\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        const { db, name: tableName } = this;\n        this.schema.mappedClass = constructor;\n        if (constructor.prototype instanceof Entity) {\n            constructor = class extends constructor {\n                get db() { return db; }\n                table() { return tableName; }\n            };\n        }\n        const inheritedProps = new Set();\n        for (let proto = constructor.prototype; proto; proto = getProto(proto)) {\n            Object.getOwnPropertyNames(proto).forEach(propName => inheritedProps.add(propName));\n        }\n        const readHook = (obj) => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (let m in obj)\n                if (!inheritedProps.has(m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed) {\n                return;\n            }\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed) {\n                    return;\n                }\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {\n                    querying = false;\n                    observer.error && observer.error(err);\n                    subscription.unsubscribe();\n                }\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === 'function') {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', (ev) => {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\n\n//# sourceMappingURL=dexie.mjs.map\n\n\n//# sourceURL=webpack://rxdb/./node_modules/dexie/dist/modern/dexie.mjs?");

/***/ }),

/***/ "./node_modules/ohash/dist/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/ohash/dist/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hash\": () => (/* binding */ hash),\n/* harmony export */   \"isEqual\": () => (/* binding */ isEqual),\n/* harmony export */   \"murmurHash\": () => (/* binding */ murmurHash),\n/* harmony export */   \"objectHash\": () => (/* binding */ objectHash),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256)\n/* harmony export */ });\nconst defaults = {\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false\n};\nfunction objectHash(object, options = {}) {\n  options = { ...defaults, ...options };\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nfunction createHasher(options) {\n  const buff = [];\n  let context = [];\n  const write = (str) => {\n    buff.push(str);\n  };\n  return {\n    toString() {\n      return buff.join(\"\");\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[\"_\" + type](value);\n    },\n    _object(object) {\n      const pattern = /\\[object (.*)]/i;\n      const objString = Object.prototype.toString.call(object);\n      const _objType = pattern.exec(objString);\n      const objType = _objType ? _objType[1].toLowerCase() : \"unknown:[\" + objString.toLowerCase() + \"]\";\n      let objectNumber = null;\n      if ((objectNumber = context.indexOf(object)) >= 0) {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      } else {\n        context.push(object);\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[\"_\" + objType]) {\n          this[\"_\" + objType](object);\n        } else if (options.ignoreUnknown) {\n          return write(\"[\" + objType + \"]\");\n        } else {\n          throw new Error('Unknown object type \"' + objType + '\"');\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          keys.splice(0, 0, \"prototype\", \"__proto__\", \"letructor\");\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter(function(key) {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + keys.length + \":\");\n        for (const key of keys) {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        }\n      }\n    },\n    _array(arr, unordered) {\n      unordered = typeof unordered !== \"undefined\" ? unordered : options.unorderedArrays !== false;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = [];\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        contextAdditions.push(hasher.getContext());\n        return hasher.toString();\n      });\n      context = [...context, ...contextAdditions];\n      entries.sort();\n      return this._array(entries, false);\n    },\n    _date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    _symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    _error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    _boolean(bool) {\n      return write(\"bool:\" + bool.toString());\n    },\n    _string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string.toString());\n    },\n    _function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this._object(fn);\n      }\n    },\n    _number(number) {\n      return write(\"number:\" + number.toString());\n    },\n    _xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    _null() {\n      return write(\"Null\");\n    },\n    _undefined() {\n      return write(\"Undefined\");\n    },\n    _regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    _uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    _url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    _map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this._array(arr, options.unorderedSets !== false);\n    },\n    _file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    _blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error('Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n');\n    },\n    _domwindow() {\n      return write(\"domwindow\");\n    },\n    _bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    _process() {\n      return write(\"process\");\n    },\n    _timer() {\n      return write(\"timer\");\n    },\n    _pipe() {\n      return write(\"pipe\");\n    },\n    _tcp() {\n      return write(\"tcp\");\n    },\n    _udp() {\n      return write(\"udp\");\n    },\n    _tty() {\n      return write(\"tty\");\n    },\n    _statwatcher() {\n      return write(\"statwatcher\");\n    },\n    _securecontext() {\n      return write(\"securecontext\");\n    },\n    _connection() {\n      return write(\"connection\");\n    },\n    _zlib() {\n      return write(\"zlib\");\n    },\n    _context() {\n      return write(\"context\");\n    },\n    _nodescript() {\n      return write(\"nodescript\");\n    },\n    _httpparser() {\n      return write(\"httpparser\");\n    },\n    _dataview() {\n      return write(\"dataview\");\n    },\n    _signal() {\n      return write(\"signal\");\n    },\n    _fsevent() {\n      return write(\"fsevent\");\n    },\n    _tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  const exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code]\\s+}$/i;\n  return exp.exec(Function.prototype.toString.call(f)) != null;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes !== void 0 ? sigBytes : words.length * 4;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push(\n        (bite >>> 4).toString(16),\n        (bite & 15).toString(16)\n      );\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n    this.reset();\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225];\nconst K = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super();\n    this.reset();\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256(message) {\n  return new SHA256().finalize(message).toString();\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nfunction murmurHash(key, seed = 0) {\n  if (typeof key === \"string\") {\n    key = createBuffer(key);\n  }\n  let i = 0;\n  let h1 = seed;\n  let k1;\n  let h1b;\n  const remainder = key.length & 3;\n  const bytes = key.length - remainder;\n  const c1 = 3432918353;\n  const c2 = 461845907;\n  while (i < bytes) {\n    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;\n    ++i;\n    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n    k1 = k1 << 15 | k1 >>> 17;\n    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n    h1 ^= k1;\n    h1 = h1 << 13 | h1 >>> 19;\n    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;\n    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);\n  }\n  k1 = 0;\n  switch (remainder) {\n    case 3:\n      k1 ^= (key[i + 2] & 255) << 16;\n      break;\n    case 2:\n      k1 ^= (key[i + 1] & 255) << 8;\n      break;\n    case 1:\n      k1 ^= key[i] & 255;\n      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;\n      k1 = k1 << 15 | k1 >>> 17;\n      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;\n      h1 ^= k1;\n  }\n  h1 ^= key.length;\n  h1 ^= h1 >>> 16;\n  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 13;\n  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;\n  h1 ^= h1 >>> 16;\n  return h1 >>> 0;\n}\nfunction createBuffer(val) {\n  return new TextEncoder().encode(val);\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\n\n\n\n//# sourceURL=webpack://rxdb/./node_modules/ohash/dist/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./docs-src/premium.ts");
/******/ 	
/******/ })()
;